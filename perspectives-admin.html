// index.js
import { DateTime } from 'luxon';
import admin from 'firebase-admin';
import { google } from 'googleapis';
import fetch from 'node-fetch';
import express from 'express';
import * as cheerio from 'cheerio';
import puppeteer from 'puppeteer';
import { createRequire } from 'module';
const require = createRequire(import.meta.url);

// Import Perspectives functions (will be loaded when endpoints are called)
let perspectivesCore;
async function loadPerspectivesCore() {
  if (!perspectivesCore) {
    perspectivesCore = await import('./perspectives-core.js');
  }
  return perspectivesCore;
}




// Firebase Admin initialization using application default credentials
let db;
function initializeFirebase() {
if (db) return db; // Return existing db instance if already initialized
if (!admin.apps.length) {
 admin.initializeApp({
   credential: admin.credential.applicationDefault(),
   projectId: process.env.FIREBASE_PROJECT_ID
 });
}
db = admin.firestore();
console.log('Firebase Firestore initialized.');
return db;
}




const SPREADSHEET_ID = process.env.SPREADSHEET_ID;
const SHEET_NAME = process.env.SHEET_NAME;
const RAPIDAPI_KEY = process.env.RAPIDAPI_KEY;
const RAPIDAPI_HOST = process.env.RAPIDAPI_HOST;
const FIREBASE_PROJECT_ID = process.env.FIREBASE_PROJECT_ID;
const API_REQUEST_DELAY_MS = 1500;
// Delay to allow Apps Script onChange (UTC->EST) to finish before reading/filtering
const SHEETS_CONVERSION_DELAY_MS = parseInt(process.env.SHEETS_CONVERSION_DELAY_MS || '60000', 10);

// Google Sheets configuration for importing games
const SHEET_ID = '1gGY9dr485hf4WrdGkx01kC6Gw7oTuKeYYh_UQD5qkt4';
const SHEET_ID_2 = '1qpr6PShU_wGH0JzBQGqklYEqwV1c0Ho8KhSjgBxhtN8';
const SHEET_ID_3 = '1Kbkg7jZOoiynLX5QPnM-T6M3gSYRZxMgOyJ5xxfHN4Q';
const SHEET_ID_4 = '1Yw2A9-7hgGaZEOftq9REuRPp9SCF6hTBmtx79MN790s';
const MANUAL_LEAGUES_TO_SPORTSGAMES = ['MotoGP', 'Boxing', 'UFC', 'PGATour', 'LPGATour', 'LIVGolf', 'USMNT', 'FormulaOne', 'NCAAM', 'NCAAW'];
const LEAGUE_DISPLAY_NAME_MAP = {
  'MotoGP': 'MotoGP',
  'Boxing': 'Boxing',
  'UFC': 'UFC',
  'PGATour': 'PGA Tour',
  'LPGATour': 'LPGA Tour',
  'LIVGolf': 'LIV Golf',
  'USMNT': 'USMNT',
  'FormulaOne': 'Formula 1',
  'NCAAM': 'USA: NCAA',
  'NCAAW': 'USA: NCAA Women'
};
const LEAGUE_TO_SPORT_MAP = {
  'MotoGP': 'Motorsport',
  'Boxing': 'Boxing',
  'UFC': 'Boxing',
  'PGATour': 'Motorsport',
  'LPGATour': 'Motorsport',
  'LIVGolf': 'Motorsport',
  'USMNT': 'Soccer',
  'FormulaOne': 'Motorsport',
  'NCAAM': 'Basketball',
  'NCAAW': 'Basketball'
};
const MANUAL_LEAGUE_CONFIGS = {
  'MotoGP': {
    sheetName: 'MotoGP',
    fields: {
      date: 'Date',
      time: 'Time',
      awayTeam: 'Away Team',
      homeTeam: 'Home Team',
      channel: 'Channel'
    }
  },
  'Boxing': {
    sheetName: 'Boxing',
    fields: {
      date: 'Date',
      time: 'Time',
      awayTeam: 'Away Team',
      homeTeam: 'Home Team',
      channel: 'Channel'
    }
  },
  'UFC': {
    sheetName: 'UFC',
    fields: {
      date: 'Date',
      time: 'Time',
      awayTeam: 'Away Team',
      homeTeam: 'Home Team',
      channel: 'Channel'
    }
  },
  'PGATour': {
    sheetName: 'PGATour',
    fields: {
      date: 'Date',
      time: 'Time',
      awayTeam: 'Away Team',
      homeTeam: 'Home Team',
      channel: 'Channel'
    }
  },
  'LPGATour': {
    sheetName: 'LPGATour',
    fields: {
      date: 'Date',
      time: 'Time',
      awayTeam: 'Away Team',
      homeTeam: 'Home Team',
      channel: 'Channel'
    }
  },
  'LIVGolf': {
    sheetName: 'LIVGolf',
    fields: {
      date: 'Date',
      time: 'Time',
      awayTeam: 'Away Team',
      homeTeam: 'Home Team',
      channel: 'Channel'
    }
  },
  'USMNT': {
    sheetName: 'USMNT',
    fields: {
      date: 'Date',
      time: 'Time',
      awayTeam: 'Away Team',
      homeTeam: 'Home Team',
      channel: 'Channel'
    }
  },
  'FormulaOne': {
    sheetName: 'FormulaOne',
    fields: {
      date: 'Date',
      time: 'Time',
      awayTeam: 'Away Team',
      homeTeam: 'Home Team',
      channel: 'Channel'
    }
  },
  'NCAAM': {
    sheetName: 'NCAAM',
    fields: {
      date: 'Date',
      time: 'Time',
      awayTeam: 'Away Team',
      homeTeam: 'Home Team',
      channel: 'Channel'
    }
  },
  'NCAAW': {
    sheetName: 'NCAAW',
    fields: {
      date: 'Date',
      time: 'Time',
      awayTeam: 'Away Team',
      homeTeam: 'Home Team',
      channel: 'Channel'
    }
  }
};




// Allowed leagues with sport-specific filtering
const ALLOWED_LEAGUE_KEYWORDS = {
// Soccer-specific leagues
'Soccer': [
  "Euro Women", "Europe: Conference League - League phase", "Leagues Cup", "Europa League", "North & Central America: Leagues Cup - Play Offs",
  // "World: Club Friendly", // Commented out - can be easily re-added later
  "Conference League", "Portugal: Super Cup", "UEFA Champions League", "Europe: Champions League - League phase",
  "World: Friendly International",
  "England: Premier League", "England: EFL Cup", "England: FA Cup", "Italy: Coppa Italia", "USA: MLS - Play Offs",
  "Turkey: Super Lig", "Europe: Europa League - Qualification", "Europe: Europa League - League phase", "Europe: Champions League Women - Qualification - Second stage",
  "Europe: Conference League - Qualification", "Germany: Bundesliga", "Portugal: Liga Portugal", "Italy: Serie A",
  "France: Ligue 1", "South America: Copa Libertadores - Play Offs", "Brazil: Serie A Betano", "World: World Cup U20", "World: World Cup U17",
  "South America: Copa Sudamericana - Play Offs", "Europe: Champions League - Qualification",
  "Germany: DFB Pokal", "World: Club Friendly", "Spain: LaLiga", "USA: NWSL Women", "USA: NWSL Women - Play Offs","USA: MLS", "USA: MLS - Play Offs", "Mexico: Liga MX", "Mexico: Liga MX - Apertura", "Mexico: Liga MX - Clausura", "Mexico: Liga MX - Apertura - Play In", "Mexico: Liga MX - Apertura - Play Offs", "Saudi Arabia: Saudi Professional League",
  // ‚úÖ Newly added
  "England: Championship", "World: World Cup U20 - Play Offs", "World: World Cup U17 - Play Offs", "USA: USL Championship", "Europe: Champions League Women - League phase", "Scotland: Premiership", "England: WSL", "Netherlands: Eredivisie", "North & Central America: Campeones Cup", "Argentina: Torneo Betano - Clausura", "Argentina: Torneo Betano - Apertura", "Argentina: Torneo Betano - Clausura - Play Offs", "Scotland: Scottish Cup", "Belgium: Jupiler Pro League", "Spain: Copa del Rey",
  "USWNT", "USMNT"
],
// Basketball-specific leagues
'Basketball': [
  "USA: NBA", "NBA", "USA: WNBA", "WNBA", "World: AmeriCup", "USA: NBA - Pre-season", "USA: NCAA", "USA: NCAA Women",
  // ‚úÖ Newly added
  "USA: WNBA - Play Offs"
],
// American Football-specific leagues
'American Football': [
  "NFL", "USA: NFL", "USA: NCAA", "USA: NFL - Pre-season", "Canada: CFL"
],
// Tennis-specific leagues
'Tennis': [
  "USA: Cleveland WTA, hard",
  "USA: US Open ATP, hard", "USA: US Open WTA, hard"
],
// Auto Racing specific leagues
'Auto Racing': [
  "NASCAR Cup Series"
],
// Cricket-specific leagues
'Cricket': [
  "World: ICC World Cup Women", "World: Twenty20 International", "World: Test Series", "World: One Day International"
],
// Hockey-specific leagues
'Hockey': [
  "USA: NHL", "NHL", "USA: NHL - Pre-season", "Canada: OHL", "USA: NCAA"
],
// Golf-specific leagues
'Golf': [
  // ‚úÖ Newly added
  "World: Ryder Cup", "DP World Tour", "PGA Champions"
],
// Motorsport-specific leagues (using regex-like matching in filter)
'Motorsport': [
  // TEMPORARILY DISABLED: Formula 1 is now handled via manual entry
  // All Formula 1 events will be matched by game.League.includes('Formula 1') in deduplication
  // "Formula 1"
]
};




const sportsToFetch = [
// { slug: 'soccer', id: 1, name: 'Soccer' },
// { slug: 'tennis', id: 2, name: 'Tennis' },
// { slug: 'basketball', id: 3, name: 'Basketball' },
// { slug: 'hockey', id: 4, name: 'Hockey' },
// { slug: 'football', id: 5, name: 'American Football' },
// { slug: 'baseball', id: 6, name: 'Baseball' },
// { slug: 'rugby_union', id: 8, name: 'Rugby Union' },
// { slug: 'volleyball', id: 12, name: 'Volleyball' },
// { slug: 'cricket', id: 13, name: 'Cricket' },
// { slug: 'boxing', id: 16, name: 'Boxing' },
// { slug: 'beach_volleyball', id: 17, name: 'Beach Volleyball' },
// { slug: 'aussie_rules', id: 18, name: 'Aussie Rules' },
// { slug: 'rugby_league', id: 19, name: 'Rugby League' },
// { slug: 'water_polo', id: 22, name: 'Water Polo' },
// { slug: 'golf', id: 23, name: 'Golf' },
// { slug: 'mma', id: 28, name: 'MMA' },
// { slug: 'motorsport', id: 31, name: 'Motorsport' },
// { slug: 'autoracing', id: 32, name: 'Autoracing' },
// { slug: 'motoracing', id: 33, name: 'Motoracing' },
// { slug: 'cycling', id: 34, name: 'Cycling' },
// { slug: 'horse_racing', id: 35, name: 'Horse Racing' },
// { slug: 'winter_sports', id: 37, name: 'Winter Sports' },
// { slug: 'ski_jumping', id: 38, name: 'Ski Jumping' },
// { slug: 'alpine_skiing', id: 39, name: 'Alpine Skiing' },
// { slug: 'cross_country', id: 40, name: 'Cross Country' }
];




// Mapping of leagues to their RapidAPI sport slug, sport ID, and league name for the new function
const leaguesToFetch = [
{ slug: 'golf', id: 23, leagueName: 'PGA Tour' },
{ slug: 'tennis', id: 2, leagueName: 'ATP' },
{ slug: 'tennis', id: 2, leagueName: 'WTA' },
{ slug: 'football', id: 5, leagueName: 'USA: NCAA' },
{ slug: 'soccer', id: 1, leagueName: 'NWSL Women' },
{ slug: 'soccer', id: 1, leagueName: 'France: Ligue 1' },
{ slug: 'soccer', id: 1, leagueName: 'Europe: Europa League' },
{ slug: 'soccer', id: 1, leagueName: 'Europe: Conference League' }
];




let sheets;
let serviceAccountEmail = null;

// Rate limiter for Google Sheets API (60 requests/minute = 1 request/second, using 1.5s for safety)
let lastSheetRequestTime = 0;
const MIN_TIME_BETWEEN_REQUESTS = 1500; // 1.5 seconds between requests

async function rateLimitedSheetRequest(requestFn, retries = 5) {
  for (let attempt = 1; attempt <= retries; attempt++) {
    try {
      // Wait if needed to respect rate limit
      const now = Date.now();
      const timeSinceLastRequest = now - lastSheetRequestTime;
      if (timeSinceLastRequest < MIN_TIME_BETWEEN_REQUESTS) {
        const waitTime = MIN_TIME_BETWEEN_REQUESTS - timeSinceLastRequest;
        await new Promise(resolve => setTimeout(resolve, waitTime));
      }
      
      lastSheetRequestTime = Date.now();
      const result = await requestFn();
      return result;
    } catch (error) {
      const isQuotaError = error.message && (
        error.message.includes('Quota exceeded') ||
        error.message.includes('quota') ||
        error.message.includes('rate limit') ||
        error.message.includes('429') ||
        (error.code === 429) ||
        (error.response && error.response.status === 429)
      );
      
      if (isQuotaError && attempt < retries) {
        // Exponential backoff: 2s, 4s, 8s, 16s, 32s
        const backoffTime = Math.min(2000 * Math.pow(2, attempt - 1), 32000);
        console.warn(`‚ö†Ô∏è  Google Sheets quota error (attempt ${attempt}/${retries}). Retrying in ${backoffTime/1000}s...`);
        await new Promise(resolve => setTimeout(resolve, backoffTime));
        continue;
      }
      
      // If not a quota error or out of retries, throw the error
      throw error;
    }
  }
}

async function authenticateGoogleSheets() {
if (sheets) return;
const googleAuth = new google.auth.GoogleAuth({
 scopes: ['https://www.googleapis.com/auth/spreadsheets'],
});
const authClient = await googleAuth.getClient();
// Log which service account is being used
const projectId = await googleAuth.getProjectId();
const credentials = await googleAuth.getCredentials();
console.log(`Google Sheets API authenticated. Project: ${projectId}`);
if (credentials.client_email) {
  serviceAccountEmail = credentials.client_email;
  console.log(`Using service account: ${serviceAccountEmail}`);
} else {
  console.log('Using application default credentials (service account determined by Cloud Run)');
}
sheets = google.sheets({ version: 'v4', auth: authClient });
}

async function clearGoogleSheet(spreadsheetId, sheetName) {
  try {
    console.log(`Clearing Google Sheet "${sheetName}"...`);
    await rateLimitedSheetRequest(() => 
      sheets.spreadsheets.values.clear({
        spreadsheetId: spreadsheetId,
        range: `${sheetName}!A:Z`
      })
    );
    console.log(`Successfully cleared Google Sheet "${sheetName}".`);
  } catch (err) {
    console.error(`Error clearing Google Sheet "${sheetName}":`, err.message);
    throw err;
  }
}

// Helper functions for manual games import
function parseDateForManualGames(dateStr) {
  if (!dateStr) return null;
  
  let date;
  
  // If it's a number (Excel serial date), convert it
  // Excel/Google Sheets date is days since 1899-12-30
  if (typeof dateStr === 'number') {
    // Excel epoch is December 30, 1899
    const excelEpoch = new Date('1899-12-30T00:00:00Z');
    const daysSinceEpoch = Math.floor(dateStr);
    date = new Date(excelEpoch.getTime() + daysSinceEpoch * 24 * 60 * 60 * 1000);
  } else {
    // Try to parse as a date string
    date = new Date(dateStr);
  }
  
  if (isNaN(date.getTime())) {
    console.warn(`Invalid date: ${dateStr}`);
    return null;
  }
  
  const year = date.getUTCFullYear();
  const month = String(date.getUTCMonth() + 1).padStart(2, '0');
  const day = String(date.getUTCDate()).padStart(2, '0');
  return `${year}-${month}-${day}`;
}

function parseTimeForManualGames(timeStr) {
  if (!timeStr) return '';
  
  // If it's already a string with time format, return it
  if (typeof timeStr === 'string' && timeStr.includes(':')) {
    return timeStr.trim();
  }
  
  let hours = 0;
  let minutes = 0;
  
  // If it's a number (Excel serial time), convert it
  // Excel/Google Sheets time is a fraction of a day (0.0 = midnight, 0.5 = noon)
  if (typeof timeStr === 'number') {
    const totalSeconds = Math.floor(timeStr * 86400); // 86400 seconds in a day
    hours = Math.floor(totalSeconds / 3600);
    minutes = Math.floor((totalSeconds % 3600) / 60);
  }
  // If it's a Date object, Google Sheets returns time-only values as Date objects
  // The Date object represents the time in UTC, but we need to extract it as EST
  // Google Sheets stores time-only values using Excel epoch (1899-12-30) as the date
  else if (timeStr instanceof Date) {
    // Check if this is a time-only value (date is 1899-12-30, Excel epoch)
    const isTimeOnly = timeStr.getUTCFullYear() === 1899 && 
                       timeStr.getUTCMonth() === 11 && 
                       timeStr.getUTCDate() === 30;
    
    if (isTimeOnly) {
      // This is a time-only value - extract UTC hours/minutes (these represent the raw time)
      hours = timeStr.getUTCHours();
      minutes = timeStr.getUTCMinutes();
    } else {
      // This is a full datetime - extract UTC hours/minutes
      hours = timeStr.getUTCHours();
      minutes = timeStr.getUTCMinutes();
    }
  } else {
    return String(timeStr).trim();
  }
  
  // Format as "H:MM AM/PM" - these hours/minutes represent EST time from Google Sheets
  const ampm = hours >= 12 ? 'PM' : 'AM';
  let displayHours = hours % 12;
  if (displayHours === 0) displayHours = 12;
  const displayMinutes = minutes.toString().padStart(2, '0');
  return `${displayHours}:${displayMinutes} ${ampm}`;
}

function createFirestoreTimestamp(dateStr, timeStr) {
  if (!dateStr) return null;
  
  // All times in sheets 1-4 are in Eastern U.S. time
  // Parse date and time as Eastern, then convert to UTC for Firestore
  let dateTime;
  
  if (dateStr.match(/^\d{4}-\d{2}-\d{2}$/)) {
    const [year, month, day] = dateStr.split('-').map(Number);
    
    if (timeStr) {
      // Parse time in Eastern timezone
      const timeMatch = timeStr.match(/(\d+):(\d+)\s*(AM|PM)?/i);
      if (timeMatch) {
        let hours = parseInt(timeMatch[1]);
        const minutes = parseInt(timeMatch[2]);
        const ampm = timeMatch[3]?.toUpperCase();
        
        // Handle AM/PM conversion
        if (ampm === 'PM' && hours !== 12) hours += 12;
        if (ampm === 'AM' && hours === 12) hours = 0;
        
        // Create DateTime in Eastern timezone, then convert to UTC
        dateTime = DateTime.fromObject({
          year,
          month,
          day,
          hour: hours,
          minute: minutes,
          second: 0
        }, { zone: 'America/New_York' });
      } else {
        // No valid time, use midnight Eastern
        dateTime = DateTime.fromObject({
          year,
          month,
          day,
          hour: 0,
          minute: 0,
          second: 0
        }, { zone: 'America/New_York' });
      }
    } else {
      // No time provided, use midnight Eastern
      dateTime = DateTime.fromObject({
        year,
        month,
        day,
        hour: 0,
        minute: 0,
        second: 0
      }, { zone: 'America/New_York' });
    }
  } else {
    // Fallback for other date formats
    const date = new Date(dateStr);
    if (isNaN(date.getTime())) {
      console.warn(`Invalid date for timestamp: ${dateStr}`);
      return null;
    }
    dateTime = DateTime.fromJSDate(date, { zone: 'America/New_York' });
    if (timeStr) {
      const timeMatch = timeStr.match(/(\d+):(\d+)\s*(AM|PM)?/i);
      if (timeMatch) {
        let hours = parseInt(timeMatch[1]);
        const minutes = parseInt(timeMatch[2]);
        const ampm = timeMatch[3]?.toUpperCase();
        if (ampm === 'PM' && hours !== 12) hours += 12;
        if (ampm === 'AM' && hours === 12) hours = 0;
        dateTime = dateTime.set({ hour: hours, minute: minutes });
      }
    }
  }
  
  if (!dateTime || !dateTime.isValid) {
    console.warn(`Invalid date/time for timestamp: ${dateStr} ${timeStr}`);
    return null;
  }
  
  // Convert to UTC and create Firestore timestamp
  const utcDate = dateTime.toUTC().toJSDate();
  return admin.firestore.Timestamp.fromDate(utcDate);
}

async function getManualSheetData(sheetName) {
  try {
    const response = await rateLimitedSheetRequest(() =>
      sheets.spreadsheets.values.get({
        spreadsheetId: SHEET_ID_4,
        range: `${sheetName}!A:Z`,
        valueRenderOption: 'UNFORMATTED_VALUE' // Get raw values (numbers) instead of formatted strings/Date objects
      })
    );
    return response.data.values || [];
  } catch (error) {
    console.error(`Error reading sheet ${sheetName}:`, error.message);
    return [];
  }
}

async function fetchManualGamesFromSheets(todayStr, tomorrowStr) {
  const allManualGames = [];
  
  console.log(`Looking for manual games with dates: today=${todayStr}, tomorrow=${tomorrowStr}`);
  
  // Exclude NCAAF, NCAAM, NCAAW from manual sheets since they're fetched from ESPN/NCAA APIs
  const LEAGUES_TO_EXCLUDE_FROM_MANUAL = ['NCAAF', 'NCAAM', 'NCAAW'];
  
  for (const [leagueName, config] of Object.entries(MANUAL_LEAGUE_CONFIGS)) {
    // Skip leagues that are fetched from APIs to avoid duplicates
    if (LEAGUES_TO_EXCLUDE_FROM_MANUAL.includes(leagueName)) {
      console.log(`Skipping ${leagueName} from manual sheets (fetched from API instead)`);
      continue;
    }
    try {
      // Rate limiting is now handled inside getManualSheetData via rateLimitedSheetRequest
      console.log(`Fetching manual games for ${leagueName} from sheet "${config.sheetName}"...`);
      const data = await getManualSheetData(config.sheetName);
      
      if (data.length === 0) {
        console.log(`No data found for ${leagueName} (sheet "${config.sheetName}" is empty or doesn't exist)`);
        continue;
      }
      
      console.log(`Found ${data.length} rows in ${leagueName} sheet`);
      const headers = data[0];
      console.log(`Headers found: ${headers.join(', ')}`);
      const dataRows = data.slice(1);
      
      // Find column indices for each field
      const fieldIndices = {};
      Object.entries(config.fields).forEach(([key, fieldName]) => {
        const index = headers.findIndex(header => 
          header && header.toLowerCase().includes(fieldName.toLowerCase())
        );
        if (index !== -1) {
          fieldIndices[key] = index;
          console.log(`  Found field "${fieldName}" at column index ${index}`);
        } else {
          console.warn(`  Field "${fieldName}" not found in ${leagueName} headers`);
        }
      });
      
      if (Object.keys(fieldIndices).length === 0) {
        console.warn(`No valid fields found for ${leagueName}, skipping...`);
        continue;
      }

      const featuredColumnIndex = headers.findIndex(header => header && header.trim().toLowerCase() === 'featured');
      if (featuredColumnIndex === -1) {
        console.log(`  ‚ÑπÔ∏è  No "Featured" column found for ${leagueName} (manual sheet)`);
      } else {
        console.log(`  ‚úì Found "Featured" column at index ${featuredColumnIndex}`);
      }
      
      let gameIdCounter = 1;
      let leagueGameCount = 0;
      let skippedDateCount = 0;
      let displayOrder = 0;
      
      // Process all leagues (including Boxing) - each row independently
        for (const row of dataRows) {
          // Check if row is empty (handle both strings and numbers from UNFORMATTED_VALUE)
          if (row.every(cell => cell === null || cell === undefined || cell === '' || (typeof cell === 'string' && cell.trim() === ''))) continue;
          
          const rawDate = row[fieldIndices.date];
          const dateStr = rawDate !== null && rawDate !== undefined && rawDate !== '' ? parseDateForManualGames(rawDate) : null;
          
          if (!dateStr) {
            console.warn(`  Skipping row with invalid date: ${rawDate}`);
            continue;
          }
          
          // Only include games for today or tomorrow
          if (dateStr !== todayStr && dateStr !== tomorrowStr) {
            skippedDateCount++;
            if (skippedDateCount <= 3) {
              console.log(`  Skipping game with date ${dateStr} (not today or tomorrow)`);
            }
            continue;
          }
          
          // Get time from row - if blank, allow it (will show as empty on site, no inheritance from previous row)
          let timeStr = '';
          const rawTime = row[fieldIndices.time];
          if (rawTime !== null && rawTime !== undefined && rawTime !== '') {
            timeStr = parseTimeForManualGames(rawTime);
            if (!timeStr) {
              console.warn(`  Skipping row with invalid time: ${rawTime}`);
              continue;
            }
          } else {
            // Empty time - allow it, will show as empty on site
            timeStr = '';
          }
          
          const channel = row[fieldIndices.channel] !== null && row[fieldIndices.channel] !== undefined && row[fieldIndices.channel] !== '' 
            ? String(row[fieldIndices.channel]).trim() 
            : '';
          
          // Only create timestamp if time is provided; if time is blank, use 11:59 PM so blank times sort at end of day
          const startTime = timeStr ? createFirestoreTimestamp(dateStr, timeStr) : createFirestoreTimestamp(dateStr, '11:59 PM');
          if (!startTime) continue;
          
          // Get team fields first (before creating gameData)
          // Support both 'away'/'home' and 'awayTeam'/'homeTeam' field names
          const awayIndex = fieldIndices.awayTeam !== undefined ? fieldIndices.awayTeam : (fieldIndices.away !== undefined ? fieldIndices.away : undefined);
          const homeIndex = fieldIndices.homeTeam !== undefined ? fieldIndices.homeTeam : (fieldIndices.home !== undefined ? fieldIndices.home : undefined);
          
          let awayTeam = awayIndex !== undefined && row[awayIndex] !== null && row[awayIndex] !== undefined && row[awayIndex] !== ''
            ? String(row[awayIndex]).trim() 
            : '';
          let homeTeam = homeIndex !== undefined && row[homeIndex] !== null && row[homeIndex] !== undefined && row[homeIndex] !== ''
            ? String(row[homeIndex]).trim() 
            : '';
          
          const leagueDisplayName = LEAGUE_DISPLAY_NAME_MAP[leagueName] || leagueName;
          const sport = LEAGUE_TO_SPORT_MAP[leagueName] || 'Other';
          
          const gameData = {
            'League': leagueDisplayName,
            'Sport': sport,
            'Start Time': startTime,
            'gameDate': dateStr,
            'Match Status': 'SCHEDULED',
            'Channel': channel,
            'channel': channel,
            'Last Updated': admin.firestore.FieldValue.serverTimestamp()
          };
          
          // Store the time string so frontend can display it as empty if blank
          if (!timeStr) {
            gameData['timeString'] = ''; // Empty time string for frontend to display as blank
          }
          
          gameData['Home Team'] = homeTeam;
          gameData['Away Team'] = awayTeam;
          gameData['Matchup'] = awayTeam && homeTeam ? `${awayTeam} vs ${homeTeam}` : (homeTeam || awayTeam);

          if (featuredColumnIndex !== -1) {
            const featuredValue = row[featuredColumnIndex];
            if (featuredValue !== null && featuredValue !== undefined && featuredValue !== '') {
              const featuredId = String(featuredValue).trim();
              if (featuredId) {
                gameData['Featured'] = featuredId;
              }
            }
          }
          
          // Generate deterministic Game ID based on league, teams, and date (NOT time - same game should have same ID)
          const normalizedHome = (homeTeam || '').toLowerCase().trim().replace(/[^a-z0-9]/g, '');
          const normalizedAway = (awayTeam || '').toLowerCase().trim().replace(/[^a-z0-9]/g, '');
          const normalizedLeague = leagueName.toLowerCase().trim().replace(/[^a-z0-9]/g, '');
          const dateStrClean = dateStr.replace(/-/g, '');
          const gameId = `imported-${normalizedLeague}-${normalizedAway}-${normalizedHome}-${dateStrClean}`;
          gameData['Game ID'] = gameId;
          
          // Add display order to preserve Google Sheet row order for manual games
          gameData['displayOrder'] = displayOrder++;
          
          allManualGames.push(gameData);
          leagueGameCount++;
          console.log(`  ‚úì Added game: ${gameData['Matchup'] || gameData['Home Team']} on ${dateStr} at ${timeStr}`);
        }
        
        if (skippedDateCount > 3) {
          console.log(`  ... and ${skippedDateCount - 3} more games skipped (wrong date)`);
        }
        console.log(`Found ${leagueGameCount} games for ${leagueName} (${skippedDateCount} skipped due to date)`);
    } catch (error) {
      console.error(`Error fetching manual games for ${leagueName}:`, error.message);
    }
  }
  
  return allManualGames;
}




async function fetchRapidApiData(url, headers) {
await new Promise(resolve => setTimeout(resolve, API_REQUEST_DELAY_MS));
const response = await fetch(url, { headers });
if (!response.ok) {
 const errorText = await response.text();
 throw new Error(`HTTP error! ${response.status}: ${errorText} @ ${url}`);
}
return await response.json();
}




// Helper function to compare two game objects (ignoring Last Updated timestamp)
function gamesAreEqual(game1, game2) {
 if (!game1 || !game2) return false;
 
 // Compare key fields that matter
 const fieldsToCompare = [
   'League', 'Sport', 'Home Team', 'Away Team', 'Match Status',
   'Home Score', 'Away Score', 'Channel', 'channel', 'gameDate',
   'Start Time', 'Matchup', 'Featured', 'Stage', 'GameTime',
   'displayClock', 'displayTime', 'period' // Include clock/time fields so live updates aren't skipped
 ];
 
 for (const field of fieldsToCompare) {
   const val1 = game1[field];
   const val2 = game2[field];
   
   // Handle Timestamp objects
   if (val1 && val1.seconds && val2 && val2.seconds) {
     if (val1.seconds !== val2.seconds) return false;
   } else if (val1 !== val2) {
     return false;
   }
 }
 
 return true;
}

// Helper function to fetch rankings from NCAA API
// Returns a map: { normalizedTeamName: rank }
async function fetchNCAARankings(leagueKey) {
  try {
    let apiUrl;
    if (leagueKey === 'NCAAM') {
      apiUrl = 'https://ncaa-api.henrygd.me/rankings/basketball-men/d1/associated-press';
    } else if (leagueKey === 'NCAAW') {
      apiUrl = 'https://ncaa-api.henrygd.me/rankings/basketball-women/d1/associated-press';
    } else if (leagueKey === 'NCAAF') {
      apiUrl = 'https://ncaa-api.henrygd.me/rankings/football/fbs/associated-press';
    } else {
      return {};
    }
    
    const response = await fetch(apiUrl, {
      headers: { 'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36' }
    });
    
    if (!response.ok) {
      console.warn(`[NCAA Rankings] Failed to fetch rankings for ${leagueKey}: HTTP ${response.status}`);
      return {};
    }
    
    const data = await response.json();
    const rankingsMap = {};
    
    if (data && data.data && Array.isArray(data.data)) {
      data.data.forEach(item => {
        const rank = item.RANKING || item.RANK;
        let teamName = item.TEAM || item.SCHOOL || item['SCHOOL (1ST VOTES)'] || '';
        // Remove first-place votes in parentheses (e.g., "Team Name (35)" -> "Team Name")
        if (teamName) {
          teamName = teamName.replace(/\s*\(\d+\)\s*$/, '').trim();
        }
        if (teamName && rank) {
          // Normalize team name for matching (lowercase, trim)
          const normalizedName = teamName.toLowerCase().trim();
          rankingsMap[normalizedName] = parseInt(rank) || null;
        }
      });
    }
    
    return rankingsMap;
  } catch (error) {
    console.error(`[NCAA Rankings] Error fetching rankings for ${leagueKey}:`, error.message);
    return {};
  }
}

// Helper function to normalize team name for ranking lookup
function normalizeTeamNameForRanking(teamName) {
  if (!teamName) return '';
  return teamName.toLowerCase().trim();
}

// Helper function to get ranking for a team
function getTeamRanking(teamName, rankingsMap) {
  if (!teamName || !rankingsMap) return null;
  const normalized = normalizeTeamNameForRanking(teamName);
  return rankingsMap[normalized] || null;
}

async function writeGamesToFirestore(games) {
const db = initializeFirebase();
const gamesRef = db.collection(`artifacts/flashlive-daily-scraper/public/data/sportsGames`);

// CRITICAL: Delete ALL today's games from ESPN/NCAA sources before writing
// NOTE: No cleanup needed - Game IDs are now stable (no time component)
// The merge: true option will update existing games instead of creating duplicates
// This is much more cost-efficient than deleting and rewriting everything

// OPTIMIZATION: Filter by date range to avoid reading entire collection
const nowInMountain = DateTime.now().setZone('America/Denver');
const yesterdayStr = nowInMountain.minus({ days: 1 }).toISODate();
const tomorrowStr = nowInMountain.plus({ days: 1 }).toISODate();

// Get existing games to compare
const existingSnapshot = await gamesRef
  .where('gameDate', '>=', yesterdayStr)
  .where('gameDate', '<=', tomorrowStr)
  .get();
const existingGamesMap = new Map();
existingSnapshot.forEach(doc => {
  const data = doc.data();
  const gameId = String(data['Game ID'] || doc.id);
  existingGamesMap.set(gameId, data);
});

const batch = db.batch();
let gameCount = 0;
let skippedCount = 0;
let updatedCount = 0;
let newCount = 0;

for (const game of games) {
 if (!game['Game ID']) {
   console.warn('Skipping Firestore write for game with missing or empty "Game ID":', JSON.stringify(game));
   continue;
 }
 
 const gameId = String(game['Game ID']);
 const docRef = gamesRef.doc(gameId);
 const existingGame = existingGamesMap.get(gameId);
 
 // For live games, always write even if they appear equal (to ensure Firestore listeners trigger)
 // Expand the heuristic to catch cases where the provider doesn't set Match Status but
 // provides a displayClock, Stage, or StageType indicating play has started.
 const rawStatus = String(game['Match Status'] || '').toUpperCase();
 const rawStageType = String(game.StageType || '').toUpperCase();
 const rawStage = String(game.Stage || '').toUpperCase();
 const displayClockVal = (game.displayClock || game.displayTime || game.GameTime || '') + '';
 const hasDisplayClock = displayClockVal && !['0', '0:00', '0.0', 'NULL', ''].includes(displayClockVal.toString().trim().toUpperCase());

 const isLive = (
   rawStatus.includes('IN PROGRESS') ||
   rawStatus.includes('LIVE') ||
   rawStageType.includes('LIVE') ||
   rawStageType.includes('IN PROGRESS') ||
   // Some feeds set Stage to FIRST_HALF/SECOND_HALF or similar
   /FIRST|SECOND|HALF|IN_PROGRESS|ONGOING|PLAY/.test(rawStage) ||
   // If there's a meaningful display clock, treat as live
   hasDisplayClock
 );
 
 // Check if game already exists and is identical
 if (existingGame && gamesAreEqual(existingGame, game) && !isLive) {
   skippedCount++;
   // Log skipped NFL games for debugging
   if (game.Sport === 'American Football' && (game.League?.includes('NFL') || game.League?.includes('NCAAF'))) {
     console.log(`‚è≠Ô∏è  Skipped unchanged NFL game: ${game['Away Team']} vs ${game['Home Team']} - GameTime: ${game.GameTime || 'null'}, displayClock: ${game.displayClock || 'null'}`);
   }
   continue; // Skip writing if game hasn't changed (unless it's live)
 }
 
 // Preserve user-set POSTPONED/PPD/CANCELED: do not overwrite with API status (e.g. FINAL) when live polling runs
 const existingStatus = existingGame && existingGame['Match Status'] ? String(existingGame['Match Status']).toUpperCase().trim() : '';
 if (existingStatus === 'POSTPONED' || existingStatus === 'PPD' || existingStatus === 'CANCELED') {
   continue; // Skip write entirely so PPD/postponed stays
 }
 
  batch.set(docRef, game, { merge: true });
  
  // Invalidate today's games JSON cache so it refreshes on next request
  todayGamesCache = null;
  todayGamesCacheTimestamp = null;
  
  // ALSO write to root-level `sportsGames` collection for backwards compatibility
  try {
    const rootDocRef = db.collection('sportsGames').doc(gameId);
    batch.set(rootDocRef, game, { merge: true });
  } catch (err) {
    // If something goes wrong creating the root ref, warn but continue with primary write
    console.warn('Warning: failed to prepare root-level sportsGames write for', gameId, err && err.message);
  }
 gameCount++;
 
 if (existingGame) {
   updatedCount++;
   // Log what changed for NFL games
   if (game.Sport === 'American Football' && (game.League?.includes('NFL') || game.League?.includes('NCAAF'))) {
     const changes = [];
     if (existingGame['Home Score'] !== game['Home Score']) changes.push(`Home Score: ${existingGame['Home Score']} ‚Üí ${game['Home Score']}`);
     if (existingGame['Away Score'] !== game['Away Score']) changes.push(`Away Score: ${existingGame['Away Score']} ‚Üí ${game['Away Score']}`);
     if (existingGame['GameTime'] !== game['GameTime']) changes.push(`GameTime: ${existingGame['GameTime']} ‚Üí ${game['GameTime']}`);
     if (existingGame['displayClock'] !== game['displayClock']) changes.push(`displayClock: ${existingGame['displayClock']} ‚Üí ${game['displayClock']}`);
     if (existingGame['displayTime'] !== game['displayTime']) changes.push(`displayTime: ${existingGame['displayTime']} ‚Üí ${game['displayTime']}`);
     if (existingGame['Stage'] !== game['Stage']) changes.push(`Stage: ${existingGame['Stage']} ‚Üí ${game['Stage']}`);
     if (existingGame['Match Status'] !== game['Match Status']) changes.push(`Match Status: ${existingGame['Match Status']} ‚Üí ${game['Match Status']}`);
     if (changes.length > 0) {
       console.log(`üèà NFL Update: ${game['Away Team']} vs ${game['Home Team']} - ${changes.join(', ')}`);
     } else if (isLive) {
       console.log(`üèà NFL Live (forced write): ${game['Away Team']} vs ${game['Home Team']} - ${game['Match Status']} ${game['Stage']} ${game['GameTime'] || 'null'} displayClock: ${game['displayClock'] || 'null'}`);
     }
   }
 } else {
   newCount++;
 }
 
 // Debug logging for non-soccer games
 if (game.Sport === 'Basketball' || game.Sport === 'American Football' || game.Sport === 'Hockey') {
   console.log(`üìù Writing to Firestore: ${game['Away Team']} vs ${game['Home Team']} (${game.Sport} - ${game.League}) - Status: ${game['Match Status']}, Scores: ${game['Away Score']}-${game['Home Score']}`);
 }
}

try {
 if (gameCount > 0) {
   await batch.commit();
   console.log(`‚úÖ Firestore write: ${gameCount} games (${newCount} new, ${updatedCount} updated, ${skippedCount} unchanged skipped).`);
 } else {
   console.log(`‚úÖ Firestore write: All ${skippedCount} games unchanged, no writes needed.`);
 }
} catch (error) {
 console.error('--- Firestore Batch Commit Failed ---');
 console.error('Error during batch commit:', error);
 if (error.message) console.error('Error Message:', error.message);
 if (error.stack) console.error('Error Stack:', error.stack);
 if (error.code) console.error('Firestore Error Code:', error.code);
 if (error.details) console.error('Firestore Error Details:', error.details);
 throw error;
}
}




// Smart Firestore cleanup: Only delete games that are old (past yesterday) or not in the new import
async function smartUpdateFirestoreCollection(newGames) {
const db = initializeFirebase();
const gamesRef = db.collection(`artifacts/flashlive-daily-scraper/public/data/sportsGames`);

// Get current date range for games we're importing
// CRITICAL: Use Eastern Time for yesterdayStr to match gameDate storage format (games are stored with Eastern Time dates)
const nowInMountain = DateTime.now().setZone('America/Denver');
const nowInEastern = DateTime.now().setZone('America/New_York');
const todayStr = nowInMountain.toISODate();
const tomorrowStr = nowInMountain.plus({ days: 1 }).toISODate();
const yesterdayStr = nowInEastern.minus({ days: 1 }).toISODate(); // Use Eastern Time to match gameDate storage
const sevenDaysAgoStr = nowInMountain.minus({ days: 7 }).toISODate();

// OPTIMIZATION: Filter by date range (last 7 days to tomorrow) to avoid reading entire collection
// Get existing games
const snapshot = await gamesRef
  .where('gameDate', '>=', sevenDaysAgoStr)
  .where('gameDate', '<=', tomorrowStr)
  .get();
const existingGames = new Map();
snapshot.forEach(doc => {
  const data = doc.data();
  const gameId = String(data['Game ID'] || doc.id);
  existingGames.set(gameId, { doc, data });
});

// Create a set of new game IDs for quick lookup
const newGameIds = new Set(newGames.map(g => String(g['Game ID'] || '')).filter(id => id));

// Find games to delete:
// 1. Games older than yesterday (definitely should be deleted)
// 2. Games not in the new import (were removed from sheets)
const deleteBatch = db.batch();
let deletedCount = 0;
let deletedOldCount = 0;
let deletedRemovedCount = 0;

for (const [gameId, { doc, data }] of existingGames.entries()) {
  const gameDate = data.gameDate || '';
  const gameSource = data.source || '';
  const isOld = gameDate && gameDate < yesterdayStr;
  const isRemoved = !newGameIds.has(gameId);
  
  // CRITICAL FIX: Don't delete ESPN/NCAA API games - they're managed by pollESPNLiveData, not Google Sheets
  // Only delete manual games (from Google Sheets) that were removed from sheets
  const isESPNOrNCAA = gameSource === 'ESPN_LIVE' || gameSource === 'NCAA_LIVE';
  
  if (isOld) {
    // Always delete old games (older than yesterday)
    deleteBatch.delete(doc.ref);
    deletedCount++;
    deletedOldCount++;
  } else if (isRemoved && !isESPNOrNCAA) {
    // Only delete removed games if they're NOT from ESPN/NCAA APIs (manual games removed from sheets)
    deleteBatch.delete(doc.ref);
    deletedCount++;
    deletedRemovedCount++;
  }
  // ESPN/NCAA games that aren't in new import are preserved (they're managed by pollESPNLiveData)
}

if (deletedCount > 0) {
  await deleteBatch.commit();
  console.log(`üßπ Smart cleanup: Deleted ${deletedCount} games (${deletedOldCount} old, ${deletedRemovedCount} removed from sheets).`);
} else {
  console.log(`üßπ Smart cleanup: No games to delete.`);
}
}

// Keep the old function for backward compatibility, but make it use smart update
async function clearFirestoreCollection() {
// For now, we'll use smart update instead of clearing everything
// This will be called with newGames later, but for backward compatibility
// we'll just log that we're skipping the full clear
console.log('‚ö†Ô∏è clearFirestoreCollection called - using smart update instead of full clear');
}




function createNoopRes() {
return {
 status() { return this; },
 send() {},
 json() {}
};
}

// NEW: Import games from Google Sheets to Firestore
async function importGamesFromSheets() {
  const db = initializeFirebase();
  const allGames = [];
  
  // League configurations for all 4 sheets
  const LEAGUE_CONFIGS = {
    // From SHEET_ID
    // ESPN/NCAA API leagues (commented out to prevent duplicates):
    // 'NFL': { sheetName: 'NFL', sheetId: SHEET_ID, fields: { date: 'Date', time: 'Time', away: 'Away Team', home: 'Home Team', channel: 'Channel' }, isSoccer: false },
    // 'NBA': { sheetName: 'NBA', sheetId: SHEET_ID, fields: { date: 'Date', time: 'Time', away: 'Away Team', home: 'Home Team', channel: 'Channel' }, isSoccer: false },
    // 'MLB': { sheetName: 'MLB', sheetId: SHEET_ID, fields: { date: 'Date', time: 'Time', away: 'Away Team', home: 'Home Team', channel: 'Channel' }, isSoccer: false },
    // 'PremierLeague': { sheetName: 'PremierLeague', sheetId: SHEET_ID, fields: { date: 'Date', time: 'Time', home: 'Home Team', away: 'Away Team', channel: 'Channel' }, isSoccer: true },
    // 'MLS': { sheetName: 'MLS', sheetId: SHEET_ID, fields: { date: 'Date', time: 'Time', home: 'Home Team', away: 'Away Team', channel: 'Channel' }, isSoccer: true },
    // 'LaLiga': { sheetName: 'LaLiga', sheetId: SHEET_ID, fields: { date: 'Date', time: 'Time', home: 'Home Team', away: 'Away Team', channel: 'Channel' }, isSoccer: true },
    // 'Bundesliga': { sheetName: 'Bundesliga', sheetId: SHEET_ID, fields: { date: 'Date', time: 'Time', home: 'Home Team', away: 'Away Team', channel: 'Channel' }, isSoccer: true },
    // 'SerieA': { sheetName: 'SerieA', sheetId: SHEET_ID, fields: { date: 'Date', time: 'Time', home: 'Home Team', away: 'Away Team', channel: 'Channel' }, isSoccer: true },
    // 'Ligue1': { sheetName: 'Ligue1', sheetId: SHEET_ID, fields: { date: 'Date', time: 'Time', home: 'Home Team', away: 'Away Team', channel: 'Channel' }, isSoccer: true },
    // 'UEFAChampionsLeague': { sheetName: 'UEFAChampionsLeague', sheetId: SHEET_ID, fields: { date: 'Date', time: 'Time', home: 'Home Team', away: 'Away Team', channel: 'Channel' }, isSoccer: true },
    // 'UEFAEuropaLeague': { sheetName: 'UEFAEuropaLeague', sheetId: SHEET_ID, fields: { date: 'Date', time: 'Time', home: 'Home Team', away: 'Away Team', channel: 'Channel' }, isSoccer: true },
    // 'UEFAConferenceLeague': { sheetName: 'UEFAConferenceLeague', sheetId: SHEET_ID, fields: { date: 'Date', time: 'Time', home: 'Home Team', away: 'Away Team', channel: 'Channel' }, isSoccer: true },
    'CopaLibertadores': { sheetName: 'CopaLibertadores', sheetId: SHEET_ID, fields: { date: 'Date', time: 'Time', home: 'Home Team', away: 'Away Team', channel: 'Channel' }, isSoccer: true },
    'CopaSudamericana': { sheetName: 'CopaSudamericana', sheetId: SHEET_ID, fields: { date: 'Date', time: 'Time', home: 'Home Team', away: 'Away Team', channel: 'Channel' }, isSoccer: true },
    // 'LigaMX': { sheetName: 'LigaMX', sheetId: SHEET_ID, fields: { date: 'Date', time: 'Time', home: 'Home Team', away: 'Away Team', channel: 'Channel' }, isSoccer: true },
    // 'NWSL': { sheetName: 'NWSL', sheetId: SHEET_ID, fields: { date: 'Date', time: 'Time', home: 'Home Team', away: 'Away Team', channel: 'Channel' }, isSoccer: true },
    // 'NCAAF': { sheetName: 'NCAAF', sheetId: SHEET_ID, fields: { date: 'Date', time: 'Time', away: 'Away Team', home: 'Home Team', channel: 'Channel' }, isSoccer: false },
    // 'NHL': { sheetName: 'NHL', sheetId: SHEET_ID, fields: { date: 'Date', time: 'Time', away: 'Away Team', home: 'Home Team', channel: 'Channel' }, isSoccer: false },
    // 'WNBA': { sheetName: 'WNBA', sheetId: SHEET_ID, fields: { date: 'Date', time: 'Time', away: 'Away Team', home: 'Home Team', channel: 'Channel' }, isSoccer: false },
    'NASCARCupSeries': { sheetName: 'NASCARCupSeries', sheetId: SHEET_ID, fields: { date: 'Date', time: 'Time', race: 'Race', location: 'Location', channel: 'Channel' }, isSoccer: false },
    'Tennis': { sheetName: 'Tennis', sheetId: SHEET_ID, fields: { date: 'Date', tour: 'Tour', tournament: 'Tournament', channel: 'Channel' }, isSoccer: false },
    'TrackAndField': { sheetName: 'TrackAndField', sheetId: SHEET_ID, fields: { date: 'Date', meet: 'Meet', channel: 'Channel' }, isSoccer: false },
    // 'EFLChampionship': { sheetName: 'EFLChampionship', sheetId: SHEET_ID, fields: { date: 'Date', time: 'Time', home: 'Home Team', away: 'Away Team', channel: 'Channel' }, isSoccer: true },
    'ArgentinePrimeraDivision': { sheetName: 'ArgentinePrimeraDivision', sheetId: SHEET_ID, fields: { date: 'Date', time: 'Time', home: 'Home Team', away: 'Away Team', channel: 'Channel' }, isSoccer: true },
    // 'Brasileirao': { sheetName: 'Brasileirao', sheetId: SHEET_ID, fields: { date: 'Date', time: 'Time', home: 'Home Team', away: 'Away Team', channel: 'Channel' }, isSoccer: true },
    // From SHEET_ID_2
    // 'BelgianProLeague': { sheetName: 'BelgianProLeague', sheetId: SHEET_ID_2, fields: { date: 'Date', time: 'Time', home: 'Home Team', away: 'Away Team', channel: 'Channel' }, isSoccer: true },
    // 'SuperLig': { sheetName: 'SuperLig', sheetId: SHEET_ID_2, fields: { date: 'Date', time: 'Time', home: 'Home Team', away: 'Away Team', channel: 'Channel' }, isSoccer: true },
    'USLChampionship': { sheetName: 'USLChampionship', sheetId: SHEET_ID_2, fields: { date: 'Date', time: 'Time', home: 'Home Team', away: 'Away Team', channel: 'Channel' }, isSoccer: true },
    'CFL': { sheetName: 'CFL', sheetId: SHEET_ID_2, fields: { date: 'Date', time: 'Time', away: 'Away Team', home: 'Home Team', channel: 'Channel' }, isSoccer: false },
    // 'LigaPortugal': { sheetName: 'LigaPortugal', sheetId: SHEET_ID_2, fields: { date: 'Date', time: 'Time', away: 'Away Team', home: 'Home Team', channel: 'Channel' }, isSoccer: true },
    // 'Eredivisie': { sheetName: 'Eredivisie', sheetId: SHEET_ID_2, fields: { date: 'Date', time: 'Time', away: 'Away Team', home: 'Home Team', channel: 'Channel' }, isSoccer: true },
    // 'ScottishPremiership': { sheetName: 'ScottishPremiership', sheetId: SHEET_ID_2, fields: { date: 'Date', time: 'Time', away: 'Away Team', home: 'Home Team', channel: 'Channel' }, isSoccer: true },
    'EFLCup': { sheetName: 'EFLCup', sheetId: SHEET_ID_2, fields: { date: 'Date', time: 'Time', away: 'Away Team', home: 'Home Team', channel: 'Channel' }, isSoccer: true },
    // 'FACup': { sheetName: 'FACup', sheetId: SHEET_ID_2, fields: { date: 'Date', time: 'Time', away: 'Away Team', home: 'Home Team', channel: 'Channel' }, isSoccer: true },
    // 'DFBPokal': { sheetName: 'DFBPokal', sheetId: SHEET_ID_2, fields: { date: 'Date', time: 'Time', away: 'Away Team', home: 'Home Team', channel: 'Channel' }, isSoccer: true },
    // 'CopaDelRey': { sheetName: 'CopaDelRey', sheetId: SHEET_ID_2, fields: { date: 'Date', time: 'Time', away: 'Away Team', home: 'Home Team', channel: 'Channel' }, isSoccer: true },
    // 'SaudiProLeague': { sheetName: 'SaudiProLeague', sheetId: SHEET_ID_2, fields: { date: 'Date', time: 'Time', home: 'Home Team', away: 'Away Team', channel: 'Channel' }, isSoccer: true },
    'WomensSuperLeague': { sheetName: 'WomensSuperLeague', sheetId: SHEET_ID_2, fields: { date: 'Date', time: 'Time', away: 'Away Team', home: 'Home Team', channel: 'Channel' }, isSoccer: true },
    // From SHEET_ID_3
    // 'NCAAM': { sheetName: 'NCAAM', sheetId: SHEET_ID_3, fields: { date: 'Date', time: 'Time', away: 'Away Team', home: 'Home Team', channel: 'Channel' }, isSoccer: false },
    // 'NCAAW': { sheetName: 'NCAAW', sheetId: SHEET_ID_3, fields: { date: 'Date', time: 'Time', away: 'Away Team', home: 'Home Team', channel: 'Channel' }, isSoccer: false },
    // 'ATP': { sheetName: 'ATP', sheetId: SHEET_ID_3, fields: { date: 'Date', time: 'Time', tournament: 'Tournament', channel: 'Channel' }, isSoccer: false },
    // 'WTA': { sheetName: 'WTA', sheetId: SHEET_ID_3, fields: { date: 'Date', time: 'Time', tournament: 'Tournament', channel: 'Channel' }, isSoccer: false },
    // 'DPWorldTour': { sheetName: 'DPWorldTour', sheetId: SHEET_ID_3, fields: { date: 'Date', time: 'Time', away: 'Away Team', home: 'Home Team', channel: 'Channel' }, isSoccer: false },
    // 'PGATourChampions': { sheetName: 'PGATourChampions', sheetId: SHEET_ID_3, fields: { date: 'Date', time: 'Time', tournament: 'Tournament', channel: 'Channel' }, isSoccer: false },
    'WomensUCL': { sheetName: 'WomensUCL', sheetId: SHEET_ID_3, fields: { date: 'Date', time: 'Time', away: 'Away Team', home: 'Home Team', channel: 'Channel' }, isSoccer: true },
    'CAFQualifiers': { sheetName: 'CAFQualifiers', sheetId: SHEET_ID_3, fields: { date: 'Date', time: 'Time', away: 'Away Team', home: 'Home Team', channel: 'Channel' }, isSoccer: true },
    'AFCQualifiers': { sheetName: 'AFCQualifiers', sheetId: SHEET_ID_3, fields: { date: 'Date', time: 'Time', away: 'Away Team', home: 'Home Team', channel: 'Channel' }, isSoccer: true },
    'AFCAsianCupQualifiers': { sheetName: 'AFCAsianCupQualifiers', sheetId: SHEET_ID_3, fields: { date: 'Date', time: 'Time', away: 'Away Team', home: 'Home Team', channel: 'Channel' }, isSoccer: true },
    'UEFAEuropeanQualifiers': { sheetName: 'UEFAEuropeanQualifiers', sheetId: SHEET_ID_3, fields: { date: 'Date', time: 'Time', away: 'Away Team', home: 'Home Team', channel: 'Channel' }, isSoccer: true },
    'CONCACAFQualifiers': { sheetName: 'CONCACAFQualifiers', sheetId: SHEET_ID_3, fields: { date: 'Date', time: 'Time', away: 'Away Team', home: 'Home Team', channel: 'Channel' }, isSoccer: true },
    'WorldCupU17': { sheetName: 'FIFAU17WorldCup', sheetId: SHEET_ID_3, fields: { date: 'Date', time: 'Time', away: 'Away Team', home: 'Home Team', channel: 'Channel' }, isSoccer: true },
    // 'CoppaItalia': { sheetName: 'CoppaItalia', sheetId: SHEET_ID_3, fields: { date: 'Date', time: 'Time', away: 'Away Team', home: 'Home Team', channel: 'Channel' }, isSoccer: true },
    // 'CoupeDeFrance': { sheetName: 'CoupeDeFrance', sheetId: SHEET_ID_3, fields: { date: 'Date', time: 'Time', away: 'Away Team', home: 'Home Team', channel: 'Channel' }, isSoccer: true },
    'ScottishCup': { sheetName: 'ScottishCup', sheetId: SHEET_ID_3, fields: { date: 'Date', time: 'Time', away: 'Away Team', home: 'Home Team', channel: 'Channel' }, isSoccer: true },
    'TacaDePortugal': { sheetName: 'TacaDePortugal', sheetId: SHEET_ID_2, fields: { date: 'Date', time: 'Time', away: 'Away Team', home: 'Home Team', channel: 'Channel' }, isSoccer: true },
    // From SHEET_ID_4 (treated same as other sheets)
    'MotoGP': { sheetName: 'MotoGP', sheetId: SHEET_ID_4, fields: { date: 'Date', time: 'Time', home: 'Home Team', away: 'Away Team', channel: 'Channel' }, isSoccer: false },
    // 'Boxing': { sheetName: 'Boxing', sheetId: SHEET_ID_4, fields: { date: 'Date', time: 'Time', home: 'Home Team', away: 'Away Team', channel: 'Channel' }, isSoccer: false },
    // 'UFC': { sheetName: 'UFC', sheetId: SHEET_ID_4, fields: { date: 'Date', time: 'Time', home: 'Home Team', away: 'Away Team', channel: 'Channel' }, isSoccer: false },
    // 'PGATour': { sheetName: 'PGATour', sheetId: SHEET_ID_4, fields: { date: 'Date', time: 'Time', home: 'Home Team', away: 'Away Team', channel: 'Channel' }, isSoccer: false },
    // 'LPGATour': { sheetName: 'LPGATour', sheetId: SHEET_ID_4, fields: { date: 'Date', time: 'Time', home: 'Home Team', away: 'Away Team', channel: 'Channel' }, isSoccer: false },
    // 'LIVGolf': { sheetName: 'LIVGolf', sheetId: SHEET_ID_4, fields: { date: 'Date', time: 'Time', home: 'Home Team', away: 'Away Team', channel: 'Channel' }, isSoccer: false },
    'USMNT': { sheetName: 'USMNT', sheetId: SHEET_ID_4, fields: { date: 'Date', time: 'Time', home: 'Home Team', away: 'Away Team', channel: 'Channel' }, isSoccer: true },
    'USWNT': { sheetName: 'USWNT', sheetId: SHEET_ID_4, fields: { date: 'Date', time: 'Time', home: 'Home Team', away: 'Away Team', channel: 'Channel' }, isSoccer: true },
    // 'FormulaOne': { sheetName: 'FormulaOne', sheetId: SHEET_ID_4, fields: { date: 'Date', time: 'Time', home: 'Home Team', away: 'Away Team', channel: 'Channel' }, isSoccer: false }
  };
  
  const LEAGUE_TO_SPORT_MAP_FULL = {
    'NFL': 'American Football', 'NCAAF': 'American Football', 'CFL': 'American Football',
    'NBA': 'Basketball', 'NCAAM': 'Basketball', 'NCAAW': 'Basketball', 'WNBA': 'Basketball',
    'MLB': 'Baseball',
    'NHL': 'Hockey',
    'PremierLeague': 'Soccer', 'LaLiga': 'Soccer', 'Bundesliga': 'Soccer', 'SerieA': 'Soccer', 'Ligue1': 'Soccer',
    'MLS': 'Soccer', 'UEFAChampionsLeague': 'Soccer', 'UEFAEuropaLeague': 'Soccer', 'UEFAConferenceLeague': 'Soccer',
    'CopaLibertadores': 'Soccer', 'CopaSudamericana': 'Soccer', 'LigaMX': 'Soccer', 'NWSL': 'Soccer',
    'EFLChampionship': 'Soccer', 'BelgianProLeague': 'Soccer', 'SuperLig': 'Soccer', 'USLChampionship': 'Soccer',
    'LigaPortugal': 'Soccer', 'Eredivisie': 'Soccer', 'ScottishPremiership': 'Soccer', 'EFLCup': 'Soccer',
    'FACup': 'Soccer', 'DFBPokal': 'Soccer', 'CopaDelRey': 'Soccer', 'SaudiProLeague': 'Soccer',
    'WomensSuperLeague': 'Soccer', 'WomensUCL': 'Soccer', 'USMNT': 'Soccer', 'USWNT': 'Soccer', 'WorldCupU17': 'Soccer', 'CoppaItalia': 'Soccer', 'CoupeDeFrance': 'Soccer', 'ScottishCup': 'Soccer', 'TacaDePortugal': 'Soccer',
    'CAFQualifiers': 'Soccer', 'AFCQualifiers': 'Soccer', 'AFCAsianCupQualifiers': 'Soccer',
    'UEFAEuropeanQualifiers': 'Soccer', 'CONCACAFQualifiers': 'Soccer', 'ArgentinePrimeraDivision': 'Soccer', 'Brasileirao': 'Soccer',
    'MotoGP': 'Motorsport', 'PGATour': 'Golf', 'LPGATour': 'Golf', 'LIVGolf': 'Golf', 'FormulaOne': 'Motorsport',
    'DPWorldTour': 'Golf', 'PGATourChampions': 'Golf',
    'Boxing': 'Boxing', 'UFC': 'Boxing',
    'Tennis': 'Tennis', 'ATP': 'Tennis', 'WTA': 'Tennis',
    'NASCARCupSeries': 'Auto Racing',
    'TrackAndField': 'Track & Field'
  };
  
  const LEAGUE_DISPLAY_NAME_MAP_FULL = {
    'PremierLeague': 'England: Premier League', 'LaLiga': 'Spain: LaLiga', 'Bundesliga': 'Germany: Bundesliga',
    'SerieA': 'Italy: Serie A', 'Ligue1': 'France: Ligue 1', 'MLS': 'USA: MLS',
    'UEFAChampionsLeague': 'UEFA Champions League', 'UEFAEuropaLeague': 'Europa League',
    'UEFAConferenceLeague': 'Conference League', 'LigaMX': 'Mexico: Liga MX',
    'NWSL': 'USA: NWSL Women', 'NFL': 'USA: NFL', 'NCAAF': 'USA: NCAA',
    'NBA': 'USA: NBA', 'NCAAM': 'USA: NCAA', 'NCAAW': 'USA: NCAA Women', 'WNBA': 'USA: WNBA',
    'MLB': 'USA: MLB', 'NHL': 'USA: NHL', 'CFL': 'Canada: CFL',
    'EFLChampionship': 'England: Championship', 'BelgianProLeague': 'Belgium: Jupiler Pro League',
    'SuperLig': 'Turkey: Super Lig', 'USLChampionship': 'USA: USL Championship',
    'LigaPortugal': 'Portugal: Liga Portugal', 'Eredivisie': 'Netherlands: Eredivisie',
    'ScottishPremiership': 'Scotland: Premiership', 'EFLCup': 'England: EFL Cup',
    'FACup': 'England: FA Cup', 'DFBPokal': 'Germany: DFB Pokal', 'CopaDelRey': 'Spain: Copa del Rey', 'CoppaItalia': 'Italy: Coppa Italia', 'CoupeDeFrance': 'France: Coupe de France', 'ScottishCup': 'Scotland: Scottish Cup', 'TacaDePortugal': 'Ta√ßa de Portugal',
    'CopaLibertadores': 'South America: Copa Libertadores - Play Offs', 'CopaSudamericana': 'South America: Copa Sudamericana',
    'SaudiProLeague': 'Saudi Arabia: Saudi Professional League', 'WomensSuperLeague': 'England: WSL',
    'WomensUCL': 'Europe: Champions League Women - League phase',
    'WorldCupU17': 'World: World Cup U17', 'CAFQualifiers': 'Africa: World Cup - Qualification',
    'AFCQualifiers': 'Asia: World Cup - Qualification', 'AFCAsianCupQualifiers': 'Asia: Asian Cup - Qualification',
    'UEFAEuropeanQualifiers': 'Europe: World Cup - Qualification', 'CONCACAFQualifiers': 'North & Central America: World Cup - Qualification',
    'ArgentinePrimeraDivision': 'Argentina: Torneo Betano - Apertura', 'Brasileirao': 'Brazil: Serie A Betano',
    'MotoGP': 'MotoGP', 'PGATour': 'PGA Tour', 'LPGATour': 'LPGA Tour', 'LIVGolf': 'LIV Golf', 'FormulaOne': 'Formula 1',
    'DPWorldTour': 'DP World Tour', 'PGATourChampions': 'PGA Champions',
    'Boxing': 'Boxing', 'UFC': 'UFC',
    'Tennis': 'Tennis', 'ATP': 'ATP', 'WTA': 'WTA',
    'NASCARCupSeries': 'NASCAR Cup Series',
    'TrackAndField': 'Track & Field'
  };
  
  async function getSheetDataForImport(sheetName, sheetId) {
    try {
      const response = await rateLimitedSheetRequest(() =>
        sheets.spreadsheets.values.get({
          spreadsheetId: sheetId,
          range: `${sheetName}!A:Z`,
          valueRenderOption: 'UNFORMATTED_VALUE'
        })
      );
      return response.data.values || [];
    } catch (error) {
      console.error(`Error reading sheet ${sheetName} from ${sheetId}:`, error.message);
      if (error.message.includes('permission') || error.message.includes('does not have permission')) {
        console.error(`  ‚ö†Ô∏è  PERMISSION ERROR: The service account needs to be granted access to this spreadsheet.`);
        if (serviceAccountEmail) {
          console.error(`  üìß Service account email: ${serviceAccountEmail}`);
          console.error(`  üìù To fix: Share the spreadsheet with this email address:`);
          console.error(`     ${serviceAccountEmail}`);
        } else {
          console.error(`  üìß To fix: Share the spreadsheet with the service account email (check logs above for the email address)`);
        }
        console.error(`  üîó Spreadsheet URL: https://docs.google.com/spreadsheets/d/${sheetId}/edit`);
        console.error(`  üìã Steps:`);
        console.error(`     1. Open the spreadsheet URL above`);
        console.error(`     2. Click the "Share" button (top right)`);
        console.error(`     3. Paste the service account email: ${serviceAccountEmail || '[check logs above]'}`);
        console.error(`     4. Set permission to "Viewer" (read-only is enough)`);
        console.error(`     5. Uncheck "Notify people" (service accounts don't need notifications)`);
        console.error(`     6. Click "Share"`);
      }
      return [];
    }
  }
  
  function parseDateForImport(dateStr) {
    if (!dateStr) return null;
    let date;
    if (typeof dateStr === 'number') {
      const excelEpoch = new Date('1899-12-30T00:00:00Z');
      const daysSinceEpoch = Math.floor(dateStr);
      date = new Date(excelEpoch.getTime() + daysSinceEpoch * 24 * 60 * 60 * 1000);
    } else {
      date = new Date(dateStr);
    }
    if (isNaN(date.getTime())) return null;
    const year = date.getUTCFullYear();
    const month = String(date.getUTCMonth() + 1).padStart(2, '0');
    const day = String(date.getUTCDate()).padStart(2, '0');
    return `${year}-${month}-${day}`;
  }
  
  function parseTimeForImport(timeStr) {
    if (!timeStr) return '';
    if (typeof timeStr === 'string' && timeStr.includes(':')) {
      return timeStr.trim();
    }
    let hours = 0, minutes = 0;
    if (typeof timeStr === 'number') {
      const totalSeconds = Math.floor(timeStr * 86400);
      hours = Math.floor(totalSeconds / 3600);
      minutes = Math.floor((totalSeconds % 3600) / 60);
    } else if (timeStr instanceof Date) {
      // For Date objects from Google Sheets, extract hours/minutes (seconds are always 00)
      hours = timeStr.getUTCHours();
      minutes = timeStr.getUTCMinutes();
    } else {
      return String(timeStr).trim();
    }
    const ampm = hours >= 12 ? 'PM' : 'AM';
    let displayHours = hours % 12;
    if (displayHours === 0) displayHours = 12;
    return `${displayHours}:${String(minutes).padStart(2, '0')} ${ampm}`;
  }
  
  const nowInMountain = DateTime.now().setZone('America/Denver');
  const todayStr = nowInMountain.toISODate();
  const tomorrowStr = nowInMountain.plus({ days: 1 }).toISODate();
  
  console.log(`Importing games from Google Sheets for dates: ${todayStr} and ${tomorrowStr}`);
  
  // ESPN/NCAA API leagues are commented out in LEAGUE_CONFIGS above to prevent duplicates
  for (const [leagueName, config] of Object.entries(LEAGUE_CONFIGS)) {
    try {
      console.log(`\nImporting ${leagueName} from sheet "${config.sheetName}" (Sheet ID: ${config.sheetId})...`);
      
      // Rate limiting is now handled inside getSheetDataForImport via rateLimitedSheetRequest
      const data = await getSheetDataForImport(config.sheetName, config.sheetId);
      
      if (data.length === 0) {
        console.log(`  No data found for ${leagueName}`);
        continue;
      }
      
      const headers = data[0];
      const dataRows = data.slice(1);
      
      console.log(`  Headers found: ${headers.join(', ')}`);
      console.log(`  Total data rows: ${dataRows.length}`);
      
      // Find column indices for each field
      const fieldIndices = {};
      Object.entries(config.fields).forEach(([key, fieldName]) => {
        const index = headers.findIndex(header => 
          header && header.toLowerCase().includes(fieldName.toLowerCase())
        );
        if (index !== -1) {
          fieldIndices[key] = index;
          console.log(`  ‚úì Found field "${fieldName}" at column index ${index}`);
        } else {
          console.warn(`  ‚úó Field "${fieldName}" not found in headers for ${leagueName}`);
        }
      });
      
      // Validate required fields exist
      if (fieldIndices.date === undefined) {
        console.error(`  ‚úó CRITICAL: Date field not found for ${leagueName}. Cannot import games.`);
        continue;
      }
      
      // Get all column indices to preserve all fields from sheet
      const allFieldIndices = {};
      headers.forEach((header, index) => {
        if (header && header.trim()) {
          allFieldIndices[header.trim()] = index;
        }
      });

      const featuredColumnIndex = headers.findIndex(header => header && header.trim().toLowerCase() === 'featured');
      if (featuredColumnIndex === -1) {
        console.log(`  ‚ÑπÔ∏è  No "Featured" column found for ${leagueName}`);
      } else {
        console.log(`  ‚úì Found "Featured" column at index ${featuredColumnIndex}`);
      }
      
      let gameIdCounter = 1;
      let leagueGameCount = 0;
      let displayOrder = 0; // Preserve Google Sheets row order - increment for EVERY row
      let skippedEmptyRows = 0;
      let skippedNoDate = 0;
      let skippedDateFilter = 0;
      let skippedInvalidTime = 0;
      
      // Special handling for Boxing and UFC: collect all games first, then group by time
      const isBoxingOrUFC = leagueName === 'Boxing' || leagueName === 'UFC';
      const tempGames = [];
      
      for (let i = 0; i < dataRows.length; i++) {
        const row = dataRows[i];
        
        // Increment displayOrder for every row to preserve exact Google Sheets order
        const currentDisplayOrder = displayOrder++;
        
        if (row.every(cell => cell === null || cell === undefined || cell === '' || (typeof cell === 'string' && cell.trim() === ''))) {
          skippedEmptyRows++;
          continue;
        }
        
        const rawDate = row[fieldIndices.date];
        const dateStr = rawDate ? parseDateForImport(rawDate) : null;
        if (!dateStr) {
          skippedNoDate++;
          if (i < 5) { // Log first few skipped rows for debugging
            console.log(`  Row ${i + 2} skipped: Invalid date (raw: ${rawDate})`);
          }
          continue;
        }
        
        // Only include games for today or tomorrow
        if (dateStr !== todayStr && dateStr !== tomorrowStr) {
          skippedDateFilter++;
          if (i < 5) { // Log first few skipped rows for debugging
            console.log(`  Row ${i + 2} skipped: Date ${dateStr} not in range (today: ${todayStr}, tomorrow: ${tomorrowStr})`);
          }
          continue;
        }
        
        const rawTime = row[fieldIndices.time];
        const timeStr = rawTime ? parseTimeForImport(rawTime) : '';
        // Get channel from cell - if blank, leave it as empty string (don't propagate from previous rows)
        const channel = row[fieldIndices.channel] ? String(row[fieldIndices.channel]).trim() : '';
        
        const startTime = timeStr ? createFirestoreTimestamp(dateStr, timeStr) : createFirestoreTimestamp(dateStr, '11:59 PM');
        if (!startTime) {
          skippedInvalidTime++;
          if (i < 5) { // Log first few skipped rows for debugging
            console.log(`  Row ${i + 2} skipped: Invalid timestamp (date: ${dateStr}, time: ${timeStr})`);
          }
          continue;
        }
        
        const sport = LEAGUE_TO_SPORT_MAP_FULL[leagueName] || 'Other';
        const leagueDisplayName = LEAGUE_DISPLAY_NAME_MAP_FULL[leagueName] || leagueName;
        
        const gameData = {
          'Sport': sport,
          'League': leagueDisplayName,
          'Start Time': startTime,
          'gameDate': dateStr,
          'Match Status': 'SCHEDULED',
          'Last Updated': admin.firestore.FieldValue.serverTimestamp(),
          'originalRowIndex': i, // Preserve original row index for sorting
          'hasChannel': channel && channel.trim() !== '' // Track if this row has channel data
        };
        
        // Only add channel fields if channel has a value (don't write blank channels to Firestore)
        if (channel && channel.trim() !== '') {
          gameData['Channel'] = channel;
          gameData['channel'] = channel;
        }

        if (featuredColumnIndex !== -1) {
          const featuredValue = row[featuredColumnIndex];
          if (featuredValue !== null && featuredValue !== undefined && featuredValue !== '') {
            const featuredId = String(featuredValue).trim();
            if (featuredId) {
              gameData['Featured'] = featuredId;
            }
          }
        }
        
        // Handle all leagues with home/away structure
        if (fieldIndices.home !== undefined && fieldIndices.away !== undefined) {
          const homeTeam = row[fieldIndices.home] ? String(row[fieldIndices.home]).trim() : '';
          const awayTeam = row[fieldIndices.away] ? String(row[fieldIndices.away]).trim() : '';
          
          // For soccer leagues, home is first line, away is second line
          // For non-soccer leagues (Boxing, UFC, etc.), away is first column, home is second column
          if (config.isSoccer) {
            gameData['Home Team'] = homeTeam;
            gameData['Away Team'] = awayTeam;
          } else {
            gameData['Away Team'] = awayTeam;
            gameData['Home Team'] = homeTeam;
          }
          gameData['Matchup'] = awayTeam && homeTeam ? `${awayTeam} vs ${homeTeam}` : (homeTeam || awayTeam);
        }
        
        // Preserve all other fields from the sheet
        Object.entries(allFieldIndices).forEach(([fieldName, index]) => {
          if (row[index] !== null && row[index] !== undefined && row[index] !== '') {
            const fieldValue = String(row[index]).trim();
            if (fieldValue && !gameData.hasOwnProperty(fieldName)) {
              gameData[fieldName] = fieldValue;
            }
          }
        });
        
        // Generate deterministic Game ID based on league, teams, and date (NOT time - same game should have same ID)
        const homeTeamForId = gameData['Home Team'] || '';
        const awayTeamForId = gameData['Away Team'] || '';
        const normalizedHome = (homeTeamForId || '').toLowerCase().trim().replace(/[^a-z0-9]/g, '');
        const normalizedAway = (awayTeamForId || '').toLowerCase().trim().replace(/[^a-z0-9]/g, '');
        const normalizedLeague = leagueName.toLowerCase().trim().replace(/[^a-z0-9]/g, '');
        const dateStrClean = dateStr.replace(/-/g, '');
        const gameId = `imported-${normalizedLeague}-${normalizedAway}-${normalizedHome}-${dateStrClean}`;
        gameData['Game ID'] = gameId;
        gameData['displayOrder'] = currentDisplayOrder; // Use the displayOrder captured at the start of the loop
        
        if (isBoxingOrUFC) {
          tempGames.push(gameData);
        } else {
          allGames.push(gameData);
          leagueGameCount++;
        }
      }
      
      // Special processing for Boxing/UFC: group by time, order with channel row first
      if (isBoxingOrUFC && tempGames.length > 0) {
        // Group games by time (using Start Time timestamp for grouping)
        const gamesByTime = {};
        tempGames.forEach(game => {
          const timeKey = game['Start Time'].toMillis ? game['Start Time'].toMillis() : game['Start Time'].seconds;
          if (!gamesByTime[timeKey]) {
            gamesByTime[timeKey] = [];
          }
          gamesByTime[timeKey].push(game);
        });
        
        // Sort time groups chronologically
        const sortedTimeKeys = Object.keys(gamesByTime).sort((a, b) => parseInt(a) - parseInt(b));
        
        // Process each time group
        sortedTimeKeys.forEach(timeKey => {
          // Sort time group by displayOrder to preserve exact sheet order
          const timeGroup = gamesByTime[timeKey].sort((a, b) => {
            const orderA = a.displayOrder !== undefined ? a.displayOrder : 0;
            const orderB = b.displayOrder !== undefined ? b.displayOrder : 0;
            return orderA - orderB;
          });
          
          // Find the row with channel data (if any) - use original order
          const channelRowIndex = timeGroup.findIndex(game => game.hasChannel);
          
          if (channelRowIndex !== -1) {
            // Channel row exists - mark it as main item, others as sub-items
            const channelRow = timeGroup[channelRowIndex];
            channelRow['isSubItem'] = false; // Main item (white text, shows time)
            
            // Mark all other rows in this time group as sub-items
            timeGroup.forEach((game, idx) => {
              if (idx !== channelRowIndex) {
                game['isSubItem'] = true; // Sub-item (gray text, no time)
              }
            });
            
            // Order: channel row first, then others in original sheet order (already sorted above)
            const orderedGroup = [channelRow];
            timeGroup.forEach((game, idx) => {
              if (idx !== channelRowIndex) {
                orderedGroup.push(game);
              }
            });
            
            // Add to allGames in the correct order with sortOrder field
            orderedGroup.forEach((game, groupIdx) => {
              // Create a sortOrder that combines time (milliseconds) with position within time group
              // This ensures chronological order, with channel row first, then sheet order
              const timeMs = game['Start Time'].toMillis ? game['Start Time'].toMillis() : (game['Start Time'].seconds * 1000);
              // Use groupIdx * 1000 to preserve order within same time (channel row = 0, others = 1000, 2000, etc.)
              game['sortOrder'] = timeMs + (groupIdx * 1000);
              allGames.push(game);
              leagueGameCount++;
            });
          } else {
            // No channel row - all are main items (first one shows time, others don't)
            // Keep in original sheet order
            timeGroup.forEach((game, idx) => {
              game['isSubItem'] = idx === 0 ? false : true; // First is main, rest are sub-items
              // Create sortOrder for games without channel row
              const timeMs = game['Start Time'].toMillis ? game['Start Time'].toMillis() : (game['Start Time'].seconds * 1000);
              game['sortOrder'] = timeMs + (idx * 1000); // First = 0, others = 1000, 2000, etc.
              allGames.push(game);
              leagueGameCount++;
            });
          }
        });
      }
      
      console.log(`  ‚úì Imported ${leagueGameCount} games from ${leagueName}`);
      if (skippedEmptyRows > 0) console.log(`    - Skipped ${skippedEmptyRows} empty rows`);
      if (skippedNoDate > 0) console.log(`    - Skipped ${skippedNoDate} rows with invalid/missing dates`);
      if (skippedDateFilter > 0) console.log(`    - Skipped ${skippedDateFilter} rows outside date range (today/tomorrow only)`);
      if (skippedInvalidTime > 0) console.log(`    - Skipped ${skippedInvalidTime} rows with invalid timestamps`);
    } catch (error) {
      console.error(`  ‚úó Error importing ${leagueName}:`, error.message);
    }
  }
  
  console.log(`\nTotal games imported: ${allGames.length}`);
  return allGames;
}




// =================================================================
// ORIGINAL FUNCTIONS (RETAINED)
// =================================================================
const initialScrapeAndStartPollingHandler = async (req, res) => {
try {
 console.log('--- initialScrapeAndStartPollingHandler started. ---');
  
  // --- Step 1: Move yesterday's games to yesterdayScores ---
 console.log('Moving yesterday\'s games to yesterdayScores...');
 const db = initializeFirebase();
 const gamesRef = db.collection(`artifacts/flashlive-daily-scraper/public/data/sportsGames`);
 const yesterdayScoresRef = db.collection(`artifacts/flashlive-daily-scraper/public/data/yesterdayScores`);
 
 // Get yesterday's date in Eastern Time (matches gameDate storage)
 const nowInEastern = DateTime.now().setZone('America/New_York');
 const yesterdayStr = nowInEastern.minus({ days: 1 }).toISODate();
 
 console.log(`[Move Yesterday] Looking for games with gameDate == "${yesterdayStr}" (Eastern Time)`);
 console.log(`[Move Yesterday] Current time: ${nowInEastern.toISO()} (Eastern)`);
 
 // Get ALL games from yesterday (not just FINAL) - if they're from yesterday, they should be moved
 // This fixes the issue where games weren't moved if they weren't marked as FINAL
 const snapshot = await gamesRef
   .where('gameDate', '==', yesterdayStr)
   .get();
 
 console.log(`[Move Yesterday] Found ${snapshot.size} games in sportsGames with gameDate == "${yesterdayStr}"`);
 
 // Check if games were already moved (to diagnose why move might find 0 games)
 const alreadyMovedSnapshot = await yesterdayScoresRef
   .where('gameDate', '==', yesterdayStr)
   .get();
 console.log(`[Move Yesterday] Already in yesterdayScores: ${alreadyMovedSnapshot.size} games`);
 
 // If we found 0 games but there are already games in yesterdayScores, that's expected (already moved)
 if (snapshot.size === 0 && alreadyMovedSnapshot.size > 0) {
   console.log(`[Move Yesterday] ‚ö†Ô∏è  No games found in sportsGames, but ${alreadyMovedSnapshot.size} games already exist in yesterdayScores - games were likely already moved in a previous run`);
 }
 
 // If we found 0 games and there are no games in yesterdayScores, that's a problem
 if (snapshot.size === 0 && alreadyMovedSnapshot.size === 0) {
   console.log(`[Move Yesterday] ‚ö†Ô∏è  WARNING: No games found in sportsGames AND no games in yesterdayScores for ${yesterdayStr}. This might indicate:`);
   console.log(`[Move Yesterday]    1. Games from yesterday were never stored with gameDate == "${yesterdayStr}"`);
   console.log(`[Move Yesterday]    2. Games were deleted before this move could run`);
   console.log(`[Move Yesterday]    3. Timezone mismatch - games stored with different date format`);
   
   // Try to find games with nearby dates to diagnose
   const nearbySnapshot = await gamesRef
     .where('gameDate', '>=', nowInEastern.minus({ days: 2 }).toISODate())
     .where('gameDate', '<=', nowInEastern.toISODate())
     .get();
   console.log(`[Move Yesterday]    Found ${nearbySnapshot.size} games with dates between ${nowInEastern.minus({ days: 2 }).toISODate()} and ${nowInEastern.toISODate()}`);
   if (nearbySnapshot.size > 0) {
     const dateCounts = {};
     nearbySnapshot.forEach(doc => {
       const date = doc.data().gameDate || 'unknown';
       dateCounts[date] = (dateCounts[date] || 0) + 1;
     });
     console.log(`[Move Yesterday]    Date breakdown:`, dateCounts);
   }
 }
 
 let movedCount = 0;
 const gameIdSet = new Set(); // Track Game IDs to prevent duplicates
 const canonicalKeySet = new Set(); // Track canonicalGameKeys to prevent duplicates
 
 for (const doc of snapshot.docs) {
   const data = doc.data();
   const gameId = data['Game ID'] || doc.id;
   const canonicalKey = data['canonicalGameKey'] || '';
   
   // Skip if we've already moved this game (deduplication by Game ID or canonicalGameKey)
   if (gameIdSet.has(gameId)) {
     console.log(`‚è≠Ô∏è  Skipping duplicate game ${gameId} (by Game ID)`);
     continue;
   }
   
   // Also check canonicalGameKey to catch games with different Game IDs but same teams/date
   if (canonicalKey && canonicalKeySet.has(canonicalKey)) {
     console.log(`‚è≠Ô∏è  Skipping duplicate game ${gameId} (by canonicalGameKey: ${canonicalKey})`);
     continue;
   }
   
  try {
    const gameData = {
      ...data,
      gameDate: yesterdayStr // Explicitly set gameDate to yesterdayStr
    };
    // Use Game ID as document ID to prevent duplicates
    await yesterdayScoresRef.doc(String(gameId)).set(gameData, { merge: true });
    gameIdSet.add(gameId);
     if (canonicalKey) {
       canonicalKeySet.add(canonicalKey);
     }
     movedCount++;
   } catch (err) {
     console.error(`Error moving game ${doc.id} to yesterdayScores:`, err);
   }
 }
 console.log(`‚úÖ Moved ${movedCount} games from yesterday to yesterdayScores.`);
   // Smart cleanup will happen after we get the new games list




 // --- Step 2: Populate with New Day's Games from Google Sheets ---
 console.log('Importing new games from Google Sheets...');
 await authenticateGoogleSheets();

const nowInMountain = DateTime.now().setZone('America/Denver');
const todayStr = nowInMountain.toISODate();
const tomorrowStr = nowInMountain.plus({ days: 1 }).toISODate();

// TEMPORARILY DISABLED: FlashLive API fetching - using Google Sheets import instead
/*
const rapidApiHeaders = {
   'X-RapidAPI-Key': RAPIDAPI_KEY,
   'X-RapidAPI-Host': RAPIDAPI_HOST
 };
// For API calls, use UTC dates to match FlashLive API expectations
const nowUTC = DateTime.now().setZone('utc');
const todayUTC = nowUTC.toISODate();
const tomorrowUTC = nowUTC.plus({ days: 1 }).toISODate();
 const allGames = [];
  // Specific game IDs to always fetch (workaround for API timezone issues)
 const FORCE_FETCH_GAME_IDS = [
   // Add game IDs here that API might miss due to timezone issues
   // Example: 'tKKG0rZX' // Inter Miami vs Nashville
 ];




 for (const sport of sportsToFetch) {
   // Query both today and tomorrow to catch all games that start today in EST
   const datesToQuery = [todayUTC, tomorrowUTC];
   
   for (const dateStr of datesToQuery) {
     const url = `https://${RAPIDAPI_HOST}/v1/events/list?sport_slug=${sport.slug}&date=${dateStr}&locale=en_INT&sport_id=${sport.id}&timezone=-4&indent_days=0`;
     
     try {
       const data = await fetchRapidApiData(url, rapidApiHeaders);
       const tournaments = data.DATA || [];

       for (const tour of tournaments) {
         const events = tour.EVENTS || [];
         for (const event of events) {
           // Normalize Match Status like NCAA API does
           const stageTypeNorm = (event.STAGE_TYPE || '').toUpperCase();
           const stageNorm = (event.STAGE || '').toUpperCase();
           const homeScoreNum = Number(event.HOME_SCORE_CURRENT || 0);
           const awayScoreNum = Number(event.AWAY_SCORE_CURRENT || 0);
           const hasClock = event.GAME_TIME && event.GAME_TIME !== '0:00' && event.GAME_TIME !== '0.0';
           
           let matchStatus = 'SCHEDULED';
           if (stageTypeNorm === 'FINAL' || stageNorm === 'FINAL' || stageTypeNorm.includes('FINAL')) {
             matchStatus = 'FINAL';
           } else if (
             stageTypeNorm.includes('LIVE') ||
             stageTypeNorm.includes('IN_PROGRESS') ||
             stageTypeNorm.includes('IN PROGRESS') ||
             stageTypeNorm.includes('OVERTIME') ||
             stageTypeNorm.includes('OT') ||
             stageNorm.includes('2ND HALF') ||
             stageNorm.includes('2ND QUARTER') ||
             hasClock ||
             homeScoreNum > 0 ||
             awayScoreNum > 0
           ) {
             if (!stageTypeNorm.includes('FINAL') && !stageNorm.includes('FINAL')) {
               matchStatus = 'IN PROGRESS';
             }
           } else if (stageNorm.includes('HALF') || stageTypeNorm.includes('HALF')) {
             matchStatus = 'HALFTIME';
           }
           
          // Validate and normalize GameTime for American Football
          let gameTime = event.GAME_TIME || '';
          const leagueName = tour.NAME || '';
          const isAmericanFootball = sport.name === 'American Football' || 
                                     leagueName.includes('NFL') || 
                                     leagueName.includes('NCAAF');
          
          if (gameTime && isAmericanFootball) {
            // Check if GameTime is invalid (e.g., "20:00" for quarters which should be max 15:00)
            if (gameTime.includes(':')) {
              const [minutes, seconds] = gameTime.split(':').map(Number);
              // If minutes > 15, it's likely halftime or invalid - check Stage
              const stage = (event.STAGE || '').toUpperCase();
              if (minutes > 15 || (minutes === 15 && seconds > 0)) {
                if (stage.includes('HALF') || matchStatus.includes('HALF')) {
                  // It's halftime - don't set GameTime, let Stage handle it
                  gameTime = '';
                } else {
                  // Invalid time, clamp to 15:00 max
                  gameTime = '15:00';
                }
              }
            }
          }
          
          const game = {
            'Sport': sport.name,
            'Game ID': event.EVENT_ID,
            'League': tour.NAME,
            'Matchup': `${event.HOME_NAME} vs ${event.AWAY_NAME}`,
            'Start Time': admin.firestore.Timestamp.fromMillis(event.START_TIME * 1000),
            'Home Team': event.HOME_NAME,
            'Away Team': event.AWAY_NAME,
            'Home Score': event.HOME_SCORE_CURRENT || '',
            'Away Score': event.AWAY_SCORE_CURRENT || '',
            'Status': event.STAGE || '',
            'Current Lap': event.RACE_RESULTS_LAP_DISTANCE || '',
            'Match Status': matchStatus,
            'Stage': event.STAGE || '',
            'GameTime': gameTime,
            'StageStartTime': event.STAGE_START_TIME || '',
            'StartTime': event.START_TIME || '',
           'StageType': event.STAGE_TYPE || '',
           'Last Updated': new Date().toISOString(),
           'gameDate': DateTime.fromMillis(event.START_TIME * 1000).setZone('America/New_York').toISODate()
          };
          allGames.push(game);
         }
       }
     } catch (err) {
       console.error(`Error fetching ${sport.name} for ${dateStr}: ${err.message}`);
     }
   }
 }
  // TEMPORARILY DISABLED: Formula 1 deduplication - F1 is now handled via manual entry
  // Deduplicate Formula 1 races - keep only one entry per race
  /*
 const f1RaceMap = new Map();
 const nonF1Games = [];
  allGames.forEach(game => {
   if (game.Sport === 'Motorsport' && game.League && game.League.includes('Formula 1')) {
     // For F1, use Grand Prix name as unique key (not session type)
     const leagueParts = game.League.split(':');
     const eventName = leagueParts[1] ? leagueParts[1].trim() : '';
     const sessionParts = eventName.split(' - ');
     const grandPrixName = (sessionParts[0] || '').replace('Grand Prix', 'GP');
     const sessionType = (sessionParts[1] || '').trim();
     const raceKey = `${grandPrixName}|${sessionType || 'Session'}`; // Unique key per GP + session type
     if (!f1RaceMap.has(raceKey)) {
       // Extract event name and session type from league string
       // "Formula 1: Mexican Grand Prix - Race" -> grandPrixName: "Mexican Grand Prix", sessionType: "Race"
       const leagueParts = game.League.split(':');
       const eventName = leagueParts[1] ? leagueParts[1].trim() : '';
       const sessionParts = eventName.split(' - ');
       const grandPrixName = (sessionParts[0] || '').replace('Grand Prix', 'GP');
       const sessionType = sessionParts[1] || '';
      
       // Create a synthetic Game ID based on league + start time (to avoid driver-specific IDs)
       const sanitizedSessionType = sessionType ? sessionType.replace(/\s+/g, '_') : 'Session';
       const syntheticGameId = `F1_${game.StartTime}_${grandPrixName.replace(/\s+/g, '_')}_${sanitizedSessionType}`;
      
       game['Game ID'] = syntheticGameId;
       game.Matchup = `${grandPrixName}\n${sessionType}`;
       game['Home Team'] = sessionType;
       game['Away Team'] = grandPrixName;
       // Put live lap data in start time column (where LIVE appears)
       if (game.Score && game.Score.includes('Lap')) {
         game['Start Time'] = game.Score; // Move lap data to start time column
         game.Score = ''; // Clear the scores column
       }
       f1RaceMap.set(raceKey, game);
     }
   } else {
     nonF1Games.push(game);
   }
 });
  // Combine deduplicated F1 races with other games
 const deduplicatedGames = [...Array.from(f1RaceMap.values()), ...nonF1Games];
 console.log(`Deduplicated ${allGames.length} games to ${deduplicatedGames.length} (removed ${allGames.length - deduplicatedGames.length} duplicate F1 driver entries)`);
  // Replace allGames with deduplicated version
 allGames.length = 0;
 allGames.push(...deduplicatedGames);
  */
  /*
  // Fetch specific games by ID (workaround for API timezone issues)
 if (FORCE_FETCH_GAME_IDS.length > 0) {
   console.log(`Fetching ${FORCE_FETCH_GAME_IDS.length} specific game(s) by ID...`);
   for (const gameId of FORCE_FETCH_GAME_IDS) {
     try {
       const url = `https://${RAPIDAPI_HOST}/v1/event/detail?event_id=${gameId}&locale=en_INT`;
       const data = await fetchRapidApiData(url, rapidApiHeaders);
      
       if (data && data.EVENT) {
         const event = data.EVENT;
         // Normalize Match Status like NCAA API does
         const stageTypeNorm = (event.STAGE_TYPE || '').toUpperCase();
         const stageNorm = (event.STAGE || '').toUpperCase();
         const homeScoreNum = Number(event.HOME_SCORE_CURRENT || 0);
         const awayScoreNum = Number(event.AWAY_SCORE_CURRENT || 0);
         const hasClock = event.GAME_TIME && event.GAME_TIME !== '0:00' && event.GAME_TIME !== '0.0';
         
         let matchStatus = 'SCHEDULED';
         if (stageTypeNorm === 'FINAL' || stageNorm === 'FINAL' || stageTypeNorm.includes('FINAL')) {
           matchStatus = 'FINAL';
         } else if (
           stageTypeNorm.includes('LIVE') ||
           stageTypeNorm.includes('IN_PROGRESS') ||
           stageTypeNorm.includes('IN PROGRESS') ||
           stageTypeNorm.includes('OVERTIME') ||
           stageTypeNorm.includes('OT') ||
           stageNorm.includes('2ND HALF') ||
           stageNorm.includes('2ND QUARTER') ||
           hasClock ||
           homeScoreNum > 0 ||
           awayScoreNum > 0
         ) {
           if (!stageTypeNorm.includes('FINAL') && !stageNorm.includes('FINAL')) {
             matchStatus = 'IN PROGRESS';
           }
         } else if (stageNorm.includes('HALF') || stageTypeNorm.includes('HALF')) {
           matchStatus = 'HALFTIME';
         }
         
        // Validate and normalize GameTime for American Football
        let gameTime = event.GAME_TIME || '';
        const leagueName = event.TOURNAMENT_NAME || event.LEAGUE_NAME || '';
        const sportName = event.SPORT_NAME || '';
        const isAmericanFootball = sportName === 'American Football' || 
                                   leagueName.includes('NFL') || 
                                   leagueName.includes('NCAAF');
        
        if (gameTime && isAmericanFootball) {
          // Check if GameTime is invalid (e.g., "20:00" for quarters which should be max 15:00)
          if (gameTime.includes(':')) {
            const [minutes, seconds] = gameTime.split(':').map(Number);
            // If minutes > 15, it's likely halftime or invalid - check Stage
            const stage = (event.STAGE || '').toUpperCase();
            if (minutes > 15 || (minutes === 15 && seconds > 0)) {
              if (stage.includes('HALF') || matchStatus.includes('HALF')) {
                // It's halftime - don't set GameTime, let Stage handle it
                gameTime = '';
              } else {
                // Invalid time, clamp to 15:00 max
                gameTime = '15:00';
              }
            }
          }
        }
        
        const game = {
          'Sport': sportName,
          'Game ID': event.EVENT_ID,
          'League': leagueName || 'Unknown',
          'Matchup': `${event.HOME_NAME} vs ${event.AWAY_NAME}`,
          'Start Time': admin.firestore.Timestamp.fromMillis(event.START_TIME * 1000),
          'Home Team': event.HOME_NAME,
          'Away Team': event.AWAY_NAME,
          'Home Score': event.HOME_SCORE_CURRENT || '',
          'Away Score': event.AWAY_SCORE_CURRENT || '',
          'Status': event.STAGE || '',
          'Current Lap': event.RACE_RESULTS_LAP_DISTANCE || '',
          'Match Status': matchStatus,
          'Stage': event.STAGE || '',
          'GameTime': gameTime,
          'StageStartTime': event.STAGE_START_TIME || '',
          'StartTime': event.START_TIME || '',
          'StageType': event.STAGE_TYPE || '',
          'Last Updated': new Date().toISOString(),
          'gameDate': DateTime.fromMillis(event.START_TIME * 1000).setZone('America/Denver').toISODate()
        };
        
         // Only add if not already in allGames
         if (!allGames.find(g => g['Game ID'] === gameId)) {
           allGames.push(game);
           console.log(`  ‚úÖ Added game ${gameId}: ${event.HOME_NAME} vs ${event.AWAY_NAME}`);
         } else {
           console.log(`  ‚è≠Ô∏è  Game ${gameId} already fetched`);
         }
       }
     } catch (err) {
       console.error(`  ‚ùå Error fetching game ${gameId}: ${err.message}`);
     }
   }
 }
 console.log(`Fetched ${allGames.length} games from RapidAPI.`);
*/

// Import games from all 4 Google Sheets
const allGames = await importGamesFromSheets();

// Smart cleanup: Delete old games and games removed from sheets
console.log('Performing smart Firestore cleanup...');
await smartUpdateFirestoreCollection(allGames);

// Write all imported games directly to Firestore (only writes changed/new games)
console.log(`Writing ${allGames.length} games to Firestore...`);
await writeGamesToFirestore(allGames);
console.log(`Successfully completed Firestore write: ${allGames.length} games imported from Google Sheets.`);




 if (res) {
   res.status(200).send(`Imported ${allGames.length} games from Google Sheets to Firestore.`);
 }
} catch (err) {
 console.error('--- initialScrapeAndStartPollingHandler FAILED ---', err);
 if (res) res.status(500).send('Scrape failed.');
}
};








const pollLiveGamesHandler = async (req, res) => {
try {
 console.log('--- pollLiveGamesHandler started. ---');




 const db = initializeFirebase();
 const gamesRef = db.collection(`artifacts/flashlive-daily-scraper/public/data/sportsGames`);
const nowInMountain = DateTime.now().setZone('America/Denver');
const todayStr = nowInMountain.toISODate();
const yesterdayStr = nowInMountain.minus({ days: 1 }).toISODate();
const tomorrowStr = nowInMountain.plus({ days: 1 }).toISODate();
 console.log(`[Backend] Current Mountain Time Date (todayStr): ${todayStr}`);




 // OPTIMIZATION: Filter by date range to avoid reading entire collection
 const snapshot = await gamesRef
   .where('gameDate', '>=', yesterdayStr)
   .where('gameDate', '<=', tomorrowStr)
   .get();
 const deleteBatch = db.batch();
 let deleteCount = 0;




snapshot.forEach(doc => {
  const data = doc.data();
  const matchStatus = (data['Match Status'] || '').toUpperCase();
  const isLive = matchStatus.includes('IN PROGRESS') || matchStatus.includes('LIVE') || matchStatus === 'LIVE';
   // Only delete games that are from a different date AND not live
  if (data.gameDate !== todayStr && !isLive) {
    deleteBatch.delete(doc.ref);
    deleteCount++;
  }
});




 if (deleteCount > 0) {
   await deleteBatch.commit();
   console.log(`üßπ Deleted ${deleteCount} old games from Firestore.`);
 } else {
   console.log('‚úÖ No old games to delete.');
 }




 const rapidApiHeaders = {
   'X-RapidAPI-Key': RAPIDAPI_KEY,
   'X-RapidAPI-Host': RAPIDAPI_HOST
 };




 const allGames = [];
  // For API calls, use UTC dates to match FlashLive API expectations
 const nowUTC = DateTime.now().setZone('utc');
 const todayUTC = nowUTC.toISODate();
 const tomorrowUTC = nowUTC.plus({ days: 1 }).toISODate();
  for (const sport of sportsToFetch) {
   // Query both today and tomorrow to catch all games that start today in EST
   const datesToQuery = [todayUTC, tomorrowUTC];
  
   for (const dateStr of datesToQuery) {
     const url = `https://${RAPIDAPI_HOST}/v1/events/list?sport_slug=${sport.slug}&date=${dateStr}&locale=en_INT&sport_id=${sport.id}&timezone=-4&indent_days=0`;
     try {
       const data = await fetchRapidApiData(url, rapidApiHeaders);
       const tournaments = data.DATA || [];
       for (const tour of tournaments) {
         for (const event of tour.EVENTS || []) {
           // Normalize Match Status like NCAA API does
           const stageTypeNorm = (event.STAGE_TYPE || '').toUpperCase();
           const stageNorm = (event.STAGE || '').toUpperCase();
           const homeScoreNum = Number(event.HOME_SCORE_CURRENT || 0);
           const awayScoreNum = Number(event.AWAY_SCORE_CURRENT || 0);
           const hasClock = event.GAME_TIME && event.GAME_TIME !== '0:00' && event.GAME_TIME !== '0.0';
           
           let matchStatus = 'SCHEDULED';
           if (stageTypeNorm === 'FINAL' || stageNorm === 'FINAL' || stageTypeNorm.includes('FINAL')) {
             matchStatus = 'FINAL';
           } else if (
             stageTypeNorm.includes('LIVE') ||
             stageTypeNorm.includes('IN_PROGRESS') ||
             stageTypeNorm.includes('IN PROGRESS') ||
             stageTypeNorm.includes('OVERTIME') ||
             stageTypeNorm.includes('OT') ||
             stageNorm.includes('2ND HALF') ||
             stageNorm.includes('2ND QUARTER') ||
             hasClock ||
             homeScoreNum > 0 ||
             awayScoreNum > 0
           ) {
             if (!stageTypeNorm.includes('FINAL') && !stageNorm.includes('FINAL')) {
               matchStatus = 'IN PROGRESS';
             }
           } else if (stageNorm.includes('HALF') || stageTypeNorm.includes('HALF')) {
             matchStatus = 'HALFTIME';
           }
           
          allGames.push({
            'Sport': sport.name,
            'Game ID': event.EVENT_ID,
            'League': tour.NAME,
            'Matchup': `${event.HOME_NAME || ''} vs ${event.AWAY_NAME || ''}`,
            'Start Time': admin.firestore.Timestamp.fromMillis(event.START_TIME * 1000),
            'Home Team': event.HOME_NAME || '',
            'Away Team': event.AWAY_NAME || '',
            'Home Score': event.HOME_SCORE_CURRENT || '',
            'Away Score': event.AWAY_SCORE_CURRENT || '',
            'Status': event.STAGE || '',
            'Match Status': matchStatus,
            'Current Lap': event.RACE_RESULTS_LAP_DISTANCE || '',
            'Stage': event.STAGE || '',
            'GameTime': event.GAME_TIME || '',
           'StageStartTime': event.STAGE_START_TIME || '',
           'StartTime': event.START_TIME || '',
           'StageType': event.STAGE_TYPE || '',
           'Last Updated': new Date().toISOString(),
           'gameDate': DateTime.fromMillis(event.START_TIME * 1000).setZone('America/New_York').toISODate()
         });
        }
      }
    } catch (err) {
      console.error(`Error fetching ${sport.name} for ${dateStr}: ${err.message}`);
    }
  }
}
console.log(`Fetched ${allGames.length} games from RapidAPI.`);

 // TEMPORARILY DISABLED: Formula 1 deduplication - F1 is now handled via manual entry
 // Deduplicate Formula 1 races - keep only one entry per race
 /*
 const f1RaceMapPoll = new Map();
 const nonF1GamesPoll = [];
  allGames.forEach(game => {
   if (game.Sport === 'Motorsport' && game.League && game.League.includes('Formula 1')) {
     // For F1, use Grand Prix name as unique key (not session type)
     const leagueParts = game.League.split(':');
     const eventName = leagueParts[1] ? leagueParts[1].trim() : '';
     const sessionParts = eventName.split(' - ');
     const grandPrixName = (sessionParts[0] || '').replace('Grand Prix', 'GP');
     const sessionType = (sessionParts[1] || '').trim();
     const raceKey = `${grandPrixName}|${sessionType || 'Session'}`; // Unique key per GP + session type
     if (!f1RaceMapPoll.has(raceKey)) {
       // Extract event name and session type from league string
       // "Formula 1: Mexican Grand Prix - Race" -> grandPrixName: "Mexican Grand Prix", sessionType: "Race"
       const leagueParts = game.League.split(':');
       const eventName = leagueParts[1] ? leagueParts[1].trim() : '';
       const sessionParts = eventName.split(' - ');
       const grandPrixName = (sessionParts[0] || '').replace('Grand Prix', 'GP');
       const sessionType = sessionParts[1] || '';
      
       // Create a synthetic Game ID based on league + start time (to avoid driver-specific IDs)
       const sanitizedSessionType = sessionType ? sessionType.replace(/\s+/g, '_') : 'Session';
       const syntheticGameId = `F1_${game.StartTime}_${grandPrixName.replace(/\s+/g, '_')}_${sanitizedSessionType}`;
      
       game['Game ID'] = syntheticGameId;
       game.Matchup = `${grandPrixName}\n${sessionType}`;
       game['Home Team'] = sessionType;
       game['Away Team'] = grandPrixName;
       // Put live lap data in start time column (where LIVE appears)
       if (game.Score && game.Score.includes('Lap')) {
         game['Start Time'] = game.Score; // Move lap data to start time column
         game.Score = ''; // Clear the scores column
       }
       f1RaceMapPoll.set(raceKey, game);
     }
   } else {
     nonF1GamesPoll.push(game);
   }
 });
  // Combine deduplicated F1 races with other games
 const deduplicatedGamesPoll = [...Array.from(f1RaceMapPoll.values()), ...nonF1GamesPoll];
 console.log(`Deduplicated ${allGames.length} games to ${deduplicatedGamesPoll.length} (removed ${allGames.length - deduplicatedGamesPoll.length} duplicate F1 driver entries)`);
  // Replace allGames with deduplicated version
 allGames.length = 0;
 allGames.push(...deduplicatedGamesPoll);
 */




 // Debug: Log all unique leagues being fetched
 const uniqueLeagues = [...new Set(allGames.map(g => g.League))];
 console.log('All leagues being fetched:', uniqueLeagues);

// Debug: Log leagues by sport to see what FlashLive API returns
const leaguesBySport = {};
allGames.forEach(g => {
  if (!leaguesBySport[g.Sport]) leaguesBySport[g.Sport] = new Set();
  leaguesBySport[g.Sport].add(g.League);
});
Object.keys(leaguesBySport).forEach(sport => {
  console.log(`${sport} leagues from FlashLive:`, Array.from(leaguesBySport[sport]));
});

const gamesForFirestore = allGames.filter(g => {
  const allowedLeaguesForSport = ALLOWED_LEAGUE_KEYWORDS[g.Sport] || [];
 
  // TEMPORARILY DISABLED: Formula 1 is now handled via manual entry
  // Special handling for Formula 1 - check if league name includes "Formula 1"
  // const isF1 = g.Sport === 'Motorsport' && g.League && g.League.includes('Formula 1');
  const isF1 = false; // Disabled - F1 now manual
  
  // Special handling for Tennis leagues containing "ATP"
  const isATPTennis = g.Sport === 'Tennis' && g.League && g.League.includes('ATP');
  
  // Special handling for "USA: NCAA" - it can be Basketball, American Football, or Hockey
  // BUT: Exclude NCAAM/NCAAW Basketball from FlashLive polling since FlashLive doesn't provide live updates
  // These will be handled by NCAA API polling within pollLiveGamesHandler (which preserves Game IDs and matches by team names)
  const isNCAA = g.League === 'USA: NCAA' || g.League === 'USA: NCAA Women';
  const isNCAAAllowed = isNCAA && (
    (g.Sport === 'American Football' && allowedLeaguesForSport.includes(g.League)) ||
    (g.Sport === 'Hockey' && allowedLeaguesForSport.includes(g.League))
    // Exclude Basketball - handled by NCAA API polling within pollLiveGamesHandler
  );
  
  // Special handling for qualification leagues - use prefix matching
  const isQualificationLeague = g.Sport === 'Soccer' && g.League && (
    g.League.startsWith('Africa: World Cup - Qualification') ||
    g.League.startsWith('Asia: World Cup - Qualification') ||
    g.League.startsWith('Asia: Asian Cup - Qualification') ||
    g.League.startsWith('Europe: World Cup - Qualification') ||
    g.League.startsWith('North & Central America: World Cup - Qualification')
  );
  
  const isAllowedLeague = isF1 || isATPTennis || isNCAAAllowed || isQualificationLeague || allowedLeaguesForSport.includes(g.League);
  
  // For F1, only Home Team is required (Away Team is empty). For others, both are required.
  const hasValidTeams = isF1 ? g['Home Team'] : (g['Home Team'] && g['Away Team']);
  const hasStartTime = g['Start Time'];
  const hasGameId = g['Game ID'];
  // Filter out games with "U" followed by numbers (e.g., U20, U23, U19) for World: Friendly International
 const isUTeamGame = g.League === 'World: Friendly International' &&
   (/\bU\d+\b/.test(g['Home Team']) || /\bU\d+\b/.test(g['Away Team']));
  // ---------- TIME FILTER (for live polling, include live games and games within ~24 hours) ----------
 // For pollLiveGames: Include games that are:
 // 1. Currently live (IN PROGRESS) - regardless of date
 // 2. Scheduled for today or tomorrow
 // 3. Started within the last 24 hours (in case they're still updating)
 let isWithinLocalWindow = true;
 const isLive = (g['Match Status'] || '').toUpperCase().includes('IN PROGRESS') || 
                (g['Match Status'] || '').toUpperCase().includes('LIVE') ||
                (g['StageType'] || '').toUpperCase().includes('LIVE');
 
 if (g['Start Time'] && g['Start Time'].toDate) {
   try {
     const startTimeUTC = g['Start Time'].toDate().toISOString();
     const gameUTC = DateTime.fromISO(startTimeUTC, { zone: 'utc' });
     const nowUTC = DateTime.now().setZone('utc');
     
     // If game is live, always include it (regardless of date)
     if (isLive) {
       isWithinLocalWindow = true;
     } else {
       // For non-live games, check if they're within the last 24 hours or next 24 hours
       const hoursDiff = gameUTC.diff(nowUTC, 'hours').hours;
       // Include games that started within last 24 hours or are scheduled within next 24 hours
       isWithinLocalWindow = hoursDiff >= -24 && hoursDiff <= 24;
     }
   } catch (error) {
     console.log('Error parsing start time for game:', g['Game ID'], error);
     // If there's an error parsing time, but game is live, include it
     isWithinLocalWindow = isLive;
   }
 }
  
  const passesFilter = isAllowedLeague && hasValidTeams && hasStartTime && hasGameId && !isUTeamGame && isWithinLocalWindow;
  
  // Debug logging for non-soccer games
  if (!passesFilter && (g.Sport === 'Basketball' || g.Sport === 'American Football' || g.Sport === 'Hockey')) {
    console.log(`‚ö†Ô∏è Filtered out: Sport=${g.Sport}, League="${g.League}", isAllowedLeague=${isAllowedLeague}, hasValidTeams=${hasValidTeams}, hasStartTime=${!!hasStartTime}, hasGameId=${!!hasGameId}, isUTeamGame=${isUTeamGame}, isWithinLocalWindow=${isWithinLocalWindow}`);
  }
  
  // Debug logging for games that pass the filter
  if (passesFilter && (g.Sport === 'Basketball' || g.Sport === 'American Football' || g.Sport === 'Hockey')) {
    console.log(`‚úÖ Passing filter: ${g['Away Team']} vs ${g['Home Team']} (${g.Sport} - ${g.League}) - Status: ${g['Match Status']}`);
  }
  
  return passesFilter;
});
console.log(`Filtered ${gamesForFirestore.length} games for Firestore using exact matching.`);




 if (gamesForFirestore.length > 0) {
   await writeGamesToFirestore(gamesForFirestore);
   console.log(`‚úÖ Successfully updated ${gamesForFirestore.length} games in Firestore.`);
 } else {
   console.log('‚ö†Ô∏è No valid games to update.');
 }

 let totalGamesUpdated = gamesForFirestore.length;
 
 // Poll NCAA API directly for NCAAM/NCAAW live scores (not FlashLive API)
console.log('--- Starting NCAA API polling for NCAAM/NCAAW ---');
const ENABLE_NCAA_API = false;

if (ENABLE_NCAA_API) {
  try {
    const todayNCAA = nowInMountain.toFormat('yyyy/MM/dd');
    const ncaaGames = [];

    const FLASH_LIVE_TO_NCAA_API_MAP = {
      'NCAAM': {
        'North Carolina A&T': 'North Carolina A&T',
        'N. Carolina A&T': 'North Carolina A&T'
      },
      'NCAAW': {
        'Albany Great Danes': 'Albany (NY)',
        'Arkansas Razorbacks': 'Arkansas',
        'Boise State': 'Boise St.',
        'Boston': 'Boston U.',
        'Cincinnati Bearcats': 'Cincinnati',
        'Colorado State': 'Colorado St.',
        'Dallas Univ.': 'Dallas',
        'Delaware State': 'Delaware St.',
        'Dickinson Red Devils': 'Dickinson',
        'East Texas A&M': 'East Tex. A&M',
        'East. Washington': 'Eastern Wash.',
        'Florida Atlantic': 'Florida Atlantic',
        'Frostburg State Bobcats': 'Frostburg St.',
        'Houston Cougars': 'Houston',
        'Houston Christian': 'Houston Christian',
        'Illinois Fighting Illini': 'Illinois',
        'Iowa State': 'Iowa St.',
        'James Madison': 'James Madison',
        'Kennesaw State': 'Kennesaw St.',
        'Lipscomb Bisons': 'Lipscomb',
        'Louisville': 'Louisville',
        'Loyola Marymount': 'Loyola Marymount',
        'LSU Tigers': 'LSU',
        'MD-E. Shore': 'Md.-East. Shore',
        'Md.-East. Shore': 'Md.-East. Shore',
        'Mercyhurst Lakers': 'Mercyhurst',
        'Merrimack Warriors': 'Merrimack',
        'Michigan Wolverines': 'Michigan',
        'Michigan State': 'Michigan St.',
        'Middle Tenn. St.': 'Middle Tenn.',
        'Miss. Valley St. ': 'Mississippi Val.',
        'NC State': 'North Carolina St.',
        'Nebraska': 'Nebraska',
        'New Haven Chargers': 'New Haven',
        'North Alabama': 'North Ala.',
        'North Carolina A&T': 'North Carolina A&T',
        'N. Carolina A&T': 'North Carolina A&T',
        'North Dakota St': 'North Dakota St.',
        'Northern Colorado': 'Northern Colo.',
        'Northern New Mexico': 'Northern New Mexico',
        'Northwest Indian': 'Northwest Indian',
        'Notre Dame': 'Notre Dame',
        'Ottawa Spirit': 'Ottawa Spirit',
        'Pacific Lutheran': 'Pacific Lutheran',
        'Prairie View A&M': 'Prairie View',
        'Providence Friars': 'Providence',
        'Purdue': 'Purdue',
        'Queens Royals': 'Queens (NC)',
        'Regent University': 'Regent University',
        'Richmond Spiders': 'Richmond',
        'RIT Tigers': 'Rochester Inst.',
        "Saint Josephs Hawks": "Saint Joseph's",
        "Saint Marys Gaels": "Saint-Mary's (CA)",
        'SE Missouri State': 'Southeast Mo. St.',
        'Sewanee Tigers': 'Sewanee',
        'SMU Mustangs': 'SMU',
        'South Dakota Coyotes': 'South Dakota',
        'Southern Illinois': 'Southern Ill.',
        'Southern Indiana': 'Southern Ind.',
        'Southern Univ.': 'Southern U.',
        'Southern Virginia': 'Southern Virginia',
        "St. Peters": "Saint Peter's",
        'Tennessee Volunteers': 'Tennessee',
        'Texas A&M SA Jaguars': 'Texas A&M SA Jaguars',
        'Troy ': 'Troy',
        'Tulane': 'Tulane',
        'Tulsa': 'Tulsa',
        'UTSA Roadrunners': 'Texas at San Antonio',
        'USC Trojans': 'Southern California',
        'Virginia Cavaliers': 'Virginia',
        'Washington & Lee': 'Wash. & Lee',
        'Western Illinois': 'Western Ill.',
        'Westminster Blue Jays': 'Westminster (MO)',
        'Westminster UT': 'Westminster (UT)'
      }
    };

    function mapFlashLiveToNCAA(flashLiveName, league) {
      if (!flashLiveName) return '';
      let normalized = flashLiveName.endsWith(' W') ? flashLiveName.slice(0, -2) : flashLiveName;
      normalized = normalized.replace(/^\d+\s+/, '').trim();
      const leagueKey = league === 'USA: NCAA' ? 'NCAAM' : 'NCAAW';
      const leagueMap = FLASH_LIVE_TO_NCAA_API_MAP[leagueKey];
      if (leagueMap && leagueMap[normalized]) {
        return leagueMap[normalized];
      }
      return normalized;
    }

    function normalizeTeamNameForNCAA(name) {
      if (!name) return '';
      let normalized = name.endsWith(' W') ? name.slice(0, -2) : name;
      normalized = normalized.replace(/^\d+\s+/, '');
      return normalized
        .toLowerCase()
        .normalize('NFD')
        .replace(/[\u0300-\u036f]/g, '')
        .replace(/[^a-z0-9\s]/g, ' ')
        .replace(/\s+/g, ' ')
        .trim();
    }

    try {
      const ncaamUrl = `https://ncaa-api.henrygd.me/scoreboard/basketball-men/d1/${todayNCAA}`;
      console.log(`Fetching NCAAM games from NCAA API: ${ncaamUrl}`);
      const ncaamResponse = await fetch(ncaamUrl, {
        headers: {
          'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36'
        }
      });
      if (!ncaamResponse.ok) {
        throw new Error(`HTTP error! status: ${ncaamResponse.status}`);
      }
      const ncaamData = await ncaamResponse.json();

      if (ncaamData.games && Array.isArray(ncaamData.games)) {
        for (const gameItem of ncaamData.games) {
          const game = gameItem.game;
          if (!game) continue;

          const awayTeam = game.away;
          const homeTeam = game.home;
          if (!awayTeam || !homeTeam) continue;

          const awayScore = awayTeam.score || '';
          const homeScore = homeTeam.score || '';
          const finalMessage = game.finalMessage || '';
          const gameState = game.gameState || '';
          const contestClock = game.contestClock || '';
          const currentPeriod = game.currentPeriod || '';
          const startTimeEpochSeconds = game.startTimeEpoch ? Number(game.startTimeEpoch) : null;
          const startTimeMillis = Number.isFinite(startTimeEpochSeconds) ? startTimeEpochSeconds * 1000 : null;
          const startTimeDisplay = game.startTime || game.start || '';
          const startDate = game.startDate || '';

          const finalMessageNorm = (finalMessage || '').toUpperCase();
          const gameStateNorm = (gameState || '').toUpperCase();
          const currentPeriodNorm = (currentPeriod || '').toUpperCase();
          const hasClock = contestClock && contestClock !== '0:00';
          const homeScoreNum = Number(homeScore);
          const awayScoreNum = Number(awayScore);

          let matchStatus = 'SCHEDULED';
          if (finalMessageNorm === 'FINAL' || gameStateNorm === 'FINAL' || currentPeriodNorm === 'FINAL') {
            matchStatus = 'FINAL';
          } else if (
            finalMessageNorm.includes('LIVE') ||
            ['LIVE', 'IN_PROGRESS', 'IN PROGRESS', 'OVERTIME', 'OT', '2ND HALF', '2ND QUARTER'].some(state => gameStateNorm.includes(state)) ||
            hasClock ||
            homeScoreNum > 0 ||
            awayScoreNum > 0
          ) {
            if (!finalMessageNorm.includes('FINAL') && !gameStateNorm.includes('FINAL')) {
              matchStatus = 'IN PROGRESS';
            }
          } else if (currentPeriodNorm.includes('HALF')) {
            matchStatus = 'HALFTIME';
          }

          const stageType = matchStatus === 'IN PROGRESS' ? 'LIVE' : matchStatus;
          const stageValue = currentPeriod || finalMessage || matchStatus;
          const statusDisplay = matchStatus === 'IN PROGRESS'
            ? (currentPeriod || finalMessage || 'IN PROGRESS')
            : matchStatus;
          const startDateLuxon = startDate
            ? DateTime.fromFormat(startDate, 'MM-dd-yyyy', { zone: 'America/Denver' })
            : null;
          const startDateIso = startDateLuxon && startDateLuxon.isValid ? startDateLuxon.toISODate() : null;
          const gameDateIso = startTimeMillis
            ? DateTime.fromMillis(startTimeMillis).setZone('America/New_York').toISODate()
            : (startDateIso || todayStr);

          const awayTeamName = awayTeam.names.short || awayTeam.names.full || awayTeam.names.seo || '';
          const homeTeamName = homeTeam.names.short || homeTeam.names.full || homeTeam.names.seo || '';

          if (awayTeamName && homeTeamName) {
            ncaaGames.push({
              league: 'USA: NCAA',
              sport: 'Basketball',
              homeTeam: homeTeamName,
              awayTeam: awayTeamName,
              homeScore: homeScore.toString(),
              awayScore: awayScore.toString(),
              matchStatus,
              status: statusDisplay,
              stage: stageValue,
              stageType,
              gameTime: contestClock || '',
              currentPeriod,
              ncaaGameId: game.gameID,
              startTimeMillis,
              startTimeDisplay,
              gameDateIso
            });
          }
        }
      }

      console.log(`Fetched ${ncaaGames.filter(g => g.league === 'USA: NCAA').length} NCAAM games from NCAA API.`);
    } catch (err) {
      console.error(`Error fetching NCAAM games from NCAA API: ${err.message}`);
    }

    await new Promise(resolve => setTimeout(resolve, 250));

    try {
      const ncaawUrl = `https://ncaa-api.henrygd.me/scoreboard/basketball-women/d1/${todayNCAA}`;
      console.log(`Fetching NCAAW games from NCAA API: ${ncaawUrl}`);
      const ncaawResponse = await fetch(ncaawUrl, {
        headers: {
          'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36'
        }
      });
      if (!ncaawResponse.ok) {
        throw new Error(`HTTP error! status: ${ncaawResponse.status}`);
      }
      const ncaawData = await ncaawResponse.json();

      if (ncaawData.games && Array.isArray(ncaawData.games)) {
        for (const gameItem of ncaawData.games) {
          const game = gameItem.game;
          if (!game) continue;

          const awayTeam = game.away;
          const homeTeam = game.home;
          if (!awayTeam || !homeTeam) continue;

          const awayScore = awayTeam.score || '';
          const homeScore = homeTeam.score || '';
          const finalMessage = game.finalMessage || '';
          const gameState = game.gameState || '';
          const contestClock = game.contestClock || '';
          const currentPeriod = game.currentPeriod || '';
          const startTimeEpochSeconds = game.startTimeEpoch ? Number(game.startTimeEpoch) : null;
          const startTimeMillis = Number.isFinite(startTimeEpochSeconds) ? startTimeEpochSeconds * 1000 : null;
          const startTimeDisplay = game.startTime || game.start || '';
          const startDate = game.startDate || '';

          const finalMessageNorm = (finalMessage || '').toUpperCase();
          const gameStateNorm = (gameState || '').toUpperCase();
          const currentPeriodNorm = (currentPeriod || '').toUpperCase();
          const hasClock = contestClock && contestClock !== '0:00';
          const homeScoreNum = Number(homeScore);
          const awayScoreNum = Number(awayScore);

          let matchStatus = 'SCHEDULED';
          if (finalMessageNorm === 'FINAL' || gameStateNorm === 'FINAL' || currentPeriodNorm === 'FINAL') {
            matchStatus = 'FINAL';
          } else if (
            finalMessageNorm.includes('LIVE') ||
            ['LIVE', 'IN_PROGRESS', 'IN PROGRESS', 'OVERTIME', 'OT', '2ND HALF', '2ND QUARTER'].some(state => gameStateNorm.includes(state)) ||
            hasClock ||
            homeScoreNum > 0 ||
            awayScoreNum > 0
          ) {
            if (!finalMessageNorm.includes('FINAL') && !gameStateNorm.includes('FINAL')) {
              matchStatus = 'IN PROGRESS';
            }
          } else if (currentPeriodNorm.includes('HALF')) {
            matchStatus = 'HALFTIME';
          }

          const stageType = matchStatus === 'IN PROGRESS' ? 'LIVE' : matchStatus;
          const stageValue = currentPeriod || finalMessage || matchStatus;
          const statusDisplay = matchStatus === 'IN PROGRESS'
            ? (currentPeriod || finalMessage || 'IN PROGRESS')
            : matchStatus;
          const startDateLuxon = startDate
            ? DateTime.fromFormat(startDate, 'MM-dd-yyyy', { zone: 'America/Denver' })
            : null;
          const startDateIso = startDateLuxon && startDateLuxon.isValid ? startDateLuxon.toISODate() : null;
          const gameDateIso = startTimeMillis
            ? DateTime.fromMillis(startTimeMillis).setZone('America/New_York').toISODate()
            : (startDateIso || todayStr);

          const awayTeamName = awayTeam.names.short || awayTeam.names.full || awayTeam.names.seo || '';
          const homeTeamName = homeTeam.names.short || homeTeam.names.full || homeTeam.names.seo || '';

          if (awayTeamName && homeTeamName) {
            ncaaGames.push({
              league: 'USA: NCAA Women',
              sport: 'Basketball',
              homeTeam: homeTeamName,
              awayTeam: awayTeamName,
              homeScore: homeScore.toString(),
              awayScore: awayScore.toString(),
              matchStatus,
              status: statusDisplay,
              stage: stageValue,
              stageType,
              gameTime: contestClock || '',
              currentPeriod,
              ncaaGameId: game.gameID,
              startTimeMillis,
              startTimeDisplay,
              gameDateIso
            });
          }
        }
      }

      console.log(`Fetched ${ncaaGames.filter(g => g.league === 'USA: NCAA Women').length} NCAAW games from NCAA API.`);
    } catch (err) {
      console.error(`Error fetching NCAAW games from NCAA API: ${err.message}`);
    }

    console.log(`üìä Total NCAA API games fetched: ${ncaaGames.length} (NCAAM: ${ncaaGames.filter(g => g.league === 'USA: NCAA' && g.sport === 'Basketball').length}, NCAAW: ${ncaaGames.filter(g => g.league === 'USA: NCAA Women').length})`);

    const matchedNcaaGameIds = new Set();
    const ncaaGamesToUpdate = [];
    const snapshot = await gamesRef.where('gameDate', '==', todayStr).get();

    for (const doc of snapshot.docs) {
      const firestoreGame = doc.data();
      const gameLeague = firestoreGame.League || '';
      const gameSport = firestoreGame.Sport || '';

      if (gameSport !== 'Basketball') continue;
      if (gameLeague !== 'USA: NCAA' && gameLeague !== 'USA: NCAA Women') continue;

      const mappedFlashLiveHome = mapFlashLiveToNCAA(firestoreGame['Home Team'], gameLeague);
      const mappedFlashLiveAway = mapFlashLiveToNCAA(firestoreGame['Away Team'], gameLeague);

      const ncaaGame = await (async () => {
        const leagueKey = gameLeague === 'USA: NCAA' ? 'NCAAM' : 'NCAAW';
        
        for (const ng of ncaaGames) {
          if (gameLeague === 'USA: NCAA' && ng.league !== 'USA: NCAA') continue;
          if (gameLeague === 'USA: NCAA Women' && ng.league !== 'USA: NCAA Women') continue;

          const ncaaHome = ng.homeTeam;
          const ncaaAway = ng.awayTeam;

          // Try exact match first
          const homeMatchExact = mappedFlashLiveHome === ncaaHome;
          const awayMatchExact = mappedFlashLiveAway === ncaaAway;
          if (homeMatchExact && awayMatchExact) return ng;

          // Try normalized match
          const homeMatchNormalized = normalizeTeamNameForNCAA(mappedFlashLiveHome) === normalizeTeamNameForNCAA(ncaaHome);
          const awayMatchNormalized = normalizeTeamNameForNCAA(mappedFlashLiveAway) === normalizeTeamNameForNCAA(ncaaAway);
          if (homeMatchNormalized && awayMatchNormalized) return ng;
        }
        
        return null;
      })();

      if (!ncaaGame) continue;

      matchedNcaaGameIds.add(ncaaGame.ncaaGameId);

      const updatedGame = {
        ...firestoreGame,
        'Home Score': ncaaGame.homeScore,
        'Away Score': ncaaGame.awayScore,
        'Match Status': ncaaGame.matchStatus,
        'Status': ncaaGame.status,
        'Stage': ncaaGame.stage,
        'StageType': ncaaGame.stageType,
        'GameTime': ncaaGame.gameTime,
        'Current Period': ncaaGame.currentPeriod || '',
        'Last Updated': new Date().toISOString()
      };
      // Preserve user-set POSTPONED/PPD/CANCELED: do not overwrite with API status
      const existingStatus = (firestoreGame['Match Status'] || '').toUpperCase().trim();
      if (existingStatus === 'POSTPONED' || existingStatus === 'PPD' || existingStatus === 'CANCELED') {
        continue; // Skip update so PPD/postponed stays
      }

      if (ncaaGame.startTimeMillis) {
        updatedGame['Start Time'] = admin.firestore.Timestamp.fromMillis(ncaaGame.startTimeMillis);
        updatedGame['gameDate'] = DateTime.fromMillis(ncaaGame.startTimeMillis).setZone('America/New_York').toISODate();
      } else if (ncaaGame.gameDateIso) {
        updatedGame['gameDate'] = ncaaGame.gameDateIso;
      }

      ncaaGamesToUpdate.push({ docId: doc.id, game: updatedGame });
    }

    if (ncaaGamesToUpdate.length > 0) {
      const batch = db.batch();
      for (const { docId, game } of ncaaGamesToUpdate) {
        batch.set(gamesRef.doc(docId), game, { merge: true });
      }
      await batch.commit();
      totalGamesUpdated += ncaaGamesToUpdate.length;
      console.log(`‚úÖ Successfully updated ${ncaaGamesToUpdate.length} NCAA games via NCAA API fallback.`);
    } else {
      console.log('‚ö†Ô∏è No existing NCAA game documents matched for update.');
    }

    const unmatchedNcaaGames = ncaaGames.filter(ng => !matchedNcaaGameIds.has(ng.ncaaGameId));
    if (unmatchedNcaaGames.length > 0) {
      const newDocs = unmatchedNcaaGames
        .filter(ng => ng.ncaaGameId)
        .map(ng => {
          const gameId = `NCAA-${ng.ncaaGameId}`;
          const startTimeTimestamp = ng.startTimeMillis
            ? admin.firestore.Timestamp.fromMillis(ng.startTimeMillis)
            : admin.firestore.Timestamp.now();
          const gameDateValue = ng.startTimeMillis
            ? DateTime.fromMillis(ng.startTimeMillis).setZone('America/New_York').toISODate()
            : (ng.gameDateIso || todayStr);

          return {
            'Sport': ng.sport,
            'Game ID': gameId,
            'League': ng.league,
            'Matchup': `${ng.awayTeam} vs ${ng.homeTeam}`,
            'Start Time': startTimeTimestamp,
            'Home Team': ng.homeTeam,
            'Away Team': ng.awayTeam,
            'Home Score': ng.homeScore,
            'Away Score': ng.awayScore,
            'Status': ng.status,
            'Match Status': ng.matchStatus,
            'Stage': ng.stage,
            'GameTime': ng.gameTime || '',
            'StageType': ng.stageType,
            'Current Period': ng.currentPeriod || '',
            'Last Updated': new Date().toISOString(),
            'gameDate': gameDateValue
          };
        });

      if (newDocs.length > 0) {
        await writeGamesToFirestore(newDocs);
        totalGamesUpdated += newDocs.length;
        console.log(`‚úÖ Inserted ${newDocs.length} NCAA games directly (no FlashLive counterpart).`);
      } else {
        console.log('‚ö†Ô∏è NCAA API returned games without IDs; skipping insert.');
      }
    } else {
      console.log('‚úÖ All NCAA API games matched existing Firestore entries.');
    }
  } catch (ncaaErr) {
    console.error('--- NCAA API polling FAILED ---', ncaaErr);
  }
} else {
  console.log('Skipping NCAA API polling for NCAAM/NCAAW (disabled).');
}


 if (res) res.status(200).send(`Polling complete. Updated ${totalGamesUpdated} games.`);
} catch (err) {
 console.error('--- pollLiveGamesHandler FAILED ---', err);
 if (res) res.status(500).send('Polling failed.');
}
};






const refreshAllHandler = async (req, res) => {
  // Return immediately to avoid Cloud Scheduler timeout
  // Tasks will continue running in background
  res.status(202).send('refreshAll started: importing featured games, running stats scrapers, running standings scrapers. (Games are handled by pollESPNLiveData)');
  
  // Run tasks asynchronously (don't await - let them run in background)
  (async () => {
    try {
      console.log('--- /refreshAll triggered ---');
      // NOTE: Games are now handled by pollESPNLiveData endpoint
      // This function only handles stats and standings
      // NOTE: Featured games are now managed via perspectives-admin.html, not Google Sheets
      
      // Run stats scrapers
      console.log('--- Running stats scrapers ---');
      const { runAllStatsScrapers } = await import('./run-all-stats-scrapers.js');
      await runAllStatsScrapers();
      
      // Run standings scrapers
      console.log('--- Running standings scrapers ---');
      const { runScrapers } = require('./scrape-all-standings.cjs');
      await runScrapers();
      
      console.log('‚úÖ refreshAll complete: ran stats scrapers, ran standings scrapers.');
    } catch (err) {
      console.error('--- /refreshAll FAILED ---', err);
    }
  })();
};




// =================================================================
// NEW FUNCTIONALITY ADDED HERE
// =================================================================
const FUTURE_GAMES_SHEET_NAME = "Future Games";




/**
* Checks if a sheet with a specific title exists and creates it if it doesn't.
* Returns the title of the sheet that was found or created.
* @param {string} spreadsheetId The ID of the Google Spreadsheet.
* @param {string} sheetName The title of the sheet to find or create.
* @returns {string} The title of the found or created sheet.
*/
async function createOrGetSheet(spreadsheetId, sheetName) {
try {
 // Check if the sheet already exists
 const response = await rateLimitedSheetRequest(() =>
   sheets.spreadsheets.get({
     spreadsheetId,
     fields: 'sheets.properties.title'
   })
 );
 const sheetsList = response.data.sheets;
 const existingSheet = sheetsList.find(s => s.properties.title === sheetName);




 if (existingSheet) {
   console.log(`Sheet "${sheetName}" already exists. Using existing tab.`);
   return sheetName;
 }




 // If the sheet doesn't exist, create it
 console.log(`Sheet "${sheetName}" not found. Creating a new tab...`);
 const request = {
   spreadsheetId,
   resource: {
     requests: [{
       addSheet: {
         properties: {
           title: sheetName
         }
       }
     }]
   }
 };
 await rateLimitedSheetRequest(() => sheets.spreadsheets.batchUpdate(request));
 console.log(`Successfully created new sheet with title "${sheetName}".`);
 return sheetName;
} catch (err) {
 console.error(`Error in createOrGetSheet: ${err.message}`);
 throw err;
}
}




async function fetchUpcomingGamesHandler(req, res) {
try {
 console.log('--- fetchUpcomingGamesHandler started for the next 7 days. ---');




 await authenticateGoogleSheets();
 await createOrGetSheet(SPREADSHEET_ID, FUTURE_GAMES_SHEET_NAME);




 const rapidApiHeaders = {
   'X-RapidAPI-Key': RAPIDAPI_KEY,
   'X-RapidAPI-Host': RAPIDAPI_HOST
 };




const allGames = [];
const nowInUTC = DateTime.now().setZone('utc');




 // Loop for the next 7 days (including today)
 for (let i = 0; i < 7; i++) {
   const dateToFetch = nowInMountain.plus({ days: i }).toISODate();
   console.log(`Fetching games for date: ${dateToFetch}`);




   for (const league of leaguesToFetch) {
     const url = `https://${RAPIDAPI_HOST}/v1/events/list?sport_slug=${league.slug}&date=${dateToFetch}&locale=en_INT&sport_id=${league.id}&timezone=-4&indent_days=0`;




     try {
       const data = await fetchRapidApiData(url, rapidApiHeaders);
       const tournaments = data.DATA || [];




       for (const tour of tournaments) {
         // Check if the tournament name matches the desired league.
         // Some leagues (like Europa League) might not match exactly, so check for inclusion instead.
         if (tour.NAME.includes(league.leagueName) || (league.leagueName.includes(tour.NAME))) {
           const events = tour.EVENTS || [];
           for (const event of events) {
             // Normalize Match Status like NCAA API does
             const stageTypeNorm = (event.STAGE_TYPE || '').toUpperCase();
             const stageNorm = (event.STAGE || '').toUpperCase();
             const homeScoreNum = Number(event.HOME_SCORE_CURRENT || 0);
             const awayScoreNum = Number(event.AWAY_SCORE_CURRENT || 0);
             const hasClock = event.GAME_TIME && event.GAME_TIME !== '0:00' && event.GAME_TIME !== '0.0';
             
             let matchStatus = 'SCHEDULED';
             if (stageTypeNorm === 'FINAL' || stageNorm === 'FINAL' || stageTypeNorm.includes('FINAL')) {
               matchStatus = 'FINAL';
             } else if (
               stageTypeNorm.includes('LIVE') ||
               stageTypeNorm.includes('IN_PROGRESS') ||
               stageTypeNorm.includes('IN PROGRESS') ||
               stageTypeNorm.includes('OVERTIME') ||
               stageTypeNorm.includes('OT') ||
               stageNorm.includes('2ND HALF') ||
               stageNorm.includes('2ND QUARTER') ||
               hasClock ||
               homeScoreNum > 0 ||
               awayScoreNum > 0
             ) {
               if (!stageTypeNorm.includes('FINAL') && !stageNorm.includes('FINAL')) {
                 matchStatus = 'IN PROGRESS';
               }
             } else if (stageNorm.includes('HALF') || stageTypeNorm.includes('HALF')) {
               matchStatus = 'HALFTIME';
             }
             
             const game = {
               'Date': dateToFetch,
               'Sport': tour.SPORT_NAME || league.slug,
               'Game ID': event.EVENT_ID,
               'League': tour.NAME,
               'Matchup': `${event.HOME_NAME} vs ${event.AWAY_NAME}`,
               'Start Time': event.START_TIME ? new Date(event.START_TIME * 1000).toISOString() : '',
               'Home Team': event.HOME_NAME,
               'Away Team': event.AWAY_NAME,
               'Home Score': event.HOME_SCORE_CURRENT || '',
               'Away Score': event.AWAY_SCORE_CURRENT || '',
               'Status': event.STAGE || '',
               'Match Status': matchStatus,
               'Last Updated': new Date().toISOString()
             };
             allGames.push(game);
           }
         }
       }
     } catch (err) {
       console.error(`Error fetching ${league.leagueName} for ${dateToFetch}: ${err.message}`);
     }
   }
 }




 console.log(`Fetched a total of ${allGames.length} games for the upcoming week.`);




 const sheetRows = allGames.map(g => [
   g.Date, g.Sport, g['Game ID'], g.League, g.Matchup,
   g['Start Time'], g['Home Team'], g['Away Team'],
   g['Home Score'], g['Away Score'], g.Status,
   g['Match Status'], g['Last Updated']
 ]);




 const sheetHeader = [
   'Date', 'Sport', 'Game ID', 'League', 'Matchup',
   'Start Time', 'Home Team', 'Away Team',
   'Home Score', 'Away Score', 'Status',
   'Match Status', 'Last Updated'
 ];




console.log(`Clearing old data from Google Sheets "${FUTURE_GAMES_SHEET_NAME}" tab...`);
await clearGoogleSheet(SPREADSHEET_ID, FUTURE_GAMES_SHEET_NAME);

console.log(`Attempting to write to Google Sheets on the "${FUTURE_GAMES_SHEET_NAME}" tab...`);
await rateLimitedSheetRequest(() =>
  sheets.spreadsheets.values.update({
    spreadsheetId: SPREADSHEET_ID,
    range: `${FUTURE_GAMES_SHEET_NAME}!A1`,
    valueInputOption: 'RAW',
    requestBody: {
      values: [sheetHeader, ...sheetRows]
    }
  })
);
console.log(`Successfully wrote ${sheetRows.length} rows to Google Sheet.`);




 if (res) {
   res.status(200).send(`Wrote ${sheetRows.length} rows to Google Sheet for the upcoming week.`);
 }
} catch (err) {
 console.error('--- fetchUpcomingGamesHandler FAILED ---', err);
 if (res) res.status(500).send('Weekly scrape and write failed.');
}
}




// =================================================================
// EXPRESS APP
// =================================================================
const app = express();

// CORS middleware for Perspectives admin UI
app.use((req, res, next) => {
  res.header('Access-Control-Allow-Origin', '*');
  res.header('Access-Control-Allow-Methods', 'GET, POST, PUT, DELETE, OPTIONS');
  res.header('Access-Control-Allow-Headers', 'Content-Type, Authorization');
  if (req.method === 'OPTIONS') {
    return res.sendStatus(200);
  }
  next();
});

app.use(express.json());




app.post('/initialScrapeAndStartPolling', initialScrapeAndStartPollingHandler);
// TEMPORARILY DISABLED: Polling endpoints commented out to reduce API usage
// app.get('/pollLiveGames', pollLiveGamesHandler);
// app.post('/pollLiveGames', pollLiveGamesHandler);
app.post('/refreshAll', refreshAllHandler);

// ESPN Live Data Polling Handler
// Writes to sportsGames collection (ESPN/NCAA API games + Google Sheets games for other leagues)
// Works like initialScrapeAndStartPolling: cleans yesterday's games, populates today's, then polls for updates
const pollESPNLiveDataHandler = async (req, res) => {
  const executionId = `poll-${Date.now()}`;
  const userAgent = req.headers?.['user-agent'] || 'unknown';
  const isScheduler = userAgent.includes('Google-Cloud-Scheduler');
  
  try {
    console.log(`\n${'='.repeat(70)}`);
    console.log(`üöÄ [${executionId}] /pollESPNLiveData started`);
    console.log(`‚è∞ Time: ${new Date().toISOString()}`);
    console.log(`üì° Source: ${isScheduler ? 'Cloud Scheduler' : 'Manual'}`);
    console.log(`üîó Path: ${req.url || req.path || '/'}`);
    console.log(`üåê User-Agent: ${userAgent}`);
    console.log('='.repeat(70));
    
    const db = initializeFirebase();
    // Write to sportsGames collection (contains ESPN/NCAA API games + Google Sheets games for other leagues)
    const gamesRef = db.collection(`artifacts/flashlive-daily-scraper/public/data/sportsGames`);
    // Get today's date in Mountain Time (CST)
    // Only fetch games for today (not next 7 days) to reduce API calls and costs
    const nowInMountain = DateTime.now().setZone('America/Denver');
    const todayStr = nowInMountain.toISODate();
    const tomorrowStr = nowInMountain.plus({ days: 1 }).toISODate();
    // FIX: Use Eastern Time for yesterdayStr to match moveYesterdayGamesToScores() and generateYesterdayGamesJSON()
    // Games are stored with gameDate in Eastern Time format, so we need to match that
    const nowInEastern = DateTime.now().setZone('America/New_York');
    const yesterdayStr = nowInEastern.minus({ days: 1 }).toISODate();
    const twoDaysAgoStr = nowInMountain.minus({ days: 2 }).toISODate();
    
    // OPTIMIZATION: Declare pre-fetch snapshots at function scope (for polling runs to reuse later)
    let preFetchLiveGamesSnapshot = null;
    let preFetchYesterdayFinalSnapshot = null;
    let preFetchUpcomingGamesSnapshot = null;
    
    // Generate array with only today's date (not next 7 days)
    const datesToFetch = [{
      isoDate: todayStr,
      espnDate: nowInMountain.toFormat('yyyyMMdd') // YYYYMMDD format for ESPN API
    }];
    
    // Calculate the date range we want to keep: yesterday + today (2 days total)
    const datesToKeep = [yesterdayStr, todayStr];
    
    console.log(`[ESPN Live Data] Fetching games for today only (${todayStr}) - Mountain Time`);
    console.log(`[ESPN Live Data] Keeping games for: ${datesToKeep.join(', ')} (yesterday's FINAL + today)`);
    
    // Step 1: Clean up yesterday's games (like initialScrapeAndStartPolling does)
    // Check if we have any games for today - if not, this is the morning run and we should clean yesterday
    // Also allow forcing morning mode via query parameter
    const forceMorning = req.query?.morning === 'true' || req.query?.morning === true;
    const todayGamesSnapshot = await gamesRef.where('gameDate', '==', todayStr).limit(1).get();
    const isMorningRun = forceMorning || todayGamesSnapshot.empty;
    
    if (isMorningRun) {
      console.log('[ESPN Live Data] Morning run detected - cleaning up games older than 2 days ago...');
      console.log('[ESPN Live Data] Note: Yesterday\'s games will be moved to yesterdayScores at the end of morning run');
      
      // Get all games from sportsGames to clean up
      const allGamesSnapshot = await gamesRef.get();
      let yesterdayGamesKept = 0;
      let oldGamesDeleted = 0;
      
      let deleteBatch = db.batch();
      let batchCount = 0;
      const BATCH_SIZE = 500;
      
      for (const doc of allGamesSnapshot.docs) {
        const data = doc.data();
        const gameDate = data.gameDate;
        
        // Keep: yesterday's games (will be moved to yesterdayScores by morning run handler)
        if (gameDate === yesterdayStr) {
          yesterdayGamesKept++;
          continue; // Keep this game (will be moved later)
        }
        
        // Delete: games from 2 days ago and older (not in our keep range)
        if (gameDate && gameDate < yesterdayStr) {
          deleteBatch.delete(doc.ref);
          batchCount++;
          oldGamesDeleted++;
          
          if (batchCount >= BATCH_SIZE) {
            await deleteBatch.commit();
            batchCount = 0;
            deleteBatch = db.batch();
          }
        }
      }
      
      // Commit remaining deletes
      if (batchCount > 0) {
        await deleteBatch.commit();
      }
      
      console.log(`‚úÖ Cleanup complete: Kept ${yesterdayGamesKept} yesterday's games (will be moved to yesterdayScores), deleted ${oldGamesDeleted} games from 2+ days ago`);
    } else {
      console.log('[ESPN Live Data] Polling run - updating existing games (no cleanup needed)');
    }

    // For polling runs, we'll optimize to only fetch leagues/dates that have live games
    // Morning runs always fetch all games (to discover when games start)
    
    // Mapping from ESPN league names to display names (matching LEAGUE_DISPLAY_NAME_MAP_FULL from importGamesFromSheets)
    const ESPN_LEAGUE_DISPLAY_NAME_MAP = {
      'NFL': 'USA: NFL',
      'NCAAF': 'USA: NCAA',
      'NBA': 'USA: NBA',
      'WNBA': 'USA: WNBA',
      'MLB': 'USA: MLB',
      'NHL': 'USA: NHL',
      'MLS': 'USA: MLS',
      'NWSL': 'USA: NWSL Women',
      'Premier League': 'England: Premier League',
      'La Liga': 'Spain: LaLiga',
      'Bundesliga': 'Germany: Bundesliga',
      'Serie A': 'Italy: Serie A',
      'Ligue 1': 'France: Ligue 1',
      'Eredivisie': 'Netherlands: Eredivisie',
      'Liga Portugal': 'Portugal: Liga Portugal',
      'Belgian Pro League': 'Belgium: Jupiler Pro League',
      'Scottish Premiership': 'Scotland: Premiership',
      'Brasileirao': 'Brazil: Serie A Betano',
      'EFL Championship': 'England: Championship',
      'EFL League One': 'England: League One',
      'EFL League Two': 'England: League Two',
      'National League': 'England: National League',
      'LaLiga 2': 'Spain: LaLiga 2',
      '2. Bundesliga': 'Germany: 2. Bundesliga',
      'Serie B': 'Italy: Serie B',
      'Ligue 2': 'Ligue 2',
      'UEFA Champions League': 'UEFA Champions League',
      'AFC Champions League': 'Asia: AFC Elite',
      'UEFA Europa League': 'Europa League',
      'UEFA Conference League': 'Conference League',
      'UEFA Nations League': 'UEFA Nations League',
      'CAF Nations League': 'CAF Nations League',
      'FA Cup': 'England: FA Cup',
      'Carabao Cup': 'England: EFL Cup',
      'Copa del Rey': 'Spain: Copa del Rey',
      'Coppa Italia': 'Italy: Coppa Italia',
      'Italian Super Cup': 'Italian Super Cup',
      'DFB-Pokal': 'Germany: DFB Pokal',
      'Coupe de France': 'France: Coupe de France',
      'Trofeo de Campeones': 'Trofeo de Campeones',
      'Ta√ßa de Portugal': 'Ta√ßa de Portugal',
      'Saudi Pro League': 'Saudi Arabia: Saudi Professional League',
      'Liga MX': 'Mexico: Liga MX',
      'Japanese J.League': 'Japan: J.League',
      'Chinese Super League': 'China: Super League',
      'Australian A-League Men': 'Australia: A-League Men',
      'Turkish Super Lig': 'Turkey: Super Lig',
      'Greek Super League': 'Greece: Super League',
      'Russian Premier League': 'Russia: Premier League',
      'Gambrinus Liga': 'Czech Republic: Gambrinus Liga',
      'Austrian Bundesliga': 'Austria: Bundesliga',
      'Swiss Super League': 'Switzerland: Super League',
      'Danish Superliga': 'Denmark: Superliga',
      'Swedish Allsvenskan': 'Sweden: Allsvenskan',
      'Norwegian Eliteserien': 'Norway: Eliteserien',
      'Finnish Veikkausliga': 'Finland: Veikkausliga',
      'ATP': 'ATP',
      'WTA': 'WTA',
      'PGA Tour': 'PGA Tour',
      'LPGA Tour': 'LPGA Tour',
      'PGA Champions': 'PGA Champions',
      'LIV Golf': 'LIV Golf',
      'DP World Tour': 'DP World Tour',
      'Korn Ferry': 'Korn Ferry',
      'Formula 1': 'Formula 1',
      'NASCAR Truck Series': 'NASCAR Truck Series',
      'UFC': 'UFC',
      'Bellator': 'Bellator',
      'Boxing': 'Boxing',
      'NCAA Women\'s Volleyball': 'NCAA Women\'s Volleyball',
      'NCAAM': 'USA: NCAA', // From NCAA API
      'NCAAW': 'USA: NCAA Women', // From NCAA API
      'USWNT': 'USWNT', // US Women's National Team
      'USMNT': 'USMNT', // US Men's National Team
      'CONCACAF Champions Cup': 'North & Central America: Concacaf Champions Cup'
    };
    
    // Step 2: Fetch and populate today's games
    // ESPN API leagues configuration - ALL available leagues (excluding NCAAM and NCAAW)
    const ESPN_LEAGUES = [
      // American Football
      { sport: 'football', league: 'nfl', leagueName: 'NFL' },
      { sport: 'football', league: 'college-football', leagueName: 'NCAAF' },
      
      // Basketball
      { sport: 'basketball', league: 'nba', leagueName: 'NBA' },
      { sport: 'basketball', league: 'wnba', leagueName: 'WNBA' },
      // Note: mens-college-basketball and womens-college-basketball removed - using NCAA API instead
      
      // Baseball
      { sport: 'baseball', league: 'mlb', leagueName: 'MLB' },
      
      // Hockey
      { sport: 'hockey', league: 'nhl', leagueName: 'NHL' },
      
      // Soccer - Major Leagues
      { sport: 'soccer', league: 'usa.1', leagueName: 'MLS' },
      { sport: 'soccer', league: 'usa.nwsl', leagueName: 'NWSL' },
      { sport: 'soccer', league: 'eng.1', leagueName: 'Premier League' },
      { sport: 'soccer', league: 'esp.1', leagueName: 'La Liga' },
      { sport: 'soccer', league: 'ger.1', leagueName: 'Bundesliga' },
      { sport: 'soccer', league: 'ita.1', leagueName: 'Serie A' },
      { sport: 'soccer', league: 'fra.1', leagueName: 'Ligue 1' },
      // { sport: 'soccer', league: 'mex.1', leagueName: 'Liga MX' }, // Out of season
      { sport: 'soccer', league: 'ned.1', leagueName: 'Eredivisie' },
      { sport: 'soccer', league: 'por.1', leagueName: 'Liga Portugal' },
      { sport: 'soccer', league: 'bel.1', leagueName: 'Belgian Pro League' },
      { sport: 'soccer', league: 'sco.1', leagueName: 'Scottish Premiership' },
      { sport: 'soccer', league: 'arg.1', leagueName: 'Argentine Primera' },
      { sport: 'soccer', league: 'bra.1', leagueName: 'Brasileirao' },
      { sport: 'soccer', league: 'eng.2', leagueName: 'EFL Championship' },
      // { sport: 'soccer', league: 'eng.3', leagueName: 'EFL League One' },
      // { sport: 'soccer', league: 'eng.4', leagueName: 'EFL League Two' },
      // { sport: 'soccer', league: 'eng.5', leagueName: 'National League' },
      //  { sport: 'soccer', league: 'esp.2', leagueName: 'LaLiga 2' },
      // { sport: 'soccer', league: 'ger.2', leagueName: '2. Bundesliga' },
      // { sport: 'soccer', league: 'ita.2', leagueName: 'Serie B' },
      //{ sport: 'soccer', league: 'fra.2', leagueName: 'Ligue 2' },
      // { sport: 'soccer', league: 'mex.2', leagueName: 'Liga MX Expansi√≥n' }, // Out of season
      
      // Soccer - Additional Leagues
      { sport: 'soccer', league: 'ksa.1', leagueName: 'Saudi Pro League' },
      { sport: 'soccer', league: 'mex.1', leagueName: 'Liga MX' },
      // { sport: 'soccer', league: 'jpn.1', leagueName: 'Japanese J.League' },
      // { sport: 'soccer', league: 'chn.1', leagueName: 'Chinese Super League' },
      // { sport: 'soccer', league: 'aus.1', leagueName: 'Australian A-League Men' },
      { sport: 'soccer', league: 'tur.1', leagueName: 'Turkish Super Lig' },
      // { sport: 'soccer', league: 'gre.1', leagueName: 'Greek Super League' },
      // { sport: 'soccer', league: 'rus.1', leagueName: 'Russian Premier League' },
      // { sport: 'soccer', league: 'cze.1', leagueName: 'Gambrinus Liga' },
      // { sport: 'soccer', league: 'aut.1', leagueName: 'Austrian Bundesliga' },
      // { sport: 'soccer', league: 'sui.1', leagueName: 'Swiss Super League' },
      // { sport: 'soccer', league: 'den.1', leagueName: 'Danish Superliga' },
      //{ sport: 'soccer', league: 'swe.1', leagueName: 'Swedish Allsvenskan' },
      //{ sport: 'soccer', league: 'nor.1', leagueName: 'Norwegian Eliteserien' },
      //{ sport: 'soccer', league: 'fin.1', leagueName: 'Finnish Veikkausliga' },
      
      // Soccer - UEFA Competitions
      { sport: 'soccer', league: 'uefa.champions', leagueName: 'UEFA Champions League' },
      { sport: 'soccer', league: 'uefa.europa', leagueName: 'UEFA Europa League' },
      { sport: 'soccer', league: 'uefa.europa.conf', leagueName: 'UEFA Conference League' },
      { sport: 'soccer', league: 'uefa.nations', leagueName: 'UEFA Nations League' },
      { sport: 'soccer', league: 'uefa.euroq', leagueName: 'UEFA Euro Qualifiers' },
      { sport: 'soccer', league: 'uefa.wchampions', leagueName: 'UEFA Women\'s Champions League' },
      
      // Soccer - CAF Competitions
      { sport: 'soccer', league: 'caf.nations', leagueName: 'CAF Nations League' },
      { sport: 'soccer', league: 'caf.nations_qual', leagueName: 'CAF Nations League Qualifiers' },
      
      // Soccer - CONMEBOL Competitions
      { sport: 'soccer', league: 'conmebol.libertadores', leagueName: 'Copa Libertadores' },
      
      // Soccer - AFC Competitions
      { sport: 'soccer', league: 'afc.asian.cup', leagueName: 'AFC Asian Cup' },
      { sport: 'soccer', league: 'afc.champions', leagueName: 'AFC Champions League' },
      // { sport: 'soccer', league: 'afc.cupq', leagueName: 'AFC Cup Qualifiers' },
      
      // Soccer - CONCACAF Competitions
      { sport: 'soccer', league: 'concacaf.nations.league', leagueName: 'CONCACAF Nations League' },
      { sport: 'soccer', league: 'fifa.worldq.concacaf', leagueName: 'FIFA World Cup Qualifiers - CONCACAF' },
      { sport: 'soccer', league: 'concacaf.champions', leagueName: 'CONCACAF Champions Cup' },
      
      // Soccer - Women's Leagues
      { sport: 'soccer', league: 'eng.w.1', leagueName: 'Women\'s Super League' },
      
      // Soccer - National Teams
      { sport: 'soccer', league: 'usa', leagueName: 'USMNT' },
      { sport: 'soccer', league: 'usa.w', leagueName: 'USWNT' },
      
      // Soccer - Other Competitions
      // { sport: 'soccer', league: 'fifa.world', leagueName: 'FIFA World Cup' }, // Out of season
      // { sport: 'soccer', league: 'concacaf.gold', leagueName: 'Gold Cup' }, // Out of season
      // { sport: 'soccer', league: 'usa.open', leagueName: 'U.S. Open Cup' }, // Out of season
      { sport: 'soccer', league: 'eng.fa', leagueName: 'FA Cup' },
      { sport: 'soccer', league: 'eng.league_cup', leagueName: 'Carabao Cup' },
      { sport: 'soccer', league: 'esp.copa_del_rey', leagueName: 'Copa del Rey' },
      { sport: 'soccer', league: 'ita.coppa_italia', leagueName: 'Coppa Italia' },
      { sport: 'soccer', league: 'ita.super_cup', leagueName: 'Italian Super Cup' },
      { sport: 'soccer', league: 'ger.dfb_pokal', leagueName: 'DFB-Pokal' },
      { sport: 'soccer', league: 'fra.coupe_de_france', leagueName: 'Coupe de France' },
      { sport: 'soccer', league: 'por.taca.portugal', leagueName: 'Ta√ßa de Portugal' },
      { sport: 'soccer', league: 'arg.trofeo_de_la_campeones', leagueName: 'Trofeo de Campeones' },
      
      // Tennis
      //  { sport: 'tennis', league: 'atp', leagueName: 'ATP' },
      // { sport: 'tennis', league: 'wta', leagueName: 'WTA' },
      
      // Golf
      // { sport: 'golf', league: 'pga', leagueName: 'PGA Tour' },
      // { sport: 'golf', league: 'lpga', leagueName: 'LPGA Tour' },
      // { sport: 'golf', league: 'champions-tour', leagueName: 'PGA Champions' },
      // { sport: 'golf', league: 'liv', leagueName: 'LIV Golf' },
      // { sport: 'golf', league: 'eur', leagueName: 'DP World Tour' },
      // { sport: 'golf', league: 'ntw', leagueName: 'Korn Ferry' },
      
      // Racing
      { sport: 'racing', league: 'f1', leagueName: 'Formula 1' },
      { sport: 'racing', league: 'nascar-cup', leagueName: 'NASCAR Cup Series' },
      { sport: 'racing', league: 'nascar-xfinity', leagueName: 'NASCAR Xfinity Series' },
      { sport: 'racing', league: 'nascar-truck', leagueName: 'NASCAR Truck Series' },
      { sport: 'racing', league: 'indycar', leagueName: 'IndyCar' },
      
      // MMA
      { sport: 'mma', league: 'ufc', leagueName: 'UFC' },
      { sport: 'mma', league: 'bellator', leagueName: 'Bellator' },
      
      // Boxing
      // { sport: 'boxing', league: 'boxing', leagueName: 'Boxing' },
      
      // Volleyball
      { sport: 'volleyball', league: 'womens-college-volleyball', leagueName: 'NCAA Women\'s Volleyball' }
    ];
    
    const allGames = [];
    let totalFetched = 0;
    // Track unique games to prevent duplicates (key: league|homeTeam|awayTeam|date)
    const uniqueGames = new Set();
    
    // Helper function to create unique game key
    const getGameKey = (league, homeTeam, awayTeam, date) => {
      return `${league}|${(homeTeam || '').toLowerCase().trim()}|${(awayTeam || '').toLowerCase().trim()}|${date}`;
    };
    
    // Generate deterministic Game ID from game data (for fallback when API doesn't provide stable ID)
    // NOTE: Time is NOT included in Game ID - same game should have same ID regardless of when it's fetched
    const generateDeterministicGameId = (source, league, homeTeam, awayTeam, date) => {
      const normalizedHome = (homeTeam || '').toLowerCase().trim().replace(/[^a-z0-9]/g, '');
      const normalizedAway = (awayTeam || '').toLowerCase().trim().replace(/[^a-z0-9]/g, '');
      const normalizedLeague = (league || '').toLowerCase().trim().replace(/[^a-z0-9]/g, '');
      const dateStr = date.replace(/-/g, '');
      return `${source}-${normalizedLeague}-${normalizedAway}-${normalizedHome}-${dateStr}`;
    };
    
    // Rate limiter for ESPN API (conservative: 2 requests per second = 120/minute)
    let lastESPNRequestTime = 0;
    const MIN_TIME_BETWEEN_ESPN_REQUESTS = 500; // 500ms = 2 requests/second
    
    // Helper function to extract eventId from Game ID
    // Format: "espn-nba-401810420" ‚Üí "401810420"
    // Format: "espn-soccer-eng.1-401789012" ‚Üí "401789012"
    const extractEventIdFromGameId = (gameId) => {
      if (!gameId || typeof gameId !== 'string') return null;
      // Match: espn-{league}-{eventId}
      // League can contain dots (e.g., "eng.1"), so we need to match everything after the second dash
      const match = gameId.match(/^espn-[^-]+-(.+)$/);
      if (!match) return null;
      // The eventId is everything after the second dash
      // For "espn-nba-401810420" ‚Üí "401810420" ‚úì
      // For "espn-soccer-eng.1-401789012" ‚Üí "eng.1-401789012" (need to extract just the number)
      // Actually, ESPN Game IDs should be numeric, so extract the last numeric part
      const parts = match[1].split('-');
      // If there are multiple parts, the eventId is the last one (numeric)
      // Otherwise, the whole thing is the eventId
      const eventId = parts.length > 1 ? parts[parts.length - 1] : match[1];
      // Verify it's numeric (ESPN eventIds are always numeric)
      return /^\d+$/.test(eventId) ? eventId : null;
    };
    
    // Helper function to extract sport and league from Game ID
    // Format: "espn-nba-401810420" ‚Üí { sport: "basketball", league: "nba" }
    const extractSportAndLeagueFromGameId = (gameId, gameData) => {
      if (!gameId || typeof gameId !== 'string') return null;
      const match = gameId.match(/^espn-([^-]+)-(.+)$/);
      if (!match) return null;
      
      const leagueSlug = match[1];
      // Find the league config that matches this slug
      const leagueConfig = ESPN_LEAGUES.find(l => l.league === leagueSlug);
      if (leagueConfig) {
        return { sport: leagueConfig.sport, league: leagueConfig.league, leagueName: leagueConfig.leagueName };
      }
      
      // Fallback: try to infer from League field in gameData
      if (gameData && gameData['League']) {
        const leagueName = gameData['League'];
        // Try to find matching league config by leagueName
        const matchedLeague = ESPN_LEAGUES.find(l => l.leagueName === leagueName || ESPN_LEAGUE_DISPLAY_NAME_MAP[l.leagueName] === leagueName);
        if (matchedLeague) {
          return { sport: matchedLeague.sport, league: matchedLeague.league, leagueName: matchedLeague.leagueName };
        }
      }
      
      return null;
    };
    
    // Determine which leagues/dates to fetch based on run type:
    // - Morning run: fetch all 7 days for all leagues (to populate upcoming games)
    // - Polling run: only fetch leagues/dates that have live games in Firestore
    let leaguesAndDatesToFetch = [];
    let gamesToPollForProcessing = []; // Initialize for both morning and polling runs
    let ncaaGamesToPollForProcessing = []; // Initialize for NCAA games
    
    // Note: preFetch variables are already declared at function scope above
    
    if (isMorningRun) {
      // Morning run: fetch only today for all leagues (changed from 7 days to reduce costs)
      leaguesAndDatesToFetch = datesToFetch.map(dateInfo => ({
        ...dateInfo,
        leagues: ESPN_LEAGUES // All leagues for today only
      }));
    } else {
      // Polling run: Check for live games BEFORE fetching from API
      // OPTIMIZATION: Only fetch from API if there are live games or games scheduled to start soon
      console.log('[ESPN Live Data] Polling run - checking for live games before API fetch...');
      
      // First check: Are there any games for today at all? (quick check)
      const todayGamesCheck = await gamesRef.where('gameDate', '==', todayStr).limit(1).get();
      if (todayGamesCheck.empty) {
        console.log('[ESPN Live Data] No games for today; skipping fetch.');
        if (res) {
          return res.status(200).json({ success: true, message: 'No games for today; skipped fetch.' });
        }
        return;
      }
      
      // Second check: Are there any live or final games that need updating?
      // Query for games that are IN PROGRESS, LIVE, or FINAL (to update scores)
      const liveGamesQuery = gamesRef
        .where('gameDate', '==', todayStr)
        .where('Match Status', 'in', ['IN PROGRESS', 'LIVE', 'FINAL', 'FINISHED']);
      
      const yesterdayFinalGamesQuery = gamesRef
        .where('gameDate', '==', yesterdayStr)
        .where('Match Status', 'in', ['FINAL', 'FINISHED']);
      
      const [liveGamesSnapshot, yesterdayFinalSnapshot] = await Promise.all([
        liveGamesQuery.get(),
        yesterdayFinalGamesQuery.get()
      ]);
      
      const hasLiveGames = !liveGamesSnapshot.empty || !yesterdayFinalSnapshot.empty;
      const liveGamesCount = liveGamesSnapshot.size + yesterdayFinalSnapshot.size;
      
      // Also check for scheduled games starting within next 2 hours (to catch newly live games)
      const nowTimestamp = admin.firestore.Timestamp.fromMillis(nowInMountain.toMillis());
      const twoHoursFromNow = admin.firestore.Timestamp.fromMillis(nowInMountain.plus({ hours: 2 }).toMillis());
      
      const upcomingGamesQuery = gamesRef
        .where('gameDate', '==', todayStr)
        .where('Match Status', '==', 'SCHEDULED')
        .where('Start Time', '>=', nowTimestamp)
        .where('Start Time', '<=', twoHoursFromNow)
        .limit(1);
      
      const upcomingGamesSnapshot = await upcomingGamesQuery.get();
      const hasUpcomingGames = !upcomingGamesSnapshot.empty;
      
      // If no live games AND no upcoming games within 2 hours, skip API fetch entirely
      if (!hasLiveGames && !hasUpcomingGames) {
        console.log(`[ESPN Live Data] No live games (${liveGamesCount} checked) and no upcoming games within 2 hours; skipping API fetch.`);
        if (res) {
          return res.status(200).json({ 
            success: true, 
            message: `No live games (${liveGamesCount} checked) and no upcoming games within 2 hours; skipped fetch.`,
            liveGamesChecked: liveGamesCount,
            gamesFetched: 0,
            gamesWritten: 0
          });
        }
        return;
      }
      
      console.log(`[ESPN Live Data] Found ${liveGamesCount} live/final game(s) to update${hasUpcomingGames ? ' and upcoming games within 2 hours' : ''} - fetching from API...`);
      
      // OPTIMIZATION: Store the live games snapshots from early exit check to reuse later (avoid redundant queries)
      // We'll use these later instead of querying again (variables declared at top of function)
      preFetchLiveGamesSnapshot = liveGamesSnapshot;
      preFetchYesterdayFinalSnapshot = yesterdayFinalSnapshot;
      preFetchUpcomingGamesSnapshot = upcomingGamesSnapshot;
      
      // OPTIMIZATION: For polling runs, query Firestore for games that need polling
      // Only fetch games where: start time <= now AND status != FINAL
      // Note: nowTimestamp is already declared above (line 3340), reuse it
      
      // Query for games that should be polled (start time has passed, not final)
      // Query only by gameDate to avoid composite index requirement, then filter Start Time in memory
      const gamesToPollQuery = gamesRef
        .where('gameDate', '==', todayStr);
      
      const gamesToPollSnapshot = await gamesToPollQuery.get();
      const gamesToPoll = [];
      
      const ncaaGamesToPoll = []; // Track NCAA games separately (they use scoreboard API, not individual endpoints)
      
      for (const doc of gamesToPollSnapshot.docs) {
        const gameData = doc.data();
        
        // Filter ESPN and NCAA games (skip manual games)
        if (gameData.source !== 'ESPN_LIVE' && gameData.source !== 'NCAA_LIVE') {
          continue;
        }
        
        // Filter by Start Time in memory (start time must have passed)
        const startTime = gameData['Start Time'];
        if (startTime && startTime.toMillis && startTime.toMillis() > nowTimestamp.toMillis()) {
          continue; // Game hasn't started yet, skip
        }
        
        const matchStatus = (gameData['Match Status'] || '').toUpperCase();
        
        // Skip FINAL games (they don't need polling)
        if (matchStatus.includes('FINAL') || matchStatus.includes('FINISHED')) {
          continue;
        }
        
        // Separate ESPN games (can use individual endpoints) from NCAA games (use scoreboard)
        if (gameData.source === 'ESPN_LIVE') {
          gamesToPoll.push({
            docId: doc.id,
            gameId: gameData['Game ID'],
            gameData: gameData
          });
        } else if (gameData.source === 'NCAA_LIVE') {
          // NCAA games use scoreboard API, but we can optimize by:
          // 1. Only fetching scoreboards for dates that have games to poll
          // 2. Filtering the response to only process the games we need
          ncaaGamesToPoll.push({
            docId: doc.id,
            gameId: gameData['Game ID'],
            gameData: gameData
          });
        }
      }
      
      // Log NCAA games separately
      if (ncaaGamesToPoll.length > 0) {
        console.log(`[ESPN Live Data] Polling run - found ${ncaaGamesToPoll.length} NCAA games to poll (will fetch only relevant scoreboards)`);
      }
      
      console.log(`[ESPN Live Data] Polling run - found ${gamesToPoll.length} games to poll individually (instead of fetching all ${ESPN_LEAGUES.length} leagues)`);
      
      // Store games to poll for later processing
      // We'll process these individually using summary endpoint instead of fetching all leagues
      // Set a flag to indicate we're using optimized polling
      const useOptimizedPolling = gamesToPoll.length > 0;
      const useOptimizedNCAA = ncaaGamesToPoll.length > 0;
      
      // For backward compatibility, still set leaguesAndDatesToFetch (but won't be used if useOptimizedPolling is true)
      leaguesAndDatesToFetch = [
        {
          isoDate: todayStr,
          espnDate: datesToFetch[0].espnDate,
          leagues: ESPN_LEAGUES // All leagues for today only (fallback)
        }
      ];
      
      // Store games to poll for processing
      gamesToPollForProcessing = useOptimizedPolling ? gamesToPoll : [];
      
      // Store NCAA games to poll for optimized fetching
      // We'll only fetch scoreboards for dates that have games to poll, and filter to only those games
      const ncaaGamesToPollForProcessing = useOptimizedNCAA ? ncaaGamesToPoll : [];
    }
    
    // Fetch rankings once for all NCAA games (NCAAM, NCAAW, NCAAF)
    const ncaamRankings = await fetchNCAARankings('NCAAM');
    const ncaawRankings = await fetchNCAARankings('NCAAW');
    const ncaafRankings = await fetchNCAARankings('NCAAF');
    
    // OPTIMIZED POLLING: Fetch individual games for both ESPN and NCAA
    // ESPN: Use summary endpoint
    // NCAA: Use game endpoint
    if (!isMorningRun && (gamesToPollForProcessing && gamesToPollForProcessing.length > 0 || ncaaGamesToPollForProcessing && ncaaGamesToPollForProcessing.length > 0)) {
      const espnCount = gamesToPollForProcessing ? gamesToPollForProcessing.length : 0;
      const ncaaCount = ncaaGamesToPollForProcessing ? ncaaGamesToPollForProcessing.length : 0;
      console.log(`[ESPN Live Data] Using optimized polling: fetching ${espnCount} ESPN games via summary endpoint and ${ncaaCount} NCAA games via game endpoint`);
      
      // Helper function to get team ranking (needed for parsing)
      const getTeamRanking = (teamName, rankingsMap) => {
        if (!rankingsMap || !teamName) return null;
        const normalized = normalizeTeamNameForRanking(teamName);
        return rankingsMap.get(normalized) || null;
      };
      
      // Helper function to normalize team name for ranking lookup
      const normalizeTeamNameForRanking = (name) => {
        return (name || '').toLowerCase().trim().replace(/[^a-z0-9]/g, '');
      };
      
      for (const { gameId, gameData: existingGameData } of gamesToPollForProcessing) {
        try {
          // Extract eventId and league info from Game ID
          const eventId = extractEventIdFromGameId(gameId);
          if (!eventId) {
            console.warn(`[ESPN Live Data] Could not extract eventId from Game ID: ${gameId}`);
            continue;
          }
          
          const leagueInfo = extractSportAndLeagueFromGameId(gameId, existingGameData);
          if (!leagueInfo) {
            console.warn(`[ESPN Live Data] Could not extract sport/league from Game ID: ${gameId}`);
            continue;
          }
          
          const { sport, league, leagueName } = leagueInfo;
          
          // Rate limiting
          const now = Date.now();
          const timeSinceLastRequest = now - lastESPNRequestTime;
          if (timeSinceLastRequest < MIN_TIME_BETWEEN_ESPN_REQUESTS) {
            const waitTime = MIN_TIME_BETWEEN_ESPN_REQUESTS - timeSinceLastRequest;
            await new Promise(resolve => setTimeout(resolve, waitTime));
          }
          lastESPNRequestTime = Date.now();
          
          // Fetch game summary
          const summaryUrl = `https://site.api.espn.com/apis/site/v2/sports/${sport}/${league}/summary?event=${eventId}`;
          console.log(`[ESPN] Fetching summary for ${leagueName} game ${eventId}...`);
          
          let response;
          let retries = 3;
          let backoffTime = 1000;
          
          while (retries > 0) {
            response = await fetch(summaryUrl, {
              headers: {
                'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36'
              }
            });
            
            if (response.status === 429 || (response.status >= 500 && response.status < 600)) {
              retries--;
              if (retries > 0) {
                console.warn(`[ESPN] ${leagueName} game ${eventId}: HTTP ${response.status} - retrying in ${backoffTime/1000}s...`);
                await new Promise(resolve => setTimeout(resolve, backoffTime));
                backoffTime *= 2;
                continue;
              }
            }
            break;
          }
          
          if (!response.ok) {
            console.warn(`[ESPN] ${leagueName} game ${eventId}: HTTP ${response.status} - skipping`);
            continue;
          }
          
          const summaryData = await response.json();
          
          // Summary endpoint structure: { header: { competitions: [...] } }
          // Create event-like structure to reuse existing parsing logic
          const competitions = summaryData.header?.competitions || [];
          if (competitions.length === 0) {
            console.warn(`[ESPN] ${leagueName} game ${eventId}: No competitions found in summary`);
            continue;
          }
          
          // Create event-like structure for existing parser
          const fakeEvent = {
            id: eventId,
            competitions: competitions,
            groupings: sport === 'tennis' ? [{ competitions: competitions }] : undefined
          };
          
          // Process this event using existing parsing logic (reuse code from lines 3413+)
          // We'll process it inline here to avoid code duplication
          let eventCompetitions = [];
          if (sport === 'tennis' && fakeEvent.groupings && fakeEvent.groupings.length > 0) {
            for (const grouping of fakeEvent.groupings) {
              if (grouping.competitions && Array.isArray(grouping.competitions)) {
                eventCompetitions.push(...grouping.competitions);
              }
            }
          } else {
            eventCompetitions = fakeEvent.competitions || [];
          }
          
          if (eventCompetitions.length === 0) continue;
          
          const firstCompetition = eventCompetitions[0];
          const firstCompetitors = firstCompetition.competitors || [];
          const firstAwayTeam = firstCompetitors.find(c => c.homeAway === 'away');
          const firstHomeTeam = firstCompetitors.find(c => c.homeAway === 'home');
          
          if (!firstAwayTeam || !firstHomeTeam) continue;
          
          const firstHomeTeamName = sport === 'tennis' 
            ? (firstHomeTeam.athlete?.displayName || firstHomeTeam.athlete?.shortName || firstHomeTeam.athlete?.fullName || firstHomeTeam.team?.displayName || '')
            : (firstHomeTeam.team?.displayName || '');
          const firstAwayTeamName = sport === 'tennis'
            ? (firstAwayTeam.athlete?.displayName || firstAwayTeam.athlete?.shortName || firstAwayTeam.athlete?.fullName || firstAwayTeam.team?.displayName || '')
            : (firstAwayTeam.team?.displayName || '');
          
          if (!firstCompetition.date) continue;
          const gameDateForStorage = DateTime
            .fromISO(firstCompetition.date, { zone: 'utc' })
            .setZone('America/New_York')
            .toISODate();
          
          const isoDateMountain = DateTime.fromISO(todayStr, { zone: 'America/Denver' });
          const isoDateEastern = isoDateMountain.setZone('America/New_York').toISODate();
          
          if (gameDateForStorage !== isoDateEastern) {
            console.log(`[ESPN] FILTERED OUT: ${leagueName} - ${firstAwayTeamName} vs ${firstHomeTeamName} - gameDate (ET): ${gameDateForStorage}`);
            continue;
          }
          
          const eventGameKey = getGameKey(leagueName, firstHomeTeamName, firstAwayTeamName, gameDateForStorage);
          if (uniqueGames.has(eventGameKey)) {
            console.log(`[ESPN] Skipping duplicate: ${leagueName} - ${firstAwayTeamName} vs ${firstHomeTeamName}`);
            continue;
          }
          uniqueGames.add(eventGameKey);
          
          // Process competitions to extract game data (simplified version of existing logic)
          const allChannels = new Set();
          let primaryCompetition = null;
          let primaryStatus = null;
          let primaryDisplayTime = '';
          
          for (const competition of eventCompetitions) {
            if (!competition) continue;
            
            const competitors = competition.competitors || [];
            const awayTeam = competitors.find(c => c.homeAway === 'away');
            const homeTeam = competitors.find(c => c.homeAway === 'home');
            
            if (!awayTeam || !homeTeam) continue;
            
            const status = competition.status || {};
            const gameDate = competition.date ? new Date(competition.date) : new Date();
            
            const broadcasts = competition.broadcasts?.[0]?.names || [];
            if (broadcasts.length > 0) {
              broadcasts.forEach(broadcastName => {
                if (broadcastName && broadcastName.trim()) {
                  allChannels.add(broadcastName.trim());
                }
              });
            }
            
            if (!primaryCompetition || (status.type?.state === 'in' && primaryStatus?.type?.state !== 'in')) {
              primaryCompetition = competition;
              primaryStatus = status;
              
              const gameDateUTC = DateTime.fromJSDate(gameDate, { zone: 'utc' });
              const gameDateMountain = gameDateUTC.setZone('America/Denver');
              
              let matchStatus = 'SCHEDULED';
              if (status.type?.state === 'in') matchStatus = 'IN PROGRESS';
              else if (status.type?.state === 'post') matchStatus = 'FINAL';
              
              const period = status.period || '';
              let displayClock = status.displayClock || '';
              
              if (sport === 'football' && (leagueName === 'NFL' || leagueName === 'NCAAF')) {
                if (status.clock !== undefined && status.clock !== null) {
                  const clockSeconds = typeof status.clock === 'number' ? status.clock : parseInt(status.clock);
                  if (!isNaN(clockSeconds) && clockSeconds >= 0) {
                    const minutes = Math.floor(clockSeconds / 60);
                    const seconds = clockSeconds % 60;
                    displayClock = `${minutes}:${String(seconds).padStart(2, '0')}`;
                  }
                }
              }
              
              if (matchStatus === 'IN PROGRESS' && (period || displayClock)) {
                const periodNum = period ? parseInt(period) : null;
                const isZeroClock = (displayClock === '0.0' || displayClock === '0:00' || displayClock === '0' || displayClock === '');
                
                if (sport === 'soccer') {
                  let minutes = null;
                  
                  if (displayClock && displayClock.includes(':')) {
                    const [mins] = displayClock.split(':').map(Number);
                    if (!isNaN(mins)) minutes = mins;
                  } else if (displayClock && !isNaN(parseInt(displayClock))) {
                    minutes = parseInt(displayClock);
                  }
                  
                  if (minutes === null && status.clock !== undefined && status.clock !== null) {
                    const clockValue = status.clock;
                    if (typeof clockValue === 'string' && clockValue.includes(':')) {
                      const [mins] = clockValue.split(':').map(Number);
                      if (!isNaN(mins)) minutes = mins;
                    } else if (typeof clockValue === 'number') {
                      minutes = Math.floor(clockValue / 60);
                    }
                  }
                  
                  let stoppageTime = null;
                  if (displayClock && (displayClock.includes('+') || displayClock.includes("'"))) {
                    const stoppageMatch = displayClock.match(/(\d+)[\'+]?\+(\d+)/);
                    if (stoppageMatch) {
                      minutes = parseInt(stoppageMatch[1]);
                      stoppageTime = parseInt(stoppageMatch[2]);
                    }
                  }
                  
                  if (stoppageTime === null && status.addedTime !== undefined && status.addedTime !== null) {
                    stoppageTime = parseInt(status.addedTime) || 0;
                  }
                  
                  if (minutes !== null) {
                    if (stoppageTime !== null && stoppageTime > 0) {
                      primaryDisplayTime = `${minutes}'+${stoppageTime}`;
                    } else {
                      primaryDisplayTime = `${minutes}'`;
                    }
                  } else if (periodNum === 1 && isZeroClock) {
                    primaryDisplayTime = 'Half';
                  } else {
                    primaryDisplayTime = displayClock || period || '';
                  }
                } else {
                  const isFootballHalftime = (sport === 'football' && (leagueName === 'NFL' || leagueName === 'NCAAF') && periodNum === 2 && isZeroClock);
                  const isBasketballHalftime = (sport === 'basketball' && (leagueName === 'NBA' || leagueName === 'WNBA') && periodNum === 2 && isZeroClock);
                  const isNHLFirstIntermission = (sport === 'hockey' && leagueName === 'NHL' && periodNum === 1 && isZeroClock);
                  const isNHLSecondIntermission = (sport === 'hockey' && leagueName === 'NHL' && periodNum === 2 && isZeroClock);
                  
                  if (isFootballHalftime || isBasketballHalftime) {
                    primaryDisplayTime = 'Half';
                  } else if (isNHLFirstIntermission) {
                    primaryDisplayTime = '1st Int.';
                  } else if (isNHLSecondIntermission) {
                    primaryDisplayTime = '2nd Int.';
                  } else {
                    let periodStr = '';
                    if (period) {
                      const periodNumParsed = parseInt(period);
                      if (!isNaN(periodNumParsed)) {
                        if (periodNumParsed === 1) periodStr = '1st';
                        else if (periodNumParsed === 2) periodStr = '2nd';
                        else if (periodNumParsed === 3) periodStr = '3rd';
                        else if (periodNumParsed === 4) periodStr = '4th';
                        else if (periodNumParsed > 4) periodStr = `${periodNumParsed}th`;
                        else periodStr = period;
                      } else {
                        periodStr = period;
                      }
                    }
                    
                    if (periodStr && displayClock) {
                      primaryDisplayTime = `${periodStr} ${displayClock}`;
                    } else if (periodStr) {
                      primaryDisplayTime = periodStr;
                    } else if (displayClock) {
                      primaryDisplayTime = displayClock;
                    }
                  }
                }
              }
              
              if (!primaryDisplayTime) {
                primaryDisplayTime = gameDateMountain.toFormat('h:mm a');
              }
            }
          }
          
          if (!primaryCompetition) continue;
          
          const primaryCompetitors = primaryCompetition.competitors || [];
          const primaryAwayTeam = primaryCompetitors.find(c => c.homeAway === 'away');
          const primaryHomeTeam = primaryCompetitors.find(c => c.homeAway === 'home');
          
          if (!primaryAwayTeam || !primaryHomeTeam) continue;
          
          const primaryGameDate = primaryCompetition.date ? new Date(primaryCompetition.date) : new Date();
          
          let matchStatus = 'SCHEDULED';
          if (primaryStatus?.type?.state === 'in') matchStatus = 'IN PROGRESS';
          else if (primaryStatus?.type?.state === 'post') matchStatus = 'FINAL';
          
          let sportDisplayName = 'Other';
          if (sport === 'football') {
            sportDisplayName = 'American Football';
          } else if (sport === 'basketball') {
            sportDisplayName = 'Basketball';
          } else if (sport === 'baseball') {
            sportDisplayName = 'Baseball';
          } else if (sport === 'hockey') {
            sportDisplayName = 'Hockey';
          } else if (sport === 'soccer') {
            sportDisplayName = 'Soccer';
          } else if (sport === 'tennis') {
            sportDisplayName = 'Tennis';
          } else if (sport === 'golf') {
            sportDisplayName = 'Golf';
          } else if (sport === 'racing') {
            sportDisplayName = 'Auto Racing';
          } else if (sport === 'mma') {
            sportDisplayName = 'MMA';
          } else if (sport === 'boxing') {
            sportDisplayName = 'Boxing';
          }
          
          const displayTime = primaryDisplayTime;
          const period = primaryStatus?.period || '';
          let displayClock = primaryStatus?.displayClock || '';
          
          if (sport === 'football' && (leagueName === 'NFL' || leagueName === 'NCAAF')) {
            if (primaryStatus?.clock !== undefined && primaryStatus?.clock !== null) {
              const clockSeconds = typeof primaryStatus.clock === 'number' ? primaryStatus.clock : parseInt(primaryStatus.clock);
              if (!isNaN(clockSeconds) && clockSeconds >= 0) {
                const minutes = Math.floor(clockSeconds / 60);
                const seconds = clockSeconds % 60;
                displayClock = `${minutes}:${String(seconds).padStart(2, '0')}`;
              }
            }
          }
          
          const leagueDisplayName = ESPN_LEAGUE_DISPLAY_NAME_MAP[leagueName] || leagueName;
          
          // Combine all channels (use first one, or comma-separate if multiple)
          // IMPORTANT: Preserve existing channel data if API doesn't provide it AND game is not FINAL
          // Only FINAL games should have empty channel; SCHEDULED and IN PROGRESS games must always display channel
          let channel = '';
          if (allChannels.size > 0) {
            // API provided channel data - use it
            channel = Array.from(allChannels)[0];
          } else if (matchStatus !== 'FINAL' && existingGameData) {
            // No channel from API, but game is not FINAL - preserve existing channel
            channel = existingGameData.channel || existingGameData.Channel || '';
          }
          // If game is FINAL and no channel from API, channel remains empty string
          
          let gameTime = '';
          if (matchStatus === 'IN PROGRESS' && displayClock && (leagueName === 'NFL' || leagueName === 'NCAAF')) {
            gameTime = displayClock;
          }
          
          let homeTeamRanking = null;
          let awayTeamRanking = null;
          if (leagueName === 'NCAAF') {
            homeTeamRanking = getTeamRanking(firstHomeTeamName, ncaafRankings);
            awayTeamRanking = getTeamRanking(firstAwayTeamName, ncaafRankings);
          }
          
          const gameData = {
            'League': leagueDisplayName,
            'Sport': sportDisplayName,
            'Home Team': firstHomeTeamName,
            'Away Team': firstAwayTeamName,
            'Home Score': primaryHomeTeam.score || '',
            'Away Score': primaryAwayTeam.score || '',
            'Match Status': matchStatus,
            'Channel': channel,
            'channel': channel,
            'Start Time': admin.firestore.Timestamp.fromDate(primaryGameDate),
            'gameDate': gameDateForStorage,
            'Matchup': `${firstAwayTeamName} vs ${firstHomeTeamName}`,
            'Game ID': eventId ? `espn-${league}-${eventId}` : generateDeterministicGameId('espn', leagueName, firstHomeTeamName, firstAwayTeamName, gameDateForStorage),
            'canonicalGameKey': getGameKey(leagueDisplayName, firstHomeTeamName, firstAwayTeamName, gameDateForStorage),
            'Last Updated': admin.firestore.FieldValue.serverTimestamp(),
            'source': 'ESPN_LIVE',
            'period': period,
            'displayClock': displayClock,
            'displayTime': displayTime,
            'GameTime': gameTime || null,
            'Stage': period ? `${period}${period === '1' ? 'ST' : period === '2' ? 'ND' : period === '3' ? 'RD' : 'TH'}_QUARTER` : '',
            'Home Team Ranking': homeTeamRanking,
            'Away Team Ranking': awayTeamRanking
          };
          
          allGames.push(gameData);
          totalFetched++;
          
        } catch (err) {
          console.error(`[ESPN Live Data] Error fetching game ${gameId}:`, err.message);
        }
      }
      
      console.log(`[ESPN Live Data] Optimized polling complete: fetched ${totalFetched} games via summary endpoint`);
    }
    
    // OPTIMIZED NCAA POLLING: Fetch individual games using game endpoint (same approach as ESPN)
    if (!isMorningRun && ncaaGamesToPollForProcessing && ncaaGamesToPollForProcessing.length > 0) {
      console.log(`[NCAA Live Data] Using optimized polling: fetching ${ncaaGamesToPollForProcessing.length} individual games via game endpoint`);
      
      // Helper function to extract numeric game ID from stored Game ID
      // Format: "ncaa-ncaam-6501578" ‚Üí "6501578"
      // Format: "ncaa-ncaam-ncaam-bostoncollege-clemson-20260113" ‚Üí try to extract from gameData or return null
      const extractNCAAGameId = (gameId, gameData) => {
        if (!gameId || typeof gameId !== 'string') return null;
        
        // Try to extract numeric ID from format "ncaa-ncaam-{numericId}" or "ncaa-ncaaw-{numericId}"
        const numericMatch = gameId.match(/^ncaa-ncaa[wm]-(\d+)$/);
        if (numericMatch) {
          return numericMatch[1];
        }
        
        // If deterministic ID format, we need the numeric ID from when the game was first fetched
        // Check if gameData has a stored numeric ID field (we might need to add this)
        // For now, return null and we'll need to fetch from scoreboard as fallback
        return null;
      };
      
      let totalNCAAFetched = 0;
      
      for (const { gameId, gameData: existingGameData } of ncaaGamesToPollForProcessing) {
        try {
          // Extract numeric game ID
          const numericGameId = extractNCAAGameId(gameId, existingGameData);
          
          if (!numericGameId) {
            // If we don't have numeric ID, we'll need to fetch from scoreboard (fallback)
            // This can happen if game ID is deterministic format
            console.warn(`[NCAA Live Data] Could not extract numeric game ID from ${gameId}, will fetch from scoreboard`);
            continue;
          }
          
          // Determine league from game ID
          const isNCAAW = gameId.includes('ncaaw');
          const leagueKey = isNCAAW ? 'NCAAW' : 'NCAAM';
          const leagueName = isNCAAW ? 'NCAAW' : 'NCAAM';
          
          // Fetch individual game
          const gameUrl = `https://ncaa-api.henrygd.me/game/${numericGameId}`;
          console.log(`[NCAA] Fetching ${leagueName} game ${numericGameId}...`);
          
          const response = await fetch(gameUrl, {
            headers: { 'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36' }
          });
          
          if (!response.ok) {
            console.warn(`[NCAA] Game ${numericGameId}: HTTP ${response.status} - skipping`);
            continue;
          }
          
          const gameData = await response.json();
          
          // Parse the game data (similar to scoreboard parsing but from individual game endpoint)
          if (gameData.contests && gameData.contests.length > 0) {
            const contest = gameData.contests[0];
            const teams = contest.teams || [];
            const homeTeam = teams.find(t => t.isHome);
            const awayTeam = teams.find(t => !t.isHome);
            
            if (!homeTeam || !awayTeam) continue;
            
            const homeTeamName = homeTeam.nameShort || homeTeam.nameFull || '';
            const awayTeamName = awayTeam.nameShort || awayTeam.nameFull || '';
            const homeScore = contest.linescores && contest.linescores.length > 0 && contest.linescores[0].homeScore ? contest.linescores[0].homeScore : (homeTeam.score || '');
            const awayScore = contest.linescores && contest.linescores.length > 0 && contest.linescores[0].awayScore ? contest.linescores[0].awayScore : (awayTeam.score || '');
            const gameState = (contest.gameState || '').toUpperCase();
            const finalMessage = (contest.finalMessage || '').toUpperCase();
            const currentPeriod = contest.currentPeriod || '';
            const startTimeEpoch = contest.startTimeEpoch ? Number(contest.startTimeEpoch) : null;
            const startTimeMillis = Number.isFinite(startTimeEpoch) ? startTimeEpoch * 1000 : null;
            
            if (!startTimeMillis) continue;
            
            const gameDateForStorage = DateTime
              .fromMillis(startTimeMillis, { zone: 'utc' })
              .setZone('America/New_York')
              .toISODate();
            
            let matchStatus = 'SCHEDULED';
            if (finalMessage === 'FINAL' || gameState === 'FINAL') {
              matchStatus = 'FINAL';
            } else if (gameState.includes('LIVE') || gameState.includes('IN_PROGRESS') || homeScore > 0 || awayScore > 0) {
              if (!finalMessage.includes('FINAL') && !gameState.includes('FINAL')) {
                matchStatus = 'IN PROGRESS';
              }
            }
            
            // Format display time (similar to scoreboard logic)
            const contestClock = contest.clock || '';
            let displayTime = '';
            const periodNum = currentPeriod ? (parseInt(currentPeriod) || (currentPeriod.includes('1') ? 1 : (currentPeriod.includes('2') ? 2 : null))) : null;
            const isZeroClock = (contestClock === '0.0' || contestClock === '0:00' || contestClock === '0' || contestClock === '');
            
            if (periodNum === 2 && isZeroClock) {
              matchStatus = 'FINAL';
              displayTime = 'F';
            } else if (matchStatus === 'IN PROGRESS' && (currentPeriod || contestClock)) {
              const isHalftime = (periodNum === 1 && isZeroClock);
              if (isHalftime) {
                displayTime = 'Half';
              } else {
                let periodStr = currentPeriod || '';
                if (periodStr && /^\d+$/.test(periodStr)) {
                  const pNum = parseInt(periodStr);
                  if (pNum === 1) periodStr = '1st';
                  else if (pNum === 2) periodStr = '2nd';
                  else if (pNum === 3) periodStr = '3rd';
                  else if (pNum === 4) periodStr = '4th';
                  else if (pNum > 4) periodStr = `${pNum}th`;
                }
                if (periodStr && contestClock) {
                  displayTime = `${periodStr} ${contestClock}`;
                } else if (periodStr) {
                  displayTime = periodStr;
                } else if (contestClock) {
                  displayTime = contestClock;
                }
              }
            }
            
            if (!displayTime && matchStatus === 'FINAL') {
              displayTime = 'F';
            }
            
            // Get rankings
            const rankingsMap = isNCAAW ? ncaawRankings : ncaamRankings;
            const homeTeamRanking = getTeamRanking(homeTeamName, rankingsMap);
            const awayTeamRanking = getTeamRanking(awayTeamName, rankingsMap);
            
            const leagueDisplayName = ESPN_LEAGUE_DISPLAY_NAME_MAP[leagueKey] || (isNCAAW ? 'USA: NCAA Women' : 'USA: NCAA');
            
            // IMPORTANT: Preserve existing channel data if game is not FINAL
            // Only FINAL games should have empty channel; SCHEDULED and IN PROGRESS games must always display channel
            // NCAA API doesn't provide channel data, so we preserve from existing game data
            let channel = '';
            if (matchStatus !== 'FINAL' && existingGameData) {
              channel = existingGameData.channel || existingGameData.Channel || '';
            }
            // If game is FINAL, channel remains empty string
            
            const gameDataToStore = {
              'League': leagueDisplayName,
              'Sport': 'Basketball',
              'Home Team': homeTeamName,
              'Away Team': awayTeamName,
              'Home Score': homeScore.toString(),
              'Away Score': awayScore.toString(),
              'Match Status': matchStatus,
              'Channel': channel,
              'channel': channel,
              'Start Time': admin.firestore.Timestamp.fromMillis(startTimeMillis),
              'gameDate': gameDateForStorage,
              'Matchup': `${awayTeamName} vs ${homeTeamName}`,
              'Game ID': `ncaa-${leagueKey.toLowerCase()}-${numericGameId}`,
              'Last Updated': admin.firestore.FieldValue.serverTimestamp(),
              'source': 'NCAA_LIVE',
              'period': currentPeriod || '',
              'displayClock': contestClock,
              'Current Period': currentPeriod,
              'displayTime': displayTime,
              'Home Team Ranking': homeTeamRanking,
              'Away Team Ranking': awayTeamRanking
            };
            
            allGames.push(gameDataToStore);
            totalNCAAFetched++;
            
          }
        } catch (err) {
          console.error(`[NCAA Live Data] Error fetching game ${gameId}:`, err.message);
        }
      }
      
      console.log(`[NCAA Live Data] Optimized polling complete: fetched ${totalNCAAFetched} games via game endpoint`);
    }
    
    // Fallback: Fetch NCAA games from scoreboard if not optimized (morning run or games without numeric IDs)
    // This happens if optimized polling didn't run or couldn't fetch all games
    
    // Fetch from ESPN API for the determined leagues/dates (fallback for morning runs or if optimized polling didn't run)
    // Note: NCAA games are always fetched (see below), so this fallback is only for ESPN leagues
    if (isMorningRun || !gamesToPollForProcessing || gamesToPollForProcessing.length === 0) {
    for (const dateInfo of leaguesAndDatesToFetch) {
      const { isoDate, espnDate, leagues } = dateInfo;
      console.log(`[ESPN Live Data] Fetching games for ${isoDate} (${espnDate})...`);
      
      // Use the leagues we determined (all leagues for morning run, or only leagues with live games for polling)
      const leaguesToFetch = leagues || ESPN_LEAGUES;
      
      for (const { sport, league, leagueName } of leaguesToFetch) {
        try {
          // Rate limiting: wait if needed
          const now = Date.now();
          const timeSinceLastRequest = now - lastESPNRequestTime;
          if (timeSinceLastRequest < MIN_TIME_BETWEEN_ESPN_REQUESTS) {
            const waitTime = MIN_TIME_BETWEEN_ESPN_REQUESTS - timeSinceLastRequest;
            await new Promise(resolve => setTimeout(resolve, waitTime));
          }
          lastESPNRequestTime = Date.now();
          
          const url = `https://site.api.espn.com/apis/site/v2/sports/${sport}/${league}/scoreboard?dates=${espnDate}`;
          console.log(`[ESPN] Fetching ${leagueName} for ${isoDate}...`);
          
          let response;
          let retries = 3;
          let backoffTime = 1000; // Start with 1 second
          
          while (retries > 0) {
            response = await fetch(url, {
              headers: {
                'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36'
              }
            });
            
            // If rate limited (429) or server error (5xx), retry with exponential backoff
            if (response.status === 429 || (response.status >= 500 && response.status < 600)) {
              retries--;
              if (retries > 0) {
                console.warn(`[ESPN] ${leagueName} (${isoDate}): HTTP ${response.status} - retrying in ${backoffTime/1000}s (${retries} retries left)...`);
                await new Promise(resolve => setTimeout(resolve, backoffTime));
                backoffTime *= 2; // Exponential backoff: 1s, 2s, 4s
                continue;
              }
            }
            break; // Success or non-retryable error
          }
          
          if (!response.ok) {
            console.warn(`[ESPN] ${leagueName} (${isoDate}): HTTP ${response.status} - skipping`);
            continue;
          }
          
          const data = await response.json();
          const events = data.events || [];
          
          if (sport === 'tennis') {
            console.log(`[ESPN] ${leagueName}: Found ${events.length} events`);
          }
          
          for (const event of events) {
            // Tennis tournaments use groupings structure, other sports use direct competitions
            let competitions = [];
            if (sport === 'tennis' && event.groupings && event.groupings.length > 0) {
              // For tennis tournaments, competitions are nested in groupings
              for (const grouping of event.groupings) {
                if (grouping.competitions && Array.isArray(grouping.competitions)) {
                  competitions.push(...grouping.competitions);
                }
              }
              if (sport === 'tennis') {
                console.log(`[ESPN] ${leagueName}: Event ${event.id || 'unknown'} (${event.name || 'unnamed'}) has ${competitions.length} competitions from ${event.groupings.length} groupings`);
                // Log sample competition dates for debugging
                if (competitions.length > 0) {
                  const sampleDates = competitions.slice(0, 5).map(c => c.date).filter(Boolean);
                  console.log(`[ESPN] ${leagueName}: Sample competition dates: ${sampleDates.join(', ')}`);
                }
              }
            } else {
              // For other sports, use direct competitions array
              competitions = event.competitions || [];
            }
            
            // Get team names from first competition to check for duplicates at event level
            // This prevents processing the same game multiple times across different competitions
            if (competitions.length === 0) {
              if (sport === 'tennis') {
                console.log(`[ESPN] ${leagueName}: Event ${event.id || 'unknown'} has no competitions, skipping`);
              }
              continue;
            }
            
            // For tennis, process each competition separately (each match gets its own game document)
            // For other sports, process all competitions together and create one game per event
            if (sport === 'tennis') {
            // Tennis: Create a game document for EACH competition/match
            for (const competition of competitions) {
              if (!competition) continue;
              
              // Filter by competition type to differentiate men's (ATP) vs women's (WTA)
              // ATP should only include "Men's Singles" and "Men's Doubles"
              // WTA should only include "Women's Singles" and "Women's Doubles"
              const competitionType = competition.type?.text || '';
              if (league === 'atp' && !competitionType.includes("Men's")) {
                // Skip women's competitions when fetching ATP
                continue;
              }
              if (league === 'wta' && !competitionType.includes("Women's")) {
                // Skip men's competitions when fetching WTA
                continue;
              }
              
              const competitors = competition.competitors || [];
              const awayTeam = competitors.find(c => c.homeAway === 'away');
              const homeTeam = competitors.find(c => c.homeAway === 'home');
              
              if (!awayTeam || !homeTeam) continue;
              
              // For tennis, use athlete.displayName
              const homeTeamName = homeTeam.athlete?.displayName || homeTeam.athlete?.shortName || homeTeam.athlete?.fullName || homeTeam.team?.displayName || '';
              const awayTeamName = awayTeam.athlete?.displayName || awayTeam.athlete?.shortName || awayTeam.athlete?.fullName || awayTeam.team?.displayName || '';
              
              // Get tournament name from event
              const tournamentName = event.name || '';
              
              // Get set-by-set scores (linescores) for tennis
              // ESPN API: linescores are on the competitor object as an array of {value: X, winner: bool}
              const homeLinescores = homeTeam.linescores || [];
              const awayLinescores = awayTeam.linescores || [];
              
              // Format linescores as array of set scores (e.g., [4, 6, 2])
              // Each linescore is an object with {value: number, winner: boolean, tiebreak?: number}
              const homeSetScores = homeLinescores.map(set => {
                if (typeof set === 'object' && set !== null) {
                  return set.value || 0;
                }
                return typeof set === 'number' ? set : 0;
              });
              const awaySetScores = awayLinescores.map(set => {
                if (typeof set === 'object' && set !== null) {
                  return set.value || 0;
                }
                return typeof set === 'number' ? set : 0;
              });
              
              // Log for debugging (only for matches with scores)
              if (homeSetScores.length > 0 || awaySetScores.length > 0) {
                console.log(`[ESPN TENNIS SCORES] ${awayTeamName} vs ${homeTeamName}: Away sets: [${awaySetScores.join(', ')}], Home sets: [${homeSetScores.join(', ')}]`);
              }
              
              const status = competition.status || {};
              const gameDate = competition.date ? new Date(competition.date) : new Date();
              
              // Get the game's actual start date by converting the start time from UTC to Eastern Time
              if (!competition.date) continue;
              const competitionGameDateForStorage = DateTime
                .fromISO(competition.date, { zone: 'utc' })
                .setZone('America/New_York')
                .toISODate();
              
              // Convert the date we're fetching (Mountain Time) to Eastern Time for comparison
              const isoDateMountain = DateTime.fromISO(isoDate, { zone: 'America/Denver' });
              const isoDateEastern = isoDateMountain.setZone('America/New_York').toISODate();
              
              // Only include games that match the date we're fetching
              if (competitionGameDateForStorage !== isoDateEastern) {
                console.log(`[ESPN] FILTERED OUT: ${leagueName} - ${awayTeamName} vs ${homeTeamName} - gameDate (ET): ${competitionGameDateForStorage}, fetching for: ${isoDateEastern}`);
                continue;
              }
              
              // Check for duplicates at COMPETITION level for tennis
              const competitionGameKey = getGameKey(leagueName, homeTeamName, awayTeamName, competitionGameDateForStorage);
              if (uniqueGames.has(competitionGameKey)) {
                console.log(`[ESPN] Skipping duplicate tennis match: ${leagueName} - ${awayTeamName} vs ${homeTeamName} on ${competitionGameDateForStorage}`);
                continue;
              }
              uniqueGames.add(competitionGameKey);
              
              // Get broadcast info
              const broadcasts = competition.broadcasts?.[0]?.names || [];
              const channel = broadcasts.length > 0 ? broadcasts[0] : '';
              
              // Map ESPN status to your format
              let matchStatus = 'SCHEDULED';
              if (status.type?.state === 'in') matchStatus = 'IN PROGRESS';
              else if (status.type?.state === 'post') matchStatus = 'FINAL';
              
              const gameDateUTC = DateTime.fromJSDate(gameDate, { zone: 'utc' });
              const gameDateMountain = gameDateUTC.setZone('America/Denver');
              
              // Calculate display time
              let displayTime = '';
              const period = status.period || '';
              let displayClock = status.displayClock || '';
              
              if (matchStatus === 'IN PROGRESS' && (period || displayClock)) {
                displayTime = displayClock || period || '';
              } else {
                displayTime = gameDateMountain.toFormat('h:mm a');
              }
              
              // Map sport to display name
              const sportDisplayName = 'Tennis';
              
              // Map ESPN league name to display name
              const leagueDisplayName = ESPN_LEAGUE_DISPLAY_NAME_MAP[leagueName] || leagueName;
              
              // Use competition.id if available, otherwise event.id + competition index
              const competitionId = competition.id || `${event.id}-${competitions.indexOf(competition)}`;
              const gameId = `espn-${league}-${competitionId}`;
              
              const gameData = {
                'League': leagueDisplayName,
                'Sport': sportDisplayName,
                'Home Team': homeTeamName,
                'Away Team': awayTeamName,
                // For tennis, competitors don't have a 'score' field - only linescores
                // Calculate sets won for display (optional - can leave empty since we have set scores)
                // Or leave empty and rely on set scores only
                'Home Score': '', // Tennis doesn't use overall score, use Home Set Scores instead
                'Away Score': '', // Tennis doesn't use overall score, use Away Set Scores instead
                'Match Status': matchStatus,
                'Channel': channel,
                'channel': channel,
                'Start Time': admin.firestore.Timestamp.fromDate(gameDate),
                'gameDate': competitionGameDateForStorage,
                'Matchup': `${awayTeamName} vs ${homeTeamName}`,
                'Game ID': gameId,
                'canonicalGameKey': competitionGameKey,
                'Last Updated': admin.firestore.FieldValue.serverTimestamp(),
                'source': 'ESPN_LIVE',
                'period': period,
                'displayClock': displayClock,
                'displayTime': displayTime,
                // Tennis-specific fields
                'Tournament': tournamentName,
                'Competition Type': competitionType, // e.g., "Men's Singles", "Women's Singles"
                'Home Set Scores': homeSetScores,
                'Away Set Scores': awaySetScores,
                'Home Linescores': homeLinescores, // Full linescores with winner flags
                'Away Linescores': awayLinescores  // Full linescores with winner flags
              };
              
              allGames.push(gameData);
              console.log(`[ESPN] INCLUDING TENNIS: ${leagueName} - ${awayTeamName} vs ${homeTeamName} - gameDate (ET): ${competitionGameDateForStorage}, Game ID: ${gameId}`);
            }
            // Skip the rest of the event processing for tennis (we've already processed all competitions)
            if (sport === 'tennis') {
              console.log(`[ESPN] ${leagueName}: Processed ${competitions.length} competitions from event ${event.id || 'unknown'}`);
            }
            continue;
          }
          
          // For non-tennis sports: Get team names from first competition to check for duplicates at event level
          const firstCompetition = competitions[0];
          const firstCompetitors = firstCompetition.competitors || [];
          const firstAwayTeam = firstCompetitors.find(c => c.homeAway === 'away');
          const firstHomeTeam = firstCompetitors.find(c => c.homeAway === 'home');
          
          if (!firstAwayTeam || !firstHomeTeam) continue;
          
          // For non-tennis sports, use team.displayName
          const firstHomeTeamName = firstHomeTeam.team?.displayName || '';
          const firstAwayTeamName = firstAwayTeam.team?.displayName || '';
          
          // Get the game's actual start date by converting the start time from UTC to Eastern Time
          // ESPN dates are ISO-8601 UTC timestamps (e.g., "2025-12-27T01:00Z")
          // We must parse as UTC, convert to Eastern, then extract the date
          if (!firstCompetition.date) continue; // Skip if no date
          const gameDateForStorage = DateTime
            .fromISO(firstCompetition.date, { zone: 'utc' })
            .setZone('America/New_York')
            .toISODate();
          
          // Convert the date we're fetching (Mountain Time) to Eastern Time for comparison
          // This ensures we only include games that match the date we're fetching
          const isoDateMountain = DateTime.fromISO(isoDate, { zone: 'America/Denver' });
          const isoDateEastern = isoDateMountain.setZone('America/New_York').toISODate();
          
          // Only include games that match the date we're fetching (after conversion to Eastern Time)
          // This prevents games from other dates from being stored with the wrong date
          // ESPN API returns games from multiple dates, so we MUST filter here
          if (gameDateForStorage !== isoDateEastern) {
            console.log(`[ESPN] FILTERED OUT: ${leagueName} - ${firstAwayTeamName} vs ${firstHomeTeamName} - gameDate (ET): ${gameDateForStorage}, fetching for: ${isoDateEastern}, ESPN UTC: ${firstCompetition.date}`);
            continue; // Skip games that don't match the date we're fetching
          }
          
          // Log games that pass the filter for debugging
          console.log(`[ESPN] INCLUDING: ${leagueName} - ${firstAwayTeamName} vs ${firstHomeTeamName} - gameDate (ET): ${gameDateForStorage}, ESPN UTC: ${firstCompetition.date}`);
          
          // For non-tennis sports: Check for duplicates at EVENT level (before processing competitions)
          const eventGameKey = getGameKey(leagueName, firstHomeTeamName, firstAwayTeamName, gameDateForStorage);
          if (uniqueGames.has(eventGameKey)) {
            console.log(`[ESPN] Skipping duplicate event: ${leagueName} - ${firstAwayTeamName} vs ${firstHomeTeamName} on ${gameDateForStorage}`);
            continue; // Skip entire event if we've already seen this game
          }
          uniqueGames.add(eventGameKey);
          
          // Collect all channels from all competitions for this event
          const allChannels = new Set();
          let primaryCompetition = null;
          let primaryStatus = null;
          let primaryDisplayTime = '';
          
          // Process each competition to collect channels and find primary competition data
          for (const competition of competitions) {
            if (!competition) continue;
            
            const competitors = competition.competitors || [];
            const awayTeam = competitors.find(c => c.homeAway === 'away');
            const homeTeam = competitors.find(c => c.homeAway === 'home');
            
            if (!awayTeam || !homeTeam) continue;
          
            const status = competition.status || {};
            const gameDate = competition.date ? new Date(competition.date) : new Date();
            
            // Get broadcast info and add to channels set
            const broadcasts = competition.broadcasts?.[0]?.names || [];
            if (broadcasts.length > 0) {
              broadcasts.forEach(broadcastName => {
                if (broadcastName && broadcastName.trim()) {
                  allChannels.add(broadcastName.trim());
                }
              });
            }
            
            // Use first competition as primary, or prefer one that's in progress
            if (!primaryCompetition || (status.type?.state === 'in' && primaryStatus?.type?.state !== 'in')) {
              primaryCompetition = competition;
              primaryStatus = status;
              
              // Calculate display time for primary competition
              const gameDateUTC = DateTime.fromJSDate(gameDate, { zone: 'utc' });
              const gameDateMountain = gameDateUTC.setZone('America/Denver');
              
              // Map ESPN status to your format
              let matchStatus = 'SCHEDULED';
              if (status.type?.state === 'in') matchStatus = 'IN PROGRESS';
              else if (status.type?.state === 'post') matchStatus = 'FINAL';
              
              const period = status.period || '';
              // ESPN API: For NFL/NCAAF, status.clock is seconds remaining in quarter (number)
              // status.displayClock might be wrong (shows 15:00 at quarter start)
              // Use status.clock (seconds) and convert to MM:SS format
              let displayClock = status.displayClock || '';
              
              // For NFL/NCAAF, prefer status.clock (seconds) over displayClock
              if (sport === 'football' && (leagueName === 'NFL' || leagueName === 'NCAAF')) {
                if (status.clock !== undefined && status.clock !== null) {
                  const clockSeconds = typeof status.clock === 'number' ? status.clock : parseInt(status.clock);
                  if (!isNaN(clockSeconds) && clockSeconds >= 0) {
                    const minutes = Math.floor(clockSeconds / 60);
                    const seconds = clockSeconds % 60;
                    displayClock = `${minutes}:${String(seconds).padStart(2, '0')}`;
                  }
                }
              }
              
              if (matchStatus === 'IN PROGRESS' && (period || displayClock)) {
                const periodNum = period ? parseInt(period) : null;
                const isZeroClock = (displayClock === '0.0' || displayClock === '0:00' || displayClock === '0' || displayClock === '');
                
                // Handle soccer time display (minutes with apostrophe, e.g., "76'")
                if (sport === 'soccer') {
                  let minutes = null;
                  
                  // ESPN API for soccer: displayClock shows TOTAL minutes elapsed in the game
                  // NOT minutes in current half - ESPN already calculates total time
                  // Period 1: 0-45+ minutes (total game time)
                  // Period 2: 45-90+ minutes (total game time)
                  
                  if (displayClock && displayClock.includes(':')) {
                    const [mins, secs] = displayClock.split(':').map(Number);
                    if (!isNaN(mins)) minutes = mins;
                  } else if (displayClock && !isNaN(parseInt(displayClock))) {
                    minutes = parseInt(displayClock);
                  }
                  
                  if (minutes === null && status.clock !== undefined && status.clock !== null) {
                    const clockValue = status.clock;
                    if (typeof clockValue === 'string' && clockValue.includes(':')) {
                      const [mins] = clockValue.split(':').map(Number);
                      if (!isNaN(mins)) minutes = mins;
                    } else if (typeof clockValue === 'number') {
                      // ESPN clock is total seconds - convert to minutes
                      minutes = Math.floor(clockValue / 60);
                    }
                  }
                  
                  let stoppageTime = null;
                  // Check for stoppage time in displayClock (e.g., "45+3", "90+5")
                  if (displayClock && (displayClock.includes('+') || displayClock.includes("'"))) {
                    const stoppageMatch = displayClock.match(/(\d+)[\'+]?\+(\d+)/);
                    if (stoppageMatch) {
                      minutes = parseInt(stoppageMatch[1]);
                      stoppageTime = parseInt(stoppageMatch[2]);
                    }
                  }
                  
                  if (stoppageTime === null && status.addedTime !== undefined && status.addedTime !== null) {
                    stoppageTime = parseInt(status.addedTime) || 0;
                  }
                  
                  if (minutes !== null) {
                    // ESPN displayClock is ALREADY total game time - don't add 45 for period 2
                    // Use minutes as-is
                    
                    if (stoppageTime !== null && stoppageTime > 0) {
                      primaryDisplayTime = `${minutes}'+${stoppageTime}`;
                    } else {
                      primaryDisplayTime = `${minutes}'`;
                    }
                  } else if (periodNum === 1 && isZeroClock) {
                    primaryDisplayTime = 'Half';
                  } else {
                    primaryDisplayTime = displayClock || period || '';
                  }
                } else {
                  // Non-soccer sports
                  const isFootballHalftime = (sport === 'football' && (leagueName === 'NFL' || leagueName === 'NCAAF') && periodNum === 2 && isZeroClock);
                  const isBasketballHalftime = (sport === 'basketball' && (leagueName === 'NBA' || leagueName === 'WNBA') && periodNum === 2 && isZeroClock);
                  const isNHLFirstIntermission = (sport === 'hockey' && leagueName === 'NHL' && periodNum === 1 && isZeroClock);
                  const isNHLSecondIntermission = (sport === 'hockey' && leagueName === 'NHL' && periodNum === 2 && isZeroClock);
                  
                  if (isFootballHalftime || isBasketballHalftime) {
                    primaryDisplayTime = 'Half';
                  } else if (isNHLFirstIntermission) {
                    primaryDisplayTime = '1st Int.';
                  } else if (isNHLSecondIntermission) {
                    primaryDisplayTime = '2nd Int.';
                  } else {
                    let periodStr = '';
                    if (period) {
                      const periodNum = parseInt(period);
                      if (!isNaN(periodNum)) {
                        if (periodNum === 1) periodStr = '1st';
                        else if (periodNum === 2) periodStr = '2nd';
                        else if (periodNum === 3) periodStr = '3rd';
                        else if (periodNum === 4) periodStr = '4th';
                        else if (periodNum > 4) periodStr = `${periodNum}th`;
                        else periodStr = period;
                      } else {
                        periodStr = period;
                      }
                    }
                    
                    if (periodStr && displayClock) {
                      primaryDisplayTime = `${periodStr} ${displayClock}`;
                    } else if (periodStr) {
                      primaryDisplayTime = periodStr;
                    } else if (displayClock) {
                      primaryDisplayTime = displayClock;
                    }
                  }
                }
              }
              
              // If not in progress, format start time for display
              if (!primaryDisplayTime) {
                primaryDisplayTime = gameDateMountain.toFormat('h:mm a');
              }
            }
          }
          
          // Now create ONE game entry using primary competition data
          if (!primaryCompetition) continue;
          
          const primaryCompetitors = primaryCompetition.competitors || [];
          const primaryAwayTeam = primaryCompetitors.find(c => c.homeAway === 'away');
          const primaryHomeTeam = primaryCompetitors.find(c => c.homeAway === 'home');
          
          if (!primaryAwayTeam || !primaryHomeTeam) continue;
          
          const primaryGameDate = primaryCompetition.date ? new Date(primaryCompetition.date) : new Date();
          const primaryGameDateUTC = DateTime.fromJSDate(primaryGameDate, { zone: 'utc' });
          const primaryGameDateMountain = primaryGameDateUTC.setZone('America/Denver');
          
          // Map ESPN status to your format
          let matchStatus = 'SCHEDULED';
          if (primaryStatus?.type?.state === 'in') matchStatus = 'IN PROGRESS';
          else if (primaryStatus?.type?.state === 'post') matchStatus = 'FINAL';
          
          // Combine all channels (use first one, or comma-separate if multiple)
          // IMPORTANT: Only set channel if API provides it OR if game is FINAL (to clear it)
          // For SCHEDULED/IN PROGRESS games without API channel, we'll preserve existing channel via merge
          const channelFromAPI = allChannels.size > 0 ? Array.from(allChannels)[0] : '';
          // Only set channel if we have it from API, or if game is FINAL (to clear channel)
          // Otherwise, don't include channel in update (merge will preserve existing)
          const shouldSetChannel = channelFromAPI || matchStatus === 'FINAL';
          const channel = shouldSetChannel ? channelFromAPI : undefined;
          
          // Map sport to display name
          let sportDisplayName = 'Other';
          if (sport === 'football') {
            sportDisplayName = 'American Football';
          } else if (sport === 'basketball') {
            sportDisplayName = 'Basketball';
          } else if (sport === 'baseball') {
            sportDisplayName = 'Baseball';
          } else if (sport === 'hockey') {
            sportDisplayName = 'Hockey';
          } else if (sport === 'soccer') {
            sportDisplayName = 'Soccer';
          } else if (sport === 'tennis') {
            sportDisplayName = 'Tennis';
          } else if (sport === 'golf') {
            sportDisplayName = 'Golf';
          } else if (sport === 'racing') {
            sportDisplayName = 'Auto Racing';
          } else if (sport === 'mma') {
            sportDisplayName = 'MMA';
          } else if (sport === 'boxing') {
            sportDisplayName = 'Boxing';
          }
          
          // Use the displayTime we calculated for the primary competition
          const displayTime = primaryDisplayTime;
          const period = primaryStatus?.period || '';
          // Recalculate displayClock for NFL/NCAAF using status.clock (seconds) if available
          let displayClock = primaryStatus?.displayClock || '';
          
          // For NFL/NCAAF, prefer status.clock (seconds) over displayClock
          // ESPN's displayClock shows "15:00" at quarter start, but status.clock has actual seconds remaining
          if (sport === 'football' && (leagueName === 'NFL' || leagueName === 'NCAAF')) {
            if (primaryStatus?.clock !== undefined && primaryStatus?.clock !== null) {
              const clockSeconds = typeof primaryStatus.clock === 'number' ? primaryStatus.clock : parseInt(primaryStatus.clock);
              if (!isNaN(clockSeconds) && clockSeconds >= 0) {
                const minutes = Math.floor(clockSeconds / 60);
                const seconds = clockSeconds % 60;
                displayClock = `${minutes}:${String(seconds).padStart(2, '0')}`;
              }
            }
          }
          
          // Map ESPN league name to display name (matching what importGamesFromSheets uses)
          const leagueDisplayName = ESPN_LEAGUE_DISPLAY_NAME_MAP[leagueName] || leagueName;
          
          // Extract GameTime from displayClock for NFL/NCAAF (frontend fallback needs this)
          // displayClock format: "8:05" (MM:SS) for NFL
          let gameTime = '';
          if (matchStatus === 'IN PROGRESS' && displayClock && (leagueName === 'NFL' || leagueName === 'NCAAF')) {
            // displayClock is MM:SS format - use as-is for GameTime
            gameTime = displayClock;
          }
          
          // Get rankings for NCAAF teams
          let homeTeamRanking = null;
          let awayTeamRanking = null;
          if (leagueName === 'NCAAF') {
            homeTeamRanking = getTeamRanking(firstHomeTeamName, ncaafRankings);
            awayTeamRanking = getTeamRanking(firstAwayTeamName, ncaafRankings);
          }
          
          const gameData = {
            'League': leagueDisplayName, // Use display name for consistency with importGamesFromSheets
            'Sport': sportDisplayName,
            'Home Team': firstHomeTeamName,
            'Away Team': firstAwayTeamName,
            'Home Score': primaryHomeTeam.score || '',
            'Away Score': primaryAwayTeam.score || '',
            'Match Status': matchStatus,
            // Only include channel if we have it from API or if game is FINAL (to clear it)
            // Otherwise, merge will preserve existing channel data
            ...(shouldSetChannel && { 'Channel': channel, 'channel': channel }),
            'Start Time': admin.firestore.Timestamp.fromDate(primaryGameDate), // UTC timestamp from ESPN
            'gameDate': gameDateForStorage, // Use the date we're fetching (ensures all games for a date have the same gameDate)
            'Matchup': `${firstAwayTeamName} vs ${firstHomeTeamName}`,
            'Game ID': event.id 
              ? `espn-${league}-${event.id}`
              : generateDeterministicGameId('espn', leagueName, firstHomeTeamName, firstAwayTeamName, gameDateForStorage),
              // Canonical key used to match games across different writers (league|home|away|date)
              'canonicalGameKey': getGameKey(leagueDisplayName, firstHomeTeamName, firstAwayTeamName, gameDateForStorage),
            'Last Updated': admin.firestore.FieldValue.serverTimestamp(),
            'source': 'ESPN_LIVE', // Flag to identify ESPN live data
            'period': period,
            'displayClock': displayClock,
            'displayTime': displayTime, // Formatted time: period/clock when in progress, start time otherwise
            'GameTime': gameTime || null, // Set GameTime for NFL/NCAAF so frontend fallback works correctly
            'Stage': period ? `${period}${period === '1' ? 'ST' : period === '2' ? 'ND' : period === '3' ? 'RD' : 'TH'}_QUARTER` : '',
            'Home Team Ranking': homeTeamRanking,
            'Away Team Ranking': awayTeamRanking
          };
          
          // Debug logging for NFL games to see what ESPN is returning
          if (sport === 'football' && (leagueName === 'NFL' || leagueName === 'NCAAF')) {
            const gameId = event.id ? `espn-${league}-${event.id}` : 'unknown';
            console.log(`[ESPN NFL DEBUG] Game ID: ${gameId} | ${firstAwayTeamName} vs ${firstHomeTeamName}:`);
            console.log(`  Raw ESPN status object:`, JSON.stringify({
              displayClock: primaryStatus?.displayClock,
              clock: primaryStatus?.clock,
              period: primaryStatus?.period,
              type: primaryStatus?.type
            }, null, 2));
            console.log(`  Calculated displayClock: "${displayClock}"`);
            console.log(`  Calculated GameTime: "${gameTime || 'null'}"`);
            console.log(`  displayTime: "${displayTime}"`);
            console.log(`  period: ${period}`);
            console.log(`  matchStatus: ${matchStatus}`);
            console.log(`  Game will be written with GameTime: "${gameTime || 'null'}"`);
          }
          
            // Add the game (duplicate check already done at event level)
            allGames.push(gameData);
          }
          
          console.log(`[ESPN] ${leagueName} (${isoDate}): Found ${events.length} games`);
          
          // Small delay to avoid rate limiting
          await new Promise(resolve => setTimeout(resolve, 200));
          
        } catch (err) {
          console.error(`[ESPN] Error fetching ${leagueName} for ${isoDate}:`, err.message);
        }
        }
      }
    }
    
    // Fetch NCAA API data for NCAAM and NCAAW
    // OPTIMIZATION: If we have NCAA games to poll, only fetch scoreboards for dates that have those games
    // Otherwise, fetch for today + yesterday (polling) or all 7 days (morning run)
    let datesForNCAA;
    if (!isMorningRun && ncaaGamesToPollForProcessing && ncaaGamesToPollForProcessing.length > 0) {
      // Optimized: Only fetch scoreboards for dates that have games to poll
      const datesWithNCAAGames = new Set();
      for (const { gameData } of ncaaGamesToPollForProcessing) {
        if (gameData.gameDate) {
          datesWithNCAAGames.add(gameData.gameDate);
        }
      }
      datesForNCAA = Array.from(datesWithNCAAGames).map(isoDate => ({
        isoDate,
        espnDate: DateTime.fromISO(isoDate).toFormat('yyyyMMdd')
      }));
      console.log(`[NCAA API] Optimized: Fetching scoreboards for ${datesForNCAA.length} date(s) with ${ncaaGamesToPollForProcessing.length} games to poll`);
    } else {
      // Fallback: Fetch for today + yesterday (polling) or all 7 days (morning run)
      datesForNCAA = isMorningRun 
      ? datesToFetch 
      : [
          { isoDate: yesterdayStr, espnDate: DateTime.fromISO(yesterdayStr).toFormat('yyyyMMdd') },
          datesToFetch[0] // Today
        ];
    console.log(`[NCAA API] Fetching NCAAM and NCAAW games for ${isMorningRun ? 'next 7 days' : 'today + yesterday'}...`);
    }
    
    // Rankings already fetched above, reuse them
    // Fetch NCAAM for each date
    for (const dateInfo of datesForNCAA) {
      const { isoDate } = dateInfo;
      const ncaaDate = DateTime.fromISO(isoDate).toFormat('yyyy/MM/dd');
      console.log(`[NCAA API] Fetching NCAAM for ${isoDate}...`);
      
      try {
        const ncaamUrl = `https://ncaa-api.henrygd.me/scoreboard/basketball-men/d1/${ncaaDate}`;
        const ncaamResponse = await fetch(ncaamUrl, {
          headers: { 'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36' }
        });
        if (ncaamResponse.ok) {
          const ncaamData = await ncaamResponse.json();
          if (ncaamData.games && Array.isArray(ncaamData.games)) {
            // OPTIMIZATION: If we have games to poll, create a set of game IDs to filter
            const gamesToPollIds = new Set();
            if (ncaaGamesToPollForProcessing && ncaaGamesToPollForProcessing.length > 0) {
              for (const { gameId } of ncaaGamesToPollForProcessing) {
                // Extract the actual game ID from stored format (e.g., "ncaa-ncaam-12345" -> "12345")
                const match = gameId.match(/^ncaa-ncaam-(.+)$/);
                if (match) {
                  gamesToPollIds.add(match[1]);
                }
                // Also add the full gameId for matching
                gamesToPollIds.add(gameId);
              }
            }
            
            for (const gameItem of ncaamData.games) {
              const game = gameItem.game;
              if (!game) continue;
              
              // Extract numeric game ID from URL if available (e.g., "/game/6501578" -> "6501578")
              // This allows us to fetch individual games later
              let numericGameId = game.id || null;
              if (!numericGameId && game.url) {
                const urlMatch = game.url.match(/\/game\/(\d+)/);
                if (urlMatch) {
                  numericGameId = urlMatch[1];
                }
              }
              
              // OPTIMIZATION: If we have games to poll, skip games not in our list
              if (gamesToPollIds.size > 0) {
                const gameIdFromAPI = game.id ? `ncaa-ncaam-${game.id}` : null;
                if (!gameIdFromAPI || !gamesToPollIds.has(gameIdFromAPI) && !gamesToPollIds.has(game.id)) {
                  continue; // Skip games not in our polling list
                }
              }
              
              const awayTeam = game.away;
              const homeTeam = game.home;
              if (!awayTeam || !homeTeam) continue;
              
              const awayTeamName = awayTeam.names?.short || awayTeam.names?.full || awayTeam.names?.seo || '';
              const homeTeamName = homeTeam.names?.short || homeTeam.names?.full || homeTeam.names?.seo || '';
              if (!awayTeamName || !homeTeamName) continue;
              
              const awayScore = awayTeam.score || '';
              const homeScore = homeTeam.score || '';
              const gameState = (game.gameState || '').toUpperCase();
              const finalMessage = (game.finalMessage || '').toUpperCase();
              const currentPeriod = game.currentPeriod || '';
              const startTimeEpochSeconds = game.startTimeEpoch ? Number(game.startTimeEpoch) : null;
              const startTimeMillis = Number.isFinite(startTimeEpochSeconds) ? startTimeEpochSeconds * 1000 : null;
              
              // Get the game's actual start date by converting the start time from UTC to Eastern Time
              // NCAA API provides epoch seconds (UTC). Convert to Eastern Time, then extract the date
              if (!startTimeMillis) continue; // Skip if no start time
              const gameDateForStorage = DateTime
                .fromMillis(startTimeMillis, { zone: 'utc' })
                .setZone('America/New_York')
                .toISODate();
              
              // Convert the date we're fetching (Mountain Time) to Eastern Time for comparison
              // This ensures we only include games that match the date we're fetching
              const isoDateMountain = DateTime.fromISO(isoDate, { zone: 'America/Denver' });
              const isoDateEastern = isoDateMountain.setZone('America/New_York').toISODate();
              
              // Only include games that match the date we're fetching (after conversion to Eastern Time)
              // This prevents games from other dates from being stored with the wrong date
              if (gameDateForStorage !== isoDateEastern) {
                continue; // Skip games that don't match the date we're fetching
              }
              
              let matchStatus = 'SCHEDULED';
              if (finalMessage === 'FINAL' || gameState === 'FINAL') {
                matchStatus = 'FINAL';
              } else if (gameState.includes('LIVE') || gameState.includes('IN_PROGRESS') || homeScore > 0 || awayScore > 0) {
                if (!finalMessage.includes('FINAL') && !gameState.includes('FINAL')) {
                  matchStatus = 'IN PROGRESS';
                }
              }
            
            // Format display time: show period/clock when in progress, start time otherwise
            const contestClock = game.contestClock || '';
            let displayTime = '';
            
            // For NCAAM: halftime is at "1st 0.0", and "2nd 0.0" means finished (F)
            const periodNum = currentPeriod ? (parseInt(currentPeriod) || (currentPeriod.includes('1') ? 1 : (currentPeriod.includes('2') ? 2 : null))) : null;
            const isZeroClock = (contestClock === '0.0' || contestClock === '0:00' || contestClock === '0' || contestClock === '');
            
            // Check if NCAAM game is finished (2nd period with 0.0 clock)
            if (periodNum === 2 && isZeroClock) {
              matchStatus = 'FINAL';
              displayTime = 'F';
            } else if (matchStatus === 'IN PROGRESS' && (currentPeriod || contestClock)) {
              // Check for halftime (1st period with 0.0 or 0:00 clock) for NCAAM
              const isHalftime = (periodNum === 1 && isZeroClock);
              
              if (isHalftime) {
                displayTime = 'Half';
              } else {
                // currentPeriod might already be formatted (e.g., "2nd") or just a number
                let periodStr = currentPeriod || '';
                
                // If period is just a number, format it (e.g., "2" -> "2nd")
                if (periodStr && /^\d+$/.test(periodStr)) {
                  const periodNum = parseInt(periodStr);
                  if (periodNum === 1) periodStr = '1st';
                  else if (periodNum === 2) periodStr = '2nd';
                  else if (periodNum === 3) periodStr = '3rd';
                  else if (periodNum === 4) periodStr = '4th';
                  else if (periodNum > 4) periodStr = `${periodNum}th`;
                }
                
                // Combine period and clock (e.g., "2nd 8:03")
                if (periodStr && contestClock) {
                  displayTime = `${periodStr} ${contestClock}`;
                } else if (periodStr) {
                  displayTime = periodStr;
                } else if (contestClock) {
                  displayTime = contestClock;
                }
              }
            }
            
            // If not in progress and not final, format start time for display
            if (!displayTime && matchStatus !== 'FINAL' && startTimeMillis) {
              const startTimeMountain = DateTime.fromMillis(startTimeMillis).setZone('America/Denver');
              displayTime = startTimeMountain.toFormat('h:mm a');
            } else if (!displayTime && matchStatus === 'FINAL') {
              displayTime = 'F';
            } else if (!displayTime) {
              displayTime = '';
            }
            
            // Map NCAA league name to display name (matching what importGamesFromSheets uses)
            const leagueDisplayName = ESPN_LEAGUE_DISPLAY_NAME_MAP['NCAAM'] || 'USA: NCAA';
            
            // Get rankings for teams
            const homeTeamRanking = getTeamRanking(homeTeamName, ncaamRankings);
            const awayTeamRanking = getTeamRanking(awayTeamName, ncaamRankings);
            
            // IMPORTANT: Preserve existing channel data if game is not FINAL
            // Only FINAL games should have empty channel; SCHEDULED and IN PROGRESS games must always display channel
            // NCAA API doesn't provide channel data, so we only clear it for FINAL games
            // Otherwise, merge will preserve existing channel data from Google Sheets
            const shouldClearChannel = matchStatus === 'FINAL';
            
            // Calculate canonicalGameKey for deduplication (same as ESPN games)
            const gameKey = getGameKey(leagueDisplayName, homeTeamName, awayTeamName, gameDateForStorage);
            
            const gameData = {
              'League': leagueDisplayName, // Use display name for consistency with importGamesFromSheets
              'Sport': 'Basketball',
              'Home Team': homeTeamName,
              'Away Team': awayTeamName,
              'Home Score': homeScore.toString(),
              'Away Score': awayScore.toString(),
              'Match Status': matchStatus,
              // Only clear channel if game is FINAL, otherwise preserve existing channel via merge
              ...(shouldClearChannel && { 'Channel': '', 'channel': '' }),
              'Start Time': startTimeMillis ? admin.firestore.Timestamp.fromMillis(startTimeMillis) : admin.firestore.Timestamp.now(),
              'gameDate': gameDateForStorage,
              'Matchup': `${awayTeamName} vs ${homeTeamName}`,
              'Game ID': numericGameId 
                ? `ncaa-ncaam-${numericGameId}`
                : generateDeterministicGameId('ncaa-ncaam', 'NCAAM', homeTeamName, awayTeamName, gameDateForStorage),
              'canonicalGameKey': gameKey, // Add canonicalGameKey for deduplication (matches ESPN games pattern)
              'NCAA Numeric ID': numericGameId || null, // Store numeric ID for optimized polling
              'Last Updated': admin.firestore.FieldValue.serverTimestamp(),
              'source': 'NCAA_LIVE',
              'period': currentPeriod || '',
              'displayClock': contestClock,
              'Current Period': currentPeriod,
              'displayTime': displayTime, // Formatted time: period/clock when in progress, start time otherwise
              'Home Team Ranking': homeTeamRanking,
              'Away Team Ranking': awayTeamRanking
            };
            
            // Check for duplicates before adding
            if (!uniqueGames.has(gameKey)) {
              uniqueGames.add(gameKey);
              allGames.push(gameData);
            } else {
              console.log(`[NCAA API] Skipping duplicate NCAAM game: ${awayTeamName} vs ${homeTeamName} on ${gameDateForStorage}`);
            }
          }
            console.log(`[NCAA API] NCAAM (${isoDate}): Found ${ncaamData.games.length} games`);
          }
        }
      } catch (err) {
        console.error(`[NCAA API] Error fetching NCAAM for ${isoDate}:`, err.message);
      }
    }
    
    // Fetch NCAAW for each date
    for (const dateInfo of datesForNCAA) {
      const { isoDate } = dateInfo;
      const ncaaDate = DateTime.fromISO(isoDate).toFormat('yyyy/MM/dd');
      console.log(`[NCAA API] Fetching NCAAW for ${isoDate}...`);
      
      try {
        const ncaawUrl = `https://ncaa-api.henrygd.me/scoreboard/basketball-women/d1/${ncaaDate}`;
        const ncaawResponse = await fetch(ncaawUrl, {
          headers: { 'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36' }
        });
        if (ncaawResponse.ok) {
          const ncaawData = await ncaawResponse.json();
          if (ncaawData.games && Array.isArray(ncaawData.games)) {
            // OPTIMIZATION: If we have games to poll, create a set of game IDs to filter
            const gamesToPollIds = new Set();
            if (ncaaGamesToPollForProcessing && ncaaGamesToPollForProcessing.length > 0) {
              for (const { gameId } of ncaaGamesToPollForProcessing) {
                // Extract the actual game ID from stored format (e.g., "ncaa-ncaaw-12345" -> "12345")
                const match = gameId.match(/^ncaa-ncaaw-(.+)$/);
                if (match) {
                  gamesToPollIds.add(match[1]);
                }
                // Also add the full gameId for matching
                gamesToPollIds.add(gameId);
              }
            }
            
            for (const gameItem of ncaawData.games) {
              const game = gameItem.game;
              if (!game) continue;
              
              // OPTIMIZATION: If we have games to poll, skip games not in our list
              if (gamesToPollIds.size > 0) {
                const gameIdFromAPI = game.id ? `ncaa-ncaaw-${game.id}` : null;
                if (!gameIdFromAPI || !gamesToPollIds.has(gameIdFromAPI) && !gamesToPollIds.has(game.id)) {
                  continue; // Skip games not in our polling list
                }
              }
              
              const awayTeam = game.away;
              const homeTeam = game.home;
              if (!awayTeam || !homeTeam) continue;
              
              const awayTeamName = awayTeam.names?.short || awayTeam.names?.full || awayTeam.names?.seo || '';
              const homeTeamName = homeTeam.names?.short || homeTeam.names?.full || homeTeam.names?.seo || '';
              if (!awayTeamName || !homeTeamName) continue;
              
              const awayScore = awayTeam.score || '';
              const homeScore = homeTeam.score || '';
              const gameState = (game.gameState || '').toUpperCase();
              const finalMessage = (game.finalMessage || '').toUpperCase();
              const currentPeriod = game.currentPeriod || '';
              const startTimeEpochSeconds = game.startTimeEpoch ? Number(game.startTimeEpoch) : null;
              const startTimeMillis = Number.isFinite(startTimeEpochSeconds) ? startTimeEpochSeconds * 1000 : null;
              
              // Get the game's actual start date by converting the start time from UTC to Eastern Time
              // NCAA API provides epoch seconds (UTC). Convert to Eastern Time, then extract the date
              if (!startTimeMillis) continue; // Skip if no start time
              const gameDateForStorage = DateTime
                .fromMillis(startTimeMillis, { zone: 'utc' })
                .setZone('America/New_York')
                .toISODate();
              
              // Convert the date we're fetching (Mountain Time) to Eastern Time for comparison
              // This ensures we only include games that match the date we're fetching
              const isoDateMountain = DateTime.fromISO(isoDate, { zone: 'America/Denver' });
              const isoDateEastern = isoDateMountain.setZone('America/New_York').toISODate();
              
              // Only include games that match the date we're fetching (after conversion to Eastern Time)
              // This prevents games from other dates from being stored with the wrong date
              if (gameDateForStorage !== isoDateEastern) {
                continue; // Skip games that don't match the date we're fetching
              }
              
              let matchStatus = 'SCHEDULED';
              if (finalMessage === 'FINAL' || gameState === 'FINAL') {
                matchStatus = 'FINAL';
              } else if (gameState.includes('LIVE') || gameState.includes('IN_PROGRESS') || homeScore > 0 || awayScore > 0) {
                if (!finalMessage.includes('FINAL') && !gameState.includes('FINAL')) {
                  matchStatus = 'IN PROGRESS';
                }
              }
            
            // Format display time: show period/clock when in progress, start time otherwise
            const contestClock = game.contestClock || '';
            let displayTime = '';
            
            if (matchStatus === 'IN PROGRESS' && (currentPeriod || contestClock)) {
              // Check for halftime (2nd period with 0.0 or 0:00 clock)
              const periodNum = currentPeriod ? (parseInt(currentPeriod) || (currentPeriod.includes('2') ? 2 : null)) : null;
              const isHalftime = (periodNum === 2 && 
                                  (contestClock === '0.0' || contestClock === '0:00' || contestClock === '0' || contestClock === ''));
              
              if (isHalftime) {
                displayTime = 'Half';
              } else {
                // currentPeriod might already be formatted (e.g., "2nd") or just a number
                let periodStr = currentPeriod || '';
                
                // If period is just a number, format it (e.g., "2" -> "2nd")
                if (periodStr && /^\d+$/.test(periodStr)) {
                  const periodNum = parseInt(periodStr);
                  if (periodNum === 1) periodStr = '1st';
                  else if (periodNum === 2) periodStr = '2nd';
                  else if (periodNum === 3) periodStr = '3rd';
                  else if (periodNum === 4) periodStr = '4th';
                  else if (periodNum > 4) periodStr = `${periodNum}th`;
                }
                
                // Combine period and clock (e.g., "2nd 8:03")
                if (periodStr && contestClock) {
                  displayTime = `${periodStr} ${contestClock}`;
                } else if (periodStr) {
                  displayTime = periodStr;
                } else if (contestClock) {
                  displayTime = contestClock;
                }
              }
            }
            
            // If not in progress, format start time for display
            if (!displayTime && startTimeMillis) {
              const startTimeMountain = DateTime.fromMillis(startTimeMillis).setZone('America/Denver');
              displayTime = startTimeMountain.toFormat('h:mm a');
            } else if (!displayTime) {
              displayTime = '';
            }
            
            // Map NCAA league name to display name (matching what importGamesFromSheets uses)
            const leagueDisplayName = ESPN_LEAGUE_DISPLAY_NAME_MAP['NCAAW'] || 'USA: NCAA Women';
            
            // Get rankings for teams
            const homeTeamRanking = getTeamRanking(homeTeamName, ncaawRankings);
            const awayTeamRanking = getTeamRanking(awayTeamName, ncaawRankings);
            
            // IMPORTANT: Preserve existing channel data if game is not FINAL
            // Only FINAL games should have empty channel; SCHEDULED and IN PROGRESS games must always display channel
            // NCAA API doesn't provide channel data, so we only clear it for FINAL games
            // Otherwise, merge will preserve existing channel data from Google Sheets
            const shouldClearChannel = matchStatus === 'FINAL';
            
            // Calculate canonicalGameKey for deduplication (same as ESPN games)
            const gameKey = getGameKey(leagueDisplayName, homeTeamName, awayTeamName, gameDateForStorage);
            
            const gameData = {
              'League': leagueDisplayName, // Use display name for consistency with importGamesFromSheets
              'Sport': 'Basketball',
              'Home Team': homeTeamName,
              'Away Team': awayTeamName,
              'Home Score': homeScore.toString(),
              'Away Score': awayScore.toString(),
              'Match Status': matchStatus,
              // Only clear channel if game is FINAL, otherwise preserve existing channel via merge
              ...(shouldClearChannel && { 'Channel': '', 'channel': '' }),
              'Start Time': startTimeMillis ? admin.firestore.Timestamp.fromMillis(startTimeMillis) : admin.firestore.Timestamp.now(),
              'gameDate': gameDateForStorage,
              'Matchup': `${awayTeamName} vs ${homeTeamName}`,
              'Game ID': game.id 
                ? `ncaa-ncaaw-${game.id}`
                : generateDeterministicGameId('ncaa-ncaaw', 'NCAAW', homeTeamName, awayTeamName, gameDateForStorage),
              'canonicalGameKey': gameKey, // Add canonicalGameKey for deduplication (matches ESPN games pattern)
              'Last Updated': admin.firestore.FieldValue.serverTimestamp(),
              'source': 'NCAA_LIVE',
              'period': currentPeriod || '',
              'displayClock': contestClock,
              'Current Period': currentPeriod,
              'displayTime': displayTime, // Formatted time: period/clock when in progress, start time otherwise
              'Home Team Ranking': homeTeamRanking,
              'Away Team Ranking': awayTeamRanking
            };
            
              // Check for duplicates before adding
              if (!uniqueGames.has(gameKey)) {
                uniqueGames.add(gameKey);
                allGames.push(gameData);
              } else {
                console.log(`[NCAA API] Skipping duplicate NCAAW game: ${awayTeamName} vs ${homeTeamName} on ${gameDateForStorage}`);
              }
            }
            console.log(`[NCAA API] NCAAW (${isoDate}): Found ${ncaawData.games.length} games`);
          }
        }
      } catch (err) {
        console.error(`[NCAA API] Error fetching NCAAW for ${isoDate}:`, err.message);
      }
    }
    
    console.log(`[ESPN Live Data] Total games fetched: ${allGames.length}`);
    
    // Fetch channel data from Google Sheets and override ESPN/NCAA channel data
    console.log('[Channel Lookup] Fetching channel data from Google Sheets...');
    await authenticateGoogleSheets();
    
    // League to sheet mapping (from importGamesFromSheets)
    const LEAGUE_SHEET_MAP = {
      'NFL': { sheetId: SHEET_ID, sheetName: 'NFL' },
      'NBA': { sheetId: SHEET_ID, sheetName: 'NBA' },
      'MLB': { sheetId: SHEET_ID, sheetName: 'MLB' },
      'Premier League': { sheetId: SHEET_ID, sheetName: 'PremierLeague' },
      'MLS': { sheetId: SHEET_ID, sheetName: 'MLS' },
      'La Liga': { sheetId: SHEET_ID, sheetName: 'LaLiga' },
      'Bundesliga': { sheetId: SHEET_ID, sheetName: 'Bundesliga' },
      'Serie A': { sheetId: SHEET_ID, sheetName: 'SerieA' },
      'Ligue 1': { sheetId: SHEET_ID, sheetName: 'Ligue1' },
      'UEFA Champions League': { sheetId: SHEET_ID, sheetName: 'UEFAChampionsLeague' },
      'UEFA Europa League': { sheetId: SHEET_ID, sheetName: 'UEFAEuropaLeague' },
      'UEFA Conference League': { sheetId: SHEET_ID, sheetName: 'UEFAConferenceLeague' },
      'DFB-Pokal': { sheetId: SHEET_ID_2, sheetName: 'DFBPokal' },
      'Germany: DFB-Pokal': { sheetId: SHEET_ID_2, sheetName: 'DFBPokal' },
      'Germany: DFB Pokal': { sheetId: SHEET_ID_2, sheetName: 'DFBPokal' },
      'DFBPokal': { sheetId: SHEET_ID_2, sheetName: 'DFBPokal' },
      'NCAAF': { sheetId: SHEET_ID, sheetName: 'NCAAF' },
      'NHL': { sheetId: SHEET_ID, sheetName: 'NHL' },
      'WNBA': { sheetId: SHEET_ID, sheetName: 'WNBA' },
      'NCAAM': { sheetId: SHEET_ID_3, sheetName: 'NCAAM' },
      'NCAAW': { sheetId: SHEET_ID_3, sheetName: 'NCAAW' }
    };
    
    // Normalize team name for matching
    function normalizeTeamName(name) {
      if (!name) return '';
      return name
        .toLowerCase()
        .normalize('NFD')
        .replace(/[\u0300-\u036f]/g, '')
        .replace(/[^\w\s]/g, '')
        .replace(/\s+/g, ' ')
        .trim();
    }
    
    // Build channel map from Google Sheets
    const channelMap = new Map(); // Key: "league|normalizedHome|normalizedAway|date", Value: channel
    
    // Exclude NCAAF, NCAAM, NCAAW from channel lookup since they're fetched from ESPN/NCAA APIs
    const LEAGUES_TO_EXCLUDE_FROM_CHANNEL_LOOKUP = ['NCAAF', 'NCAAM', 'NCAAW'];
    
    for (const [leagueName, sheetInfo] of Object.entries(LEAGUE_SHEET_MAP)) {
      // Skip leagues that are fetched from APIs to avoid duplicates
      if (LEAGUES_TO_EXCLUDE_FROM_CHANNEL_LOOKUP.includes(leagueName)) {
        continue;
      }
      try {
        // Rate limiting is now handled via rateLimitedSheetRequest
        const range = `${sheetInfo.sheetName}!A:Z`;
        const response = await rateLimitedSheetRequest(() =>
          sheets.spreadsheets.values.get({
            spreadsheetId: sheetInfo.sheetId,
            range: range
          })
        );
        
        const rows = response.data.values || [];
        if (rows.length < 2) continue; // Need at least header + 1 row
        
        // Find column indices
        const headerRow = rows[0];
        const dateCol = headerRow.findIndex(col => col && col.toString().toLowerCase().includes('date'));
        const timeCol = headerRow.findIndex(col => col && col.toString().toLowerCase().includes('time'));
        const homeCol = headerRow.findIndex(col => col && col.toString().toLowerCase().includes('home') && col.toString().toLowerCase().includes('team'));
        const awayCol = headerRow.findIndex(col => col && col.toString().toLowerCase().includes('away') && col.toString().toLowerCase().includes('team'));
        const channelCol = headerRow.findIndex(col => col && col.toString().toLowerCase().includes('channel'));
        
        if (dateCol === -1 || homeCol === -1 || awayCol === -1 || channelCol === -1) continue;
        
        // Process rows
        for (let i = 1; i < rows.length; i++) {
          const row = rows[i];
          if (!row || row.length === 0) continue;
          
          const dateStr = row[dateCol] ? String(row[dateCol]).trim() : '';
          const homeTeam = row[homeCol] ? String(row[homeCol]).trim() : '';
          const awayTeam = row[awayCol] ? String(row[awayCol]).trim() : '';
          const channel = row[channelCol] ? String(row[channelCol]).trim() : '';
          
          if (!dateStr || !homeTeam || !awayTeam || !channel) continue;
          
          // Parse date - handle various formats
          let parsedDate = null;
          if (dateStr.includes('/')) {
            // Format: MM/DD/YYYY or M/D/YYYY
            const parts = dateStr.split('/');
            if (parts.length === 3) {
              const month = parseInt(parts[0], 10);
              const day = parseInt(parts[1], 10);
              const year = parseInt(parts[2], 10);
              if (month && day && year) {
                parsedDate = DateTime.fromObject({ year, month, day }, { zone: 'America/Denver' });
              }
            }
          } else if (dateStr.match(/^\d{4}-\d{2}-\d{2}$/)) {
            // Format: YYYY-MM-DD
            parsedDate = DateTime.fromISO(dateStr, { zone: 'America/Denver' });
          }
          
          if (!parsedDate || !parsedDate.isValid) continue;
          const rowDateStr = parsedDate.toISODate();
          
          // Only process rows matching today's date
          if (rowDateStr !== todayStr) continue;
          
          const normalizedHome = normalizeTeamName(homeTeam);
          const normalizedAway = normalizeTeamName(awayTeam);
          
          // Create keys for both possible orders (home/away and away/home)
          const key1 = `${leagueName}|${normalizedHome}|${normalizedAway}|${rowDateStr}`;
          const key2 = `${leagueName}|${normalizedAway}|${normalizedHome}|${rowDateStr}`;
          channelMap.set(key1, channel);
          channelMap.set(key2, channel);
        }
        
        console.log(`[Channel Lookup] Processed ${sheetInfo.sheetName} sheet`);
      } catch (err) {
        console.error(`[Channel Lookup] Error processing ${leagueName}:`, err.message);
      }
    }
    
    console.log(`[Channel Lookup] Built channel map with ${channelMap.size} entries`);
    
    // Override channel data in games with Google Sheets data
    let channelOverrideCount = 0;
    for (const game of allGames) {
      const league = game.League || '';
      const homeTeam = game['Home Team'] || '';
      const awayTeam = game['Away Team'] || '';
      const normalizedHome = normalizeTeamName(homeTeam);
      const normalizedAway = normalizeTeamName(awayTeam);
      
      // Try to find channel in map
      const key = `${league}|${normalizedHome}|${normalizedAway}|${todayStr}`;
      const sheetChannel = channelMap.get(key);
      
      if (sheetChannel) {
        game.Channel = sheetChannel;
        game.channel = sheetChannel;
        channelOverrideCount++;
      }
      // If not found, keep ESPN/NCAA channel data (already set above)
    }
    
    console.log(`[Channel Lookup] Overrode ${channelOverrideCount} games with Google Sheets channel data`);
    
    // Step 3: On morning run, also import Google Sheets games (excluding ESPN/NCAA leagues) to sportsGames
    if (isMorningRun) {
      console.log('[ESPN Live Data] Morning run - importing Google Sheets games (excluding ESPN/NCAA leagues)...');
      const manualGames = await fetchManualGamesFromSheets(todayStr, tomorrowStr);
      // Add manual games to allGames (they're already filtered to exclude ESPN/NCAA leagues)
      allGames.push(...manualGames);
      console.log(`[ESPN Live Data] Added ${manualGames.length} manual games from Google Sheets to sportsGames`);
    }
    
    // Log total games fetched
    console.log(`[ESPN Live Data] Total games fetched: ${allGames.length} (ESPN/NCAA: ${allGames.length - (isMorningRun ? (allGames.filter(g => g.source === 'MANUAL').length) : 0)}, Manual: ${isMorningRun ? allGames.filter(g => g.source === 'MANUAL').length : 0})`);
    
    if (allGames.length === 0) {
      console.warn(`[ESPN Live Data] ‚ö†Ô∏è WARNING: No games fetched! Collection will not be created.`);
      if (res) {
        return res.status(200).json({
          success: true,
          message: 'No games found for today',
          gamesFetched: 0,
          gamesWritten: 0
        });
      }
      return;
    }
    
    // Step 4: Filter games based on run type
    // OPTIMIZATION: For polling runs, reuse the live games snapshots from early exit check (avoid redundant queries)
    let existingGamesSnapshot;
    if (isMorningRun) {
      // Morning run: read all today's games (needed for initial population)
      existingGamesSnapshot = await gamesRef.where('gameDate', '==', todayStr).get();
    } else {
      // Polling run: REUSE the snapshots from early exit check (already queried at lines 3263-3290)
      // This avoids redundant Firestore reads!
      if (!preFetchLiveGamesSnapshot || !preFetchYesterdayFinalSnapshot || !preFetchUpcomingGamesSnapshot) {
        // Fallback: if for some reason pre-fetch snapshots don't exist, query now
        // This can happen if we somehow skipped the early exit check, or if variables weren't set
        console.warn('[ESPN Live Data] Pre-fetch snapshots not found, querying now (fallback)');
        const liveGamesQuery = gamesRef
          .where('gameDate', '==', todayStr)
          .where('Match Status', 'in', ['IN PROGRESS', 'LIVE', 'FINAL', 'FINISHED']);
        
        const yesterdayFinalQuery = gamesRef
          .where('gameDate', '==', yesterdayStr)
          .where('Match Status', 'in', ['FINAL', 'FINISHED']);
        
        const nowTimestamp = admin.firestore.Timestamp.fromMillis(nowInMountain.toMillis());
        const twoHoursFromNow = admin.firestore.Timestamp.fromMillis(nowInMountain.plus({ hours: 2 }).toMillis());
        
        const upcomingGamesQuery = gamesRef
          .where('gameDate', '==', todayStr)
          .where('Match Status', '==', 'SCHEDULED')
          .where('Start Time', '>=', nowTimestamp)
          .where('Start Time', '<=', twoHoursFromNow);
        
        const [liveGamesSnapshot, yesterdayFinalSnapshot, upcomingGamesSnapshot] = await Promise.all([
          liveGamesQuery.get(),
          yesterdayFinalQuery.get(),
          upcomingGamesQuery.get()
        ]);
        
        existingGamesSnapshot = {
          empty: liveGamesSnapshot.empty && yesterdayFinalSnapshot.empty && upcomingGamesSnapshot.empty,
          forEach: (callback) => {
            liveGamesSnapshot.forEach(callback);
            yesterdayFinalSnapshot.forEach(callback);
            upcomingGamesSnapshot.forEach(callback);
          },
          size: liveGamesSnapshot.size + yesterdayFinalSnapshot.size + upcomingGamesSnapshot.size,
          docs: [...liveGamesSnapshot.docs, ...yesterdayFinalSnapshot.docs, ...upcomingGamesSnapshot.docs]
        };
      } else {
        // Reuse the snapshots from early exit check (already queried, no additional reads!)
        existingGamesSnapshot = {
          empty: preFetchLiveGamesSnapshot.empty && preFetchYesterdayFinalSnapshot.empty && preFetchUpcomingGamesSnapshot.empty,
          forEach: (callback) => {
            preFetchLiveGamesSnapshot.forEach(callback);
            preFetchYesterdayFinalSnapshot.forEach(callback);
            preFetchUpcomingGamesSnapshot.forEach(callback);
          },
          size: preFetchLiveGamesSnapshot.size + preFetchYesterdayFinalSnapshot.size + preFetchUpcomingGamesSnapshot.size,
          docs: [...preFetchLiveGamesSnapshot.docs, ...preFetchYesterdayFinalSnapshot.docs, ...preFetchUpcomingGamesSnapshot.docs]
        };
        
        console.log(`[ESPN Live Data] Polling run - reused pre-fetch snapshots (0 additional reads!): ${existingGamesSnapshot.size} games`);
      }
    }
    
    const existingGamesMap = new Map();
    existingGamesSnapshot.forEach(doc => {
      const data = doc.data();
      const gameId = data['Game ID'] || doc.id;
      existingGamesMap.set(gameId, data);
    });
    
    // Filter games based on run type:
    // - Morning run: include all games (scheduled + in progress + final) for all 7 days
    // - Polling run: include games that are IN PROGRESS or FINAL (to update scores and finalize games)
    //   Also include scheduled games for today that might have just started (to discover new live games)
    const gamesToUpdate = isMorningRun 
      ? allGames // Morning run: include all games for all 7 days
      : allGames.filter(game => {
          const matchStatus = (game['Match Status'] || '').toUpperCase();
          const gameDate = game.gameDate || todayStr;
          
          // Always include FINAL games (to update final scores and ensure they're marked final)
          const isFinal = matchStatus.includes('FINAL') || matchStatus.includes('FINISHED');
          if (isFinal && (gameDate === todayStr || gameDate === yesterdayStr)) {
            return true;
          }
          
          // Include games that are IN PROGRESS
          const isLive = matchStatus.includes('IN PROGRESS') || 
                         matchStatus.includes('LIVE') ||
                         (game.StageType || '').toUpperCase().includes('LIVE') ||
                         (game.Stage || '').toUpperCase().includes('LIVE');
          
          if (isLive) return true;
          
          // Include games that appear to be live (has active clock, scores, etc.)
          const hasClock = game.displayClock || game.displayTime || game.GameTime;
          const hasActiveClock = hasClock && !['0', '0:00', '0.0', 'NULL', ''].includes(String(hasClock).trim().toUpperCase());
          const hasScores = (game['Home Score'] && parseInt(game['Home Score']) > 0) || 
                           (game['Away Score'] && parseInt(game['Away Score']) > 0);
          
          // Include if appears to be live (has clock/scores but not FINAL) for today or yesterday
          if ((hasActiveClock || hasScores) && !isFinal && (gameDate === todayStr || gameDate === yesterdayStr)) {
            return true;
          }
          
          // Skip scheduled games and other non-live games during polling
          return false;
        });
    
    console.log(`[ESPN Live Data] ${isMorningRun ? 'Morning run' : 'Polling run'}: ${gamesToUpdate.length} games to update (${allGames.length - gamesToUpdate.length} finished games skipped)`);
    
    if (gamesToUpdate.length === 0) {
      console.warn(`[ESPN Live Data] ‚ö†Ô∏è WARNING: No games to update! Collection will not be created.`);
      if (res) {
        return res.status(200).json({
          success: true,
          message: 'No games to update',
          gamesFetched: allGames.length,
          gamesWritten: 0
        });
      }
      return;
    }
    
    // Incremental write logic: only write additions, changes, and deletions
    // OPTIMIZATION: For polling runs, only check dates that have live games (reuse existingGamesSnapshot)
    const datesToCheckForDeletions = leaguesAndDatesToFetch.map(d => d.isoDate);
    console.log(`[ESPN Live Data] Checking for deletions in dates: ${datesToCheckForDeletions.join(', ')}`);
    
    const existingGamesForDates = new Map();
    if (isMorningRun) {
      // Morning run: check all dates being fetched (needed for full deletion check)
      for (const dateStr of datesToCheckForDeletions) {
        const dateSnapshot = await gamesRef.where('gameDate', '==', dateStr).get();
        dateSnapshot.forEach(doc => {
          const data = doc.data();
          const gameId = data['Game ID'] || doc.id;
          existingGamesForDates.set(gameId, { docId: doc.id, data: data });
        });
      }
    } else {
      // Polling run: reuse existingGamesSnapshot (already contains live/final games)
      // This avoids redundant Firestore reads - we already have the games we need
      existingGamesSnapshot.forEach(doc => {
        const data = doc.data();
        const gameId = data['Game ID'] || doc.id;
        existingGamesForDates.set(gameId, { docId: doc.id, data: data });
      });
      console.log(`[ESPN Live Data] Polling run - using existing live games snapshot for deletions check: ${existingGamesForDates.size} games (optimized from querying all dates)`);
    }
    
    console.log(`[ESPN Live Data] Found ${existingGamesForDates.size} existing games in database for dates being fetched`);
    
    // Create a map of fetched games by Game ID and a canonical map by canonicalGameKey
    const fetchedGamesMap = new Map();
    const fetchedCanonicalMap = new Map();
    for (const game of gamesToUpdate) {
      if (game['Game ID']) {
        fetchedGamesMap.set(String(game['Game ID']), game);
      }
      const canonical = game['canonicalGameKey'] || '';
      if (canonical) {
        fetchedCanonicalMap.set(canonical, String(game['Game ID'] || ''));
      }
    }
    
    // Determine what to write/delete
    const gamesToWrite = [];
    const gamesToDelete = [];
    
    // Build a canonical lookup for existing games (canonicalKey -> {docId, gameId})
    const existingCanonicalMap = new Map();
    for (const [gameId, existing] of existingGamesForDates.entries()) {
      const canonical = existing.data && existing.data.canonicalGameKey ? existing.data.canonicalGameKey : '';
      if (canonical) existingCanonicalMap.set(canonical, { docId: existing.docId, gameId });
    }

    // Find games to write (new or changed) ‚Äî try exact Game ID first, then canonical key
    for (const game of gamesToUpdate) {
      if (!game['Game ID']) {
        console.warn(`[ESPN Live Data] Skipping game without Game ID:`, game['Matchup'] || 'Unknown');
        continue;
      }

      const gameId = String(game['Game ID']);
      let existing = existingGamesForDates.get(gameId);

      // If we don't have an exact Game ID match, try canonical key match
      if (!existing) {
        const canonical = game['canonicalGameKey'] || '';
        if (canonical && existingCanonicalMap.has(canonical)) {
          const match = existingCanonicalMap.get(canonical);
          existing = existingGamesForDates.get(match.gameId);
          // Ensure the fetched game will update the same Game ID/document
          if (match && match.gameId) {
            game['Game ID'] = match.gameId;
          }
          gamesToWrite.push({ game, reason: 'mergedByCanonical' });
          continue;
        }
      }

      if (!existing) {
        // New game - write it
        gamesToWrite.push({ game, reason: 'new' });
        continue;
      }

      // Existing game - check if changed
      const existingData = existing.data;
      const existingGameDate = existingData['gameDate'];
      const newGameDate = game['gameDate'];
        // Always use the earlier gameDate (preserve existing if earlier, or use new if earlier)
        // This prevents games from being moved to later dates when they appear on multiple scoreboards
        // and corrects games that were stored with dates that are too late
        if (existingGameDate && newGameDate) {
          game['gameDate'] = existingGameDate < newGameDate ? existingGameDate : newGameDate;
        }
        
        // Consider these fields when deciding whether a game changed
        const changedFields = (
          existingData['Home Score'] !== game['Home Score'] ||
          existingData['Away Score'] !== game['Away Score'] ||
          existingData['Match Status'] !== game['Match Status'] ||
          existingData['Channel'] !== game['Channel'] ||
          existingData['displayClock'] !== game['displayClock'] ||
          existingData['displayTime'] !== game['displayTime'] ||
          existingData['GameTime'] !== game['GameTime'] ||
          existingData['period'] !== game['period'] ||
          existingData['Stage'] !== game['Stage'] ||
          existingData['Start Time']?.toMillis() !== game['Start Time']?.toMillis() ||
          existingData['gameDate'] !== game['gameDate']
        );

        // Only write if data actually changed (no heartbeat writes needed since we're using JSON endpoints)
        if (changedFields) {
          // Preserve user-set POSTPONED/PPD/CANCELED: do not overwrite with API status (e.g. FINAL) when polling runs
          const existingStatusNorm = String(existingData['Match Status'] || '').toUpperCase().trim();
          if (existingStatusNorm === 'POSTPONED' || existingStatusNorm === 'PPD' || existingStatusNorm === 'CANCELED') {
            // Skip write entirely so PPD/postponed stays
          } else {
            gamesToWrite.push({ game, reason: 'changed' });
          }
        }
        // If unchanged, skip it (no write needed)
      }
    
    // Find games to delete (exist in DB but not in fetched data)
    for (const [gameId, existing] of existingGamesForDates.entries()) {
      const canonical = existing.data && existing.data.canonicalGameKey ? existing.data.canonicalGameKey : '';
      // If fetchedGamesMap doesn't have this gameId and canonical isn't present in fetchedCanonicalMap, consider delete
      const presentById = fetchedGamesMap.has(gameId);
      const presentByCanonical = canonical && fetchedCanonicalMap.has(canonical);

      if (!presentById && !presentByCanonical) {
        // During polling runs, preserve FINAL, SCHEDULED, POSTPONED, PPD, and CANCELED games (don't delete them even if not fetched)
        if (!isMorningRun) {
          const existingStatus = (existing.data['Match Status'] || '').toUpperCase();
          const isExistingFinal = existingStatus.includes('FINAL') || existingStatus.includes('FINISHED') || existingStatus.includes('GAME OVER');
          const isExistingScheduled = !isExistingFinal && !existingStatus.includes('IN PROGRESS') && !existingStatus.includes('LIVE');
          const isExistingPostponedOrCanceled = existingStatus.includes('POSTPONED') || existingStatus.includes('PPD') || existingStatus.includes('CANCELED');

          if (isExistingFinal || isExistingScheduled || isExistingPostponedOrCanceled) {
            continue; // Skip deletion of FINAL, SCHEDULED, POSTPONED, and CANCELED games during polling runs
          }
        }

        // Game exists in DB but not in fetched data - delete it
        gamesToDelete.push({ docId: existing.docId, gameId, gameDate: existing.data.gameDate });
      }
    }
    
    const skipCount = existingGamesForDates.size - gamesToWrite.length - gamesToDelete.length; // Unchanged games
    console.log(`[ESPN Live Data] Incremental update: ${gamesToWrite.length} to write (${gamesToWrite.filter(g => g.reason === 'new').length} new, ${gamesToWrite.filter(g => g.reason === 'changed').length} changed), ${gamesToDelete.length} to delete, ${skipCount} unchanged`);
    
    // Write additions and changes
    let writeCount = 0;
    let deleteCount = 0;
    const BATCH_SIZE = 500;
    // DRY_RUN disabled intentionally during debugging/deployment: force real writes
    const isDryRun = false;
    
    // Write games in batches
    for (let i = 0; i < gamesToWrite.length; i += BATCH_SIZE) {
      const batch = db.batch();
      const batchGames = gamesToWrite.slice(i, i + BATCH_SIZE);
      
      for (const { game } of batchGames) {
        const docRef = gamesRef.doc(String(game['Game ID']));
        batch.set(docRef, game, { merge: true });
      }
      
      if (batchGames.length > 0) {
        try {
          if (isDryRun) {
            writeCount += batchGames.length;
            console.log(`[ESPN Live Data] [DRY RUN] Would commit write batch: ${batchGames.length} games (total would-write: ${writeCount})`);
          } else {
            await batch.commit();
            writeCount += batchGames.length;
            console.log(`[ESPN Live Data] ‚úÖ Committed write batch: ${batchGames.length} games (total written: ${writeCount})`);
          }
        } catch (err) {
          console.error(`[ESPN Live Data] ‚ùå Batch commit failed:`, err.message);
          throw err;
        }
      }
    }
    
    // Delete games that no longer exist in fetched data
    for (let i = 0; i < gamesToDelete.length; i += BATCH_SIZE) {
      const batch = db.batch();
      const batchDeletes = gamesToDelete.slice(i, i + BATCH_SIZE);
      
      for (const { docId } of batchDeletes) {
        const docRef = gamesRef.doc(docId);
        batch.delete(docRef);
      }
      
      if (batchDeletes.length > 0) {
        try {
          if (isDryRun) {
            deleteCount += batchDeletes.length;
            console.log(`[ESPN Live Data] [DRY RUN] Would commit delete batch: ${batchDeletes.length} games (total would-delete: ${deleteCount})`);
          } else {
            await batch.commit();
            deleteCount += batchDeletes.length;
            console.log(`[ESPN Live Data] ‚úÖ Committed delete batch: ${batchDeletes.length} games (total deleted: ${deleteCount})`);
          }
        } catch (err) {
          console.error(`[ESPN Live Data] ‚ùå Delete batch commit failed:`, err.message);
          throw err;
        }
      }
    }
    
    if (writeCount > 0 || deleteCount > 0) {
      console.log(`[ESPN Live Data] ‚úÖ Incremental update complete: ${writeCount} games written, ${deleteCount} games deleted`);
    } else {
      console.log(`[ESPN Live Data] ‚úÖ No changes detected - all games up to date`);
    }
    
    if (res) {
      res.status(200).json({
        success: true,
        message: 'ESPN live data polling complete',
        gamesFetched: allGames.length,
        gamesWritten: writeCount,
        gamesSkipped: skipCount
      });
    }
    
  } catch (err) {
    console.error('--- /pollESPNLiveData FAILED ---', err);
    if (res) {
      res.status(500).json({
        success: false,
        error: err.message
      });
    }
  }
};

app.post('/pollESPNLiveData', pollESPNLiveDataHandler);
app.get('/pollESPNLiveData', pollESPNLiveDataHandler);




// New endpoint for fetching weekly games
app.get('/fetchUpcomingGames', fetchUpcomingGamesHandler);
app.post('/fetchUpcomingGames', fetchUpcomingGamesHandler);




// Morning Refresh Handler - runs all scripts
const morningRefreshHandler = async (req, res) => {
  const executionId = `morning-${Date.now()}`;
  console.log(`\n${'='.repeat(70)}`);
  console.log(`üöÄ [${executionId}] Morning Refresh Started`);
  console.log(`‚è∞ Time: ${new Date().toISOString()}`);
  console.log('='.repeat(70));
  
  try {
    const results = { success: [], failed: [], startTime: new Date() };
    const { exec } = await import('child_process');
    const { promisify } = await import('util');
    const { fileURLToPath } = await import('url');
    const { dirname, join } = await import('path');
    const execPromise = promisify(exec);
    
    // Get the directory where index.js is located
    const __filename = fileURLToPath(import.meta.url);
    const __dirname = dirname(__filename);
    console.log(`üìÅ Working directory: ${__dirname}`);
    
    // 1. Run pollESPNLiveData first (morning mode)
    console.log('\nüîÑ [1/3] Running ESPN Live Data polling (morning mode)...');
    console.log('-'.repeat(70));
    try {
      const mockRes = {
        status: () => ({
          json: (data) => {
            console.log('üìä ESPN Live Data response:', JSON.stringify(data, null, 2));
          }
        })
      };
      await pollESPNLiveDataHandler({ query: { morning: 'true' } }, mockRes);
      results.success.push({ script: 'ESPN Live Data', details: 'Completed successfully' });
      console.log('‚úÖ [1/3] ESPN Live Data completed');
    } catch (error) {
      console.error('‚ùå [1/3] ESPN Live Data failed:', error.message);
      console.error('Stack:', error.stack);
      results.failed.push({ script: 'ESPN Live Data', error: error.message, stack: error.stack });
    }
    
    // Note: Featured games are now managed via perspectives-admin.html, not Google Sheets
    console.log('\nüìã [2/3] Skipping featured games import (managed via perspectives-admin.html)');
    results.success.push({ script: 'Featured Games', details: 'Skipped (managed via perspectives-admin.html)' });
    
    // 3. Run all stats scrapers - COMMENTED OUT FOR NOW
    // console.log('\nüìä [3/5] Running all stats scrapers...');
    // console.log('-'.repeat(70));
    // try {
    //   const { runAllStatsScrapers } = await import('./run-all-stats-scrapers.js');
    //   const statsResult = await runAllStatsScrapers();
    //   console.log('üìä Stats scrapers result:', JSON.stringify(statsResult, null, 2));
    //   results.success.push({ script: 'Stats Scrapers', details: statsResult || 'Completed' });
    //   console.log('‚úÖ [3/5] Stats scrapers completed');
    // } catch (error) {
    //   console.error('‚ùå [3/5] Stats scrapers failed:', error.message);
    //   console.error('Stack:', error.stack);
    //   results.failed.push({ script: 'Stats Scrapers', error: error.message, stack: error.stack });
    // }
    
    // 3. Move yesterday's games to yesterdayScores
    console.log('\nüìä [3/3] Moving yesterday\'s games to yesterdayScores...');
    console.log('-'.repeat(70));
    try {
      const moveResult = await moveYesterdayGamesToScores();
      results.success.push({ 
        script: 'Move Yesterday Games', 
        details: `Moved ${moveResult.moved} games to yesterdayScores` 
      });
      console.log('‚úÖ [3/3] Yesterday games moved successfully');
    } catch (error) {
      console.error('‚ùå [3/3] Move yesterday games failed:', error.message);
      console.error('Stack:', error.stack);
      results.failed.push({ script: 'Move Yesterday Games', error: error.message, stack: error.stack });
    }
    
    results.endTime = new Date();
    const duration = (results.endTime - results.startTime) / 1000;
    
    console.log('\n' + '='.repeat(70));
    console.log(`üìä [${executionId}] Morning Refresh Summary:`);
    console.log(`‚úÖ Success: ${results.success.length} scripts`);
    console.log(`‚ùå Failed: ${results.failed.length} scripts`);
    console.log(`‚è±Ô∏è  Duration: ${duration.toFixed(2)}s`);
    if (results.failed.length > 0) {
      console.log('\n‚ùå Failed Scripts:');
      results.failed.forEach(f => {
        console.log(`  - ${f.script}: ${f.error}`);
      });
    }
    console.log('='.repeat(70));
    
    res.status(200).json({
      message: 'Morning refresh completed',
      executionId,
      results,
      duration: `${duration.toFixed(2)}s`,
      timestamp: results.endTime.toISOString()
    });
  } catch (error) {
    console.error(`\nüí• [${executionId}] Fatal error in morning refresh:`, error);
    console.error('Stack:', error.stack);
    res.status(500).json({ 
      error: 'Morning refresh failed', 
      executionId,
      details: error.message,
      stack: error.stack,
      timestamp: new Date().toISOString()
    });
  }
};

app.post('/morningRefresh', morningRefreshHandler);
app.get('/morningRefresh', morningRefreshHandler);

// =================================================================
// PERSPECTIVES SYSTEM ENDPOINTS
// =================================================================

// Add manual social post to a game
const addManualPostHandler = async (req, res) => {
  try {
    const { gameId, url, priority = 50, sourceType = 'fan', addedBy = 'admin', notes = null, tags = ['manual'] } = req.body;
    
    if (!gameId || !url) {
      return res.status(400).json({ error: 'gameId and url are required' });
    }
    
    const { addManualPost, ensureGameSocialStructure } = await loadPerspectivesCore();
    
    // Ensure game has social structure
    await ensureGameSocialStructure(gameId);
    
    // Add the post
    const post = await addManualPost(gameId, url, {
      priority: parseInt(priority),
      sourceType,
      addedBy,
      notes,
      tags: Array.isArray(tags) ? tags : [tags]
    });
    
    res.status(200).json({
      success: true,
      message: 'Manual post added successfully',
      post
    });
  } catch (error) {
    console.error('Error adding manual post:', error);
    res.status(500).json({
      error: 'Failed to add manual post',
      details: error.message
    });
  }
};

// Get all social posts for a game
const getGameSocialPostsHandler = async (req, res) => {
  try {
    const { gameId } = req.query;

    if (!gameId) {
      return res.status(400).json({ error: 'gameId is required' });
    }

    const { getGameSocialPosts } = await loadPerspectivesCore();
    const posts = await getGameSocialPosts(gameId);

    res.status(200).json({
      success: true,
      gameId,
      posts,
      count: posts.length
    });
  } catch (error) {
    console.error('Error getting game social posts:', error);
    res.status(500).json({
      error: 'Failed to get game social posts',
      details: error.message
    });
  }
};

// Match a post to games (for automated ingestion)
const matchPostHandler = async (req, res) => {
  try {
    const { title, description, url, timestamp, league } = req.body;
    
    if (!title && !description) {
      return res.status(400).json({ error: 'title or description is required' });
    }
    
    const { matchPostToGames } = await loadPerspectivesCore();
    
    const post = {
      title,
      description,
      url: url || '',
      timestamp: timestamp || new Date().toISOString()
    };
    
    const matches = await matchPostToGames(post, league || null);
    
    res.status(200).json({
      success: true,
      matches,
      count: matches.length
    });
  } catch (error) {
    console.error('Error matching post to games:', error);
    res.status(500).json({
      error: 'Failed to match post to games',
      details: error.message
    });
  }
};

// Strip undefined from object so Firestore set() does not throw (Firestore rejects undefined values)
function stripUndefinedForFirestore(obj) {
  if (obj === null || typeof obj !== 'object') return obj;
  if (typeof obj.toDate === 'function') return obj; // Firestore Timestamp
  if (obj instanceof Date) return obj;
  if (Array.isArray(obj)) return obj.map(stripUndefinedForFirestore).filter(v => v !== undefined);
  const out = {};
  for (const [k, v] of Object.entries(obj)) {
    if (v === undefined) continue;
    out[k] = (v !== null && typeof v === 'object' && !(v instanceof Date) && typeof v.toDate !== 'function')
      ? stripUndefinedForFirestore(v) : v;
  }
  return out;
}

// Toggle featured status for a game
const toggleFeaturedHandler = async (req, res) => {
  try {
    const { gameId, gameDate, featured } = req.body;
    
    if (!gameId) {
      return res.status(400).json({ error: 'gameId is required' });
    }
    
    if (typeof featured !== 'boolean') {
      return res.status(400).json({ error: 'featured must be a boolean' });
    }
    
    // Compute gameDate if not provided; normalize to YYYY-MM-DD string (Firestore doc IDs cannot contain '/')
    let dateStr = gameDate != null ? String(gameDate).trim() : '';
    if (!dateStr) {
      const now = new Date();
      dateStr = now.toLocaleDateString('en-CA', { timeZone: 'America/New_York' });
    } else if (dateStr.includes('/')) {
      dateStr = dateStr.replace(/\//g, '-');
    }
    
    // Determine if this is a future date (compared to today in EST)
    const todayInEST = DateTime.now().setZone('America/New_York').toISODate();
    const isFutureDate = dateStr > todayInEST;
    
    const db = admin.firestore();
    const gamesRef = db.collection('artifacts/flashlive-daily-scraper/public/data/sportsGames');
    const futureGamesRef = db.collection('sportsGamesFuture');
    const featuredRef = db.collection('artifacts/flashlive-daily-scraper/public/data/Featured');
    
    const gameIdStr = String(gameId);
    const docId = `${dateStr}_${gameIdStr}`;
    const docRef = featuredRef.doc(docId);
    
    if (featured) {
      // Check if this is a url-only featured game (Game ID starts with "url-only-")
      let gameData;
      if (gameIdStr.startsWith('url-only-')) {
        const league = req.body.league || '';
        const home = req.body.home || '';
        const away = req.body.away || '';
        const url = req.body.url || '';
        const startTime = req.body.startTime || '';
        const endTime = req.body.endTime || '';
        const time = req.body.time || '';
        gameData = {
          'Game ID': gameIdStr,
          'Away Team': away,
          'Home Team': home,
          'League': league,
          'Sport': 'Other',
          'gameDate': dateStr,
          'Match Status': 'SCHEDULED',
          'isUrlOnlyFeatured': true,
          'isHardcodedToday': true,
          'urlOnlyFeaturedUrl': url,
          'hardcodedTodayUrl': url,
          'hardcodedStartTime': startTime,
          'hardcodedEndTime': endTime,
          'hardcodedTime': time,
          'time': time
        };
      } else if (gameIdStr.startsWith('hardcoded-')) {
        // Hardcoded game - get data from Hardcoded_Today_Schedules structure
        // Parse Game ID: hardcoded-{leagueKey}-{date}-{index}
        // Example: hardcoded-Tennis-2026-01-20-0
        // Need to handle date with dashes, so split and reconstruct
        const parts = gameIdStr.split('-');
        if (parts.length >= 6) {
          const leagueKey = parts[1]; // e.g., "Tennis"
          // Date is parts[2], parts[3], parts[4] (e.g., "2026", "01", "20")
          const gameDate = `${parts[2]}-${parts[3]}-${parts[4]}`; // e.g., "2026-01-20"
          const gameIndex = parseInt(parts[5]) || 0;
          
          // Hardcoded_Today_Schedules data structure (same as perspectives-admin.html)
          const Hardcoded_Today_Schedules = {

            'CFB': [
{ date: '2026-01-27', time: '7:00 pm', startTime: '19:00', endTime: '22:00', away: 'East-West', home: 'Shrine Bowl', channel: 'NFL Network', url: 'https://x.com/ShrineBowl' },

],

'TGL': [
  {
    date: '2026-02-09',
    time: '7:00 pm',
    startTime: '19:00',
    endTime: '21:00',
    away: 'The Bay',
    home: 'Los Angeles',
    channel: 'ESPN2',
    url: 'https://tglgolf.com/match/2026/108?webview=1'
  },
  {
    date: '2026-02-23',
    time: '5:00 pm',
    startTime: '17:00',
    endTime: '19:00',
    away: 'Atlanta',
    home: 'Boston',
    channel: 'ESPN2',
    url: 'https://tglgolf.com/match/2026/109?webview=1'
  },
  {
    date: '2026-02-23',
    time: '9:00 pm',
    startTime: '21:00',
    endTime: '23:00',
    away: 'Los Angeles',
    home: 'Atlanta',
    channel: 'ESPN2',
    url: 'https://tglgolf.com/match/2026/110?webview=1'
  },
  {
    date: '2026-02-24',
    time: '5:00 pm',
    startTime: '17:00',
    endTime: '19:00',
    away: 'New York',
    home: 'The Bay',
    channel: 'ESPN',
    url: 'https://tglgolf.com/match/2026/111?webview=1'
  },
  {
    date: '2026-02-24',
    time: '9:00 pm',
    startTime: '21:00',
    endTime: '23:00',
    away: 'Boston',
    home: 'New York',
    channel: 'ESPN',
    url: 'https://tglgolf.com/match/2026/112?webview=1'
  },
  {
    date: '2026-03-01',
    time: '9:00 pm',
    startTime: '21:00',
    endTime: '23:00',
    away: 'Jupiter',
    home: 'Boston',
    channel: 'ESPN',
    url: 'https://tglgolf.com/match/2026/113?webview=1'
  },
  {
    date: '2026-03-02',
    time: '7:00 pm',
    startTime: '19:00',
    endTime: '21:00',
    away: 'Los Angeles',
    home: 'New York',
    channel: 'ESPN2',
    url: 'https://tglgolf.com/match/2026/114?webview=1'
  },
  {
    date: '2026-03-03',
    time: '9:00 pm',
    startTime: '21:00',
    endTime: '23:00',
    away: 'The Bay',
    home: 'Jupiter',
    channel: 'ESPN',
    url: 'https://tglgolf.com/match/2026/115?webview=1'
  }
],

      
        'PGATour': [
          { date: '2026-01-22', time: '11:30 am', startTime: '11:30', endTime: '17:15', home: 'First Round', away: 'The AMEX', channel: 'ESPN+, GOLF', url: 'https://www.pgatour.com/leaderboard' },
          { date: '2026-01-23', time: '11:30 am', startTime: '11:30', endTime: '17:15', home: 'Second Round', away: 'The AMEX', channel: 'ESPN+, GOLF', url: 'https://www.pgatour.com/leaderboard' },
          { date: '2026-01-24', time: '11:30 am', startTime: '11:30', endTime: '17:30', home: 'Third Round', away: 'The AMEX', channel: 'ESPN+, GOLF', url: 'https://www.pgatour.com/leaderboard' },
          { date: '2026-01-25', time: '11:30 am', startTime: '11:30', endTime: '17:30', home: 'Final Round', away: 'The AMEX', channel: 'ESPN+, GOLF', url: 'https://www.pgatour.com/leaderboard' },
        
          { date: '2026-01-29', time: '3:00 pm', startTime: '15:00', endTime: '20:45', home: 'First Round', away: 'Farmers', channel: 'GOLF', url: 'https://www.pgatour.com/leaderboard' },
          { date: '2026-01-30', time: '3:00 pm', startTime: '15:00', endTime: '20:45', home: 'Second Round', away: 'Farmers', channel: 'GOLF', url: 'https://www.pgatour.com/leaderboard' },
          { date: '2026-01-31', time: '3:00 pm', startTime: '15:00', endTime: '21:00', home: 'Third Round', away: 'Farmers', channel: 'CBS', url: 'https://www.pgatour.com/leaderboard' },
          { date: '2026-02-01', time: '3:00 pm', startTime: '15:00', endTime: '21:00', home: 'Final Round', away: 'Farmers', channel: 'CBS', url: 'https://www.pgatour.com/leaderboard' },
        
          { date: '2026-02-05', time: '1:00 pm', startTime: '13:00', endTime: '18:45', home: 'First Round', away: 'Phoenix Open', channel: 'GOLF', url: 'https://www.pgatour.com/leaderboard' },
          { date: '2026-02-06', time: '1:00 pm', startTime: '13:00', endTime: '18:45', home: 'Second Round', away: 'Phoenix Open', channel: 'GOLF', url: 'https://www.pgatour.com/leaderboard' },
          { date: '2026-02-07', time: '1:00 pm', startTime: '13:00', endTime: '19:00', home: 'Third Round', away: 'Phoenix Open', channel: 'CBS', url: 'https://www.pgatour.com/leaderboard' },
          { date: '2026-02-08', time: '1:00 pm', startTime: '13:00', endTime: '19:00', home: 'Final Round', away: 'Phoenix Open', channel: 'CBS', url: 'https://www.pgatour.com/leaderboard' },
        
          { date: '2026-02-12', time: '12:00 pm', startTime: '12:00', endTime: '17:45', home: 'First Round', away: 'Pebble Beach', channel: 'GOLF', url: 'https://www.pgatour.com/leaderboard' },
          { date: '2026-02-13', time: '12:00 pm', startTime: '12:00', endTime: '17:45', home: 'Second Round', away: 'Pebble Beach', channel: 'GOLF', url: 'https://www.pgatour.com/leaderboard' },
          { date: '2026-02-14', time: '12:00 pm', startTime: '12:00', endTime: '18:00', home: 'Third Round', away: 'Pebble Beach', channel: 'CBS', url: 'https://www.pgatour.com/leaderboard' },
          { date: '2026-02-15', time: '12:00 pm', startTime: '12:00', endTime: '18:00', home: 'Final Round', away: 'Pebble Beach', channel: 'CBS', url: 'https://www.pgatour.com/leaderboard' },
        
          { date: '2026-02-19', time: '1:00 pm', startTime: '13:00', endTime: '18:45', home: 'First Round', away: 'Genesis', channel: 'GOLF', url: 'https://www.pgatour.com/leaderboard' },
          { date: '2026-02-20', time: '1:00 pm', startTime: '13:00', endTime: '18:45', home: 'Second Round', away: 'Genesis', channel: 'GOLF', url: 'https://www.pgatour.com/leaderboard' },
          { date: '2026-02-21', time: '12:00 pm', startTime: '12:00', endTime: '18:00', home: 'Third Round', away: 'Genesis', channel: 'CBS', url: 'https://www.pgatour.com/leaderboard' },
          { date: '2026-02-22', time: '12:00 pm', startTime: '12:00', endTime: '18:00', home: 'Final Round', away: 'Genesis', channel: 'CBS', url: 'https://www.pgatour.com/leaderboard' },
        
          { date: '2026-02-26', time: '', startTime: '', endTime: '', home: 'First Round', away: 'Cognizant', channel: 'GOLF', url: 'https://www.pgatour.com/leaderboard' },
          { date: '2026-02-27', time: '', startTime: '', endTime: '', home: 'Second Round', away: 'Cognizant', channel: 'GOLF', url: 'https://www.pgatour.com/leaderboard' },
          { date: '2026-02-28', time: '3:00 pm', startTime: '15:00', endTime: '21:00', home: 'Third Round', away: 'Cognizant', channel: 'NBC', url: 'https://www.pgatour.com/leaderboard' },
          { date: '2026-03-01', time: '3:00 pm', startTime: '15:00', endTime: '21:00', home: 'Final Round', away: 'Cognizant', channel: 'NBC', url: 'https://www.pgatour.com/leaderboard' },
        
          { date: '2026-03-05', time: '2:00 pm', startTime: '14:00', endTime: '19:45', home: 'First Round', away: 'Arnold Palmer', channel: 'GOLF', url: 'https://www.pgatour.com/leaderboard' },
          { date: '2026-03-06', time: '2:00 pm', startTime: '14:00', endTime: '19:45', home: 'Second Round', away: 'Arnold Palmer', channel: 'GOLF', url: 'https://www.pgatour.com/leaderboard' },
          { date: '2026-03-07', time: '2:30 pm', startTime: '14:30', endTime: '20:30', home: 'Third Round', away: 'Arnold Palmer', channel: 'NBC', url: 'https://www.pgatour.com/leaderboard' },
          { date: '2026-03-08', time: '2:30 pm', startTime: '14:30', endTime: '20:30', home: 'Final Round', away: 'Arnold Palmer', channel: 'NBC', url: 'https://www.pgatour.com/leaderboard' },
        
          { date: '2026-03-12', time: '1:00 pm', startTime: '13:00', endTime: '18:45', home: 'First Round', away: 'THE PLAYERS', channel: 'GOLF', url: 'https://www.pgatour.com/leaderboard' },
          { date: '2026-03-13', time: '1:00 pm', startTime: '13:00', endTime: '18:45', home: 'Second Round', away: 'THE PLAYERS', channel: 'GOLF', url: 'https://www.pgatour.com/leaderboard' },
          { date: '2026-03-14', time: '2:00 pm', startTime: '14:00', endTime: '20:00', home: 'Third Round', away: 'THE PLAYERS', channel: 'NBC', url: 'https://www.pgatour.com/leaderboard' },
          { date: '2026-03-15', time: '1:00 pm', startTime: '13:00', endTime: '19:00', home: 'Final Round', away: 'THE PLAYERS', channel: 'NBC', url: 'https://www.pgatour.com/leaderboard' },
          ],
      
      'UFC': [
  { date: '2026-01-24', time: '5:00 PM', startTime: '17:00', endTime: '19:00', home: 'Gaethje-Pimblett', away: 'UFC 324 Early Prelims', channel: 'Paramount+', url: 'https://www.ufc.com/event/ufc-324' },
  { date: '2026-01-24', time: '7:00 PM', startTime: '19:00', endTime: '21:00', home: 'Gaethje-Pimblett', away: 'UFC 324 Prelims', channel: 'Paramount+', url: 'https://www.ufc.com/event/ufc-324' },
  { date: '2026-01-24', time: '9:00 PM', startTime: '21:00', endTime: '23:59', home: 'Gaethje-Pimblett', away: 'UFC 324 Main Card', channel: 'Paramount+', url: 'https://www.ufc.com/event/ufc-324' },

  { date: '2026-01-31', time: '5:00 PM', startTime: '17:00', endTime: '19:00', home: 'Volkanovski-Lopes 2', away: 'UFC 325 Early Prelims', channel: 'Paramount+', url: 'https://www.ufc.com/event/ufc-325' },
  { date: '2026-01-31', time: '7:00 PM', startTime: '19:00', endTime: '21:00', home: 'Volkanovski-Lopes 2', away: 'UFC 325 Prelims', channel: 'Paramount+', url: 'https://www.ufc.com/event/ufc-325' },
  { date: '2026-01-31', time: '9:00 PM', startTime: '21:00', endTime: '23:59', home: 'Volkanovski-Lopes 2', away: 'UFC 325 Main Card', channel: 'Paramount+', url: 'https://www.ufc.com/event/ufc-325' },

  { date: '2026-02-07', time: '6:00 PM', startTime: '18:00', endTime: '20:00', home: 'Bautista-Oliveira', away: 'UFC Fight Night Prelims', channel: 'Paramount+', url: 'https://www.ufc.com/event/ufc-fight-night-february-07-2026' },
  { date: '2026-02-07', time: '9:00 PM', startTime: '21:00', endTime: '23:59', home: 'Bautista-Oliveira', away: 'UFC Fight Night Main Card', channel: 'Paramount+', url: 'https://www.ufc.com/event/ufc-fight-night-february-07-2026' },

  { date: '2026-02-21', time: '5:00 PM', startTime: '17:00', endTime: '19:00', home: 'Strickland-Hernandez', away: 'UFC Fight Night Prelims', channel: 'Paramount+', url: 'https://www.ufc.com/event/ufc-fight-night-february-21-2026' },
  { date: '2026-02-21', time: '8:00 PM', startTime: '20:00', endTime: '23:30', home: 'Strickland-Hernandez', away: 'UFC Fight Night Main Card', channel: 'Paramount+', url: 'https://www.ufc.com/event/ufc-fight-night-february-21-2026' },

  { date: '2026-02-28', time: '6:00 PM', startTime: '18:00', endTime: '20:00', home: 'Moreno-Almabayev', away: 'UFC Fight Night Prelims', channel: 'Paramount+', url: 'https://www.ufc.com/event/ufc-fight-night-february-28-2026' },
  { date: '2026-02-28', time: '9:00 PM', startTime: '21:00', endTime: '23:59', home: 'Moreno-Almabayev', away: 'UFC Fight Night Main Card', channel: 'Paramount+', url: 'https://www.ufc.com/event/ufc-fight-night-february-28-2026' },

  { date: '2026-03-07', time: '5:00 PM', startTime: '17:00', endTime: '19:00', home: 'Holloway-Oliveira 2', away: 'UFC 326 Early Prelims', channel: 'Paramount+', url: 'https://www.ufc.com/event/ufc-326' },
  { date: '2026-03-07', time: '7:00 PM', startTime: '19:00', endTime: '21:00', home: 'Holloway-Oliveira 2', away: 'UFC 326 Prelims', channel: 'Paramount+', url: 'https://www.ufc.com/event/ufc-326' },
  { date: '2026-03-07', time: '9:00 PM', startTime: '21:00', endTime: '23:59', home: 'Holloway-Oliveira 2', away: 'UFC 326 Main Card', channel: 'Paramount+', url: 'https://www.ufc.com/event/ufc-326' },

  { date: '2026-03-14', time: '6:00 PM', startTime: '18:00', endTime: '20:00', home: 'Emmett-Vallejos', away: 'UFC Fight Night Prelims', channel: 'Paramount+', url: 'https://www.ufc.com/event/ufc-fight-night-march-14-2026' },
  { date: '2026-03-14', time: '9:00 PM', startTime: '21:00', endTime: '23:59', home: 'Emmett-Vallejos', away: 'UFC Fight Night Main Card', channel: 'Paramount+', url: 'https://www.ufc.com/event/ufc-fight-night-march-14-2026' },

  { date: '2026-03-21', time: '1:00 PM', startTime: '13:00', endTime: '15:00', home: 'TBA-TBA', away: 'UFC Fight Night Prelims', channel: 'Paramount+' },
  { date: '2026-03-21', time: '4:00 PM', startTime: '16:00', endTime: '19:30', home: 'TBA-TBA', away: 'UFC Fight Night Main Card', channel: 'Paramount+' },

  { date: '2026-03-28', time: '6:00 PM', startTime: '18:00', endTime: '20:00', home: 'Adesanya-Pyfer', away: 'UFC Fight Night Prelims', channel: 'Paramount+', url: 'https://www.ufc.com/event/ufc-fight-night-march-28-2026' },
  { date: '2026-03-28', time: '9:00 PM', startTime: '21:00', endTime: '23:59', home: 'Adesanya-Pyfer', away: 'UFC Fight Night Main Card', channel: 'Paramount+', url: 'https://www.ufc.com/event/ufc-fight-night-march-28-2026' }
],
      
      'Boxing': [
        { date: '2026-01-30', time: '6:00 PM', home: 'Castillo', away: 'Flores', channel: 'ProBox TV', startTime: '18:00', endTime: '22:30', url: 'https://box.live/us-boxing-tv-schedule' },
        { date: '2026-01-31', time: '12:00 AM', home: 'Baraou', away: 'Zayas', channel: '', startTime: '00:00', endTime: '23:59', url: 'https://box.live/us-boxing-tv-schedule' },
        { date: '2026-01-31', time: '1:00 PM', home: 'Kelly', away: 'Murtazaliev', channel: 'DAZN', startTime: '13:00', endTime: '17:30', url: 'https://box.live/us-boxing-tv-schedule' },
        { date: '2026-01-31', time: '8:00 PM', home: 'Stevenson', away: 'Lopez', channel: 'DAZN', startTime: '20:00', endTime: '23:59', url: 'https://box.live/us-boxing-tv-schedule' },
        { date: '2026-01-31', time: '12:00 AM', home: 'Lemos', away: 'Azim', channel: 'BBC Two', startTime: '00:00', endTime: '23:59', url: 'https://box.live/us-boxing-tv-schedule' },
        { date: '2026-01-31', time: '12:00 AM', home: 'Bank', away: 'Scull', channel: 'DAZN', startTime: '00:00', endTime: '23:59', url: 'https://box.live/us-boxing-tv-schedule' },
        { date: '2026-02-05', time: '6:30 PM', home: 'Richards', away: 'Ramirez', channel: 'Punchinggrace.com', startTime: '18:30', endTime: '23:00', url: 'https://box.live/us-boxing-tv-schedule' },
        { date: '2026-02-06', time: '9:00 PM', home: 'Curiel', away: 'Medina', channel: 'DAZN', startTime: '21:00', endTime: '23:59', url: 'https://box.live/us-boxing-tv-schedule' },
        { date: '2026-02-07', time: '2:00 PM', home: 'Figueroa', away: 'Ball', channel: 'DAZN', startTime: '14:00', endTime: '18:30', url: 'https://box.live/us-boxing-tv-schedule' },
        { date: '2026-02-10', time: '8:00 PM', home: 'Jimenez', away: 'Pagan', channel: 'DAZN', startTime: '20:00', endTime: '23:59', url: 'https://box.live/us-boxing-tv-schedule' },
        { date: '2026-02-14', time: '12:00 AM', home: 'Martin', away: 'Ajagba', channel: 'Paramount+', startTime: '00:00', endTime: '23:59', url: 'https://box.live/us-boxing-tv-schedule' },
        { date: '2026-02-15', time: '12:00 AM', home: 'Mercado', away: 'Nishida', channel: '', startTime: '00:00', endTime: '23:59', url: 'https://box.live/us-boxing-tv-schedule' },
        { date: '2026-02-15', time: '12:00 PM', home: 'Byfield', away: 'Muxanga', channel: 'DAZN', startTime: '12:00', endTime: '16:30', url: 'https://box.live/us-boxing-tv-schedule' },
        { date: '2026-02-21', time: '1:00 PM', home: 'Warrington', away: 'Wood', channel: 'DAZN', startTime: '13:00', endTime: '17:30', url: 'https://box.live/us-boxing-tv-schedule' },
        { date: '2026-02-21', time: '12:00 AM', home: 'Cepeda', away: 'Santillan', channel: '', startTime: '00:00', endTime: '23:59', url: 'https://box.live/us-boxing-tv-schedule' },
        { date: '2026-02-21', time: '7:00 PM', home: 'Garcia', away: 'Barrios', channel: 'DAZN', startTime: '19:00', endTime: '23:30', url: 'https://box.live/us-boxing-tv-schedule' },
        { date: '2026-02-22', time: '8:00 PM', home: 'Crews-Dezurn', away: 'Shields', channel: 'DAZN', startTime: '20:00', endTime: '23:59', url: 'https://box.live/us-boxing-tv-schedule' },
        { date: '2026-02-28', time: '4:00 PM', home: 'Navarrete', away: 'Nunez', channel: 'DAZN', startTime: '16:00', endTime: '20:30', url: 'https://box.live/us-boxing-tv-schedule' },
        { date: '2026-02-28', time: '5:00 PM', home: 'Parra', away: 'Pierce', channel: 'Amazon Prime', startTime: '17:00', endTime: '21:30', url: 'https://box.live/us-boxing-tv-schedule' },
        { date: '2026-02-28', time: '2:00 PM', home: 'Cooper', away: 'Ursu', channel: 'DAZN', startTime: '14:00', endTime: '18:30', url: 'https://box.live/us-boxing-tv-schedule' },
        { date: '2026-03-05', time: '12:00 AM', home: 'Hiseni', away: 'Butler', channel: 'Punchinggrace.com', startTime: '00:00', endTime: '23:59', url: 'https://box.live/us-boxing-tv-schedule' },
        { date: '2026-03-14', time: '3:00 PM', home: 'Cacace', away: 'Dickens', channel: 'DAZN', startTime: '15:00', endTime: '19:30', url: 'https://box.live/us-boxing-tv-schedule' },
        { date: '2026-03-28', time: '1:45 PM', home: 'Franklin', away: 'Itauma', channel: 'DAZN', startTime: '13:45', endTime: '18:15', url: 'https://box.live/us-boxing-tv-schedule' },
        { date: '2026-04-18', time: '12:00 AM', home: 'Agyarko', away: 'Adams', channel: '', startTime: '00:00', endTime: '23:59', url: 'https://box.live/us-boxing-tv-schedule' }
      
      
      ],
      
      'NASCARCupSeries': [
        { date: '2026-02-04', time: '6:00 PM', home: 'Bowman Gray', away: 'Clash at', channel: 'FOX', startTime: '18:00', endTime: '22:00', url: 'https://www.nascar.com/followlive/' },        { date: '2026-02-12', time: '8:45 PM', home: 'Duel #2', away: 'Daytona', channel: 'FS1', startTime: '20:45', endTime: '23:59', url: 'https://www.nascar.com/followlive/' },
        { date: '2026-02-15', time: '2:30 PM', home: 'Daytona 500', away: '', channel: 'FOX', startTime: '14:30', endTime: '19:00', url: 'https://www.nascar.com/followlive/' },
        { date: '2026-02-22', time: '3:00 PM', home: 'Atlanta', away: '', channel: 'FOX', startTime: '15:00', endTime: '19:30', url: 'https://www.nascar.com/followlive/' },
        { date: '2026-03-01', time: '3:30 PM', home: 'Circuit of the Americas', away: 'COTA', channel: 'FOX', startTime: '15:30', endTime: '20:00', url: 'https://www.nascar.com/followlive/' },
        { date: '2026-03-08', time: '3:30 PM', home: 'Phoenix', away: '', channel: 'FS1', startTime: '15:30', endTime: '20:00', url: 'https://www.nascar.com/followlive/' },
        { date: '2026-03-15', time: '4:00 PM', home: 'Las Vegas', away: '', channel: 'FS1', startTime: '16:00', endTime: '20:30', url: 'https://www.nascar.com/followlive/' },
        { date: '2026-03-22', time: '3:00 PM', home: 'Darlington', away: '', channel: 'FS1', startTime: '15:00', endTime: '19:30', url: 'https://www.nascar.com/followlive/' },
        { date: '2026-03-29', time: '3:30 PM', home: 'Martinsville', away: '', channel: 'FS1', startTime: '15:30', endTime: '20:00', url: 'https://www.nascar.com/followlive/' },
        { date: '2026-04-12', time: '3:00 PM', home: 'Bristol', away: '', channel: 'FS1', startTime: '15:00', endTime: '19:30', url: 'https://www.nascar.com/followlive/' },
        { date: '2026-04-19', time: '2:00 PM', home: 'Kansas', away: '', channel: 'FOX', startTime: '14:00', endTime: '18:30', url: 'https://www.nascar.com/followlive/' },
        { date: '2026-04-26', time: '3:00 PM', home: 'Talladega', away: '', channel: 'FOX', startTime: '15:00', endTime: '19:30', url: 'https://www.nascar.com/followlive/' },
        { date: '2026-05-03', time: '3:30 PM', home: 'Texas', away: '', channel: 'FS1', startTime: '15:30', endTime: '20:00', url: 'https://www.nascar.com/followlive/' },
        { date: '2026-05-10', time: '3:00 PM', home: 'Watkins Glen', away: '', channel: 'FS1', startTime: '15:00', endTime: '19:30', url: 'https://www.nascar.com/followlive/' },
        { date: '2026-05-17', time: '3:00 PM', home: 'All Star Race', away: 'Dover', channel: 'FS1', startTime: '15:00', endTime: '19:30', url: 'https://www.nascar.com/followlive/' },
        { date: '2026-05-24', time: '6:00 PM', home: 'Charlotte', away: '', channel: 'Prime Video', startTime: '18:00', endTime: '22:30', url: 'https://www.nascar.com/followlive/' },
        { date: '2026-05-31', time: '7:00 PM', home: 'Nashville', away: '', channel: 'Prime Video', startTime: '19:00', endTime: '23:30', url: 'https://www.nascar.com/followlive/' },
        { date: '2026-06-07', time: '3:00 PM', home: 'Michigan', away: '', channel: 'Prime Video', startTime: '15:00', endTime: '19:30', url: 'https://www.nascar.com/followlive/' },
        { date: '2026-06-14', time: '3:00 PM', home: 'Pocono', away: '', channel: 'Prime Video', startTime: '15:00', endTime: '19:30', url: 'https://www.nascar.com/followlive/' },
        { date: '2026-06-28', time: '3:30 PM', home: 'Sonoma', away: 'Sonoma Raceway', channel: 'TNT', startTime: '15:30', endTime: '20:00', url: 'https://www.nascar.com/followlive/' },
        { date: '2026-07-05', time: '6:00 PM', home: 'Chicago', away: '', channel: 'TNT', startTime: '18:00', endTime: '22:30', url: 'https://www.nascar.com/followlive/' },
        { date: '2026-07-12', time: '7:00 PM', home: 'Atlanta', away: '', channel: 'TNT', startTime: '19:00', endTime: '23:30', url: 'https://www.nascar.com/followlive/' },
        { date: '2026-07-19', time: '7:00 PM', home: 'North Wilkesboro', away: '', channel: 'TNT', startTime: '19:00', endTime: '23:30', url: 'https://www.nascar.com/followlive/' },
        { date: '2026-07-26', time: '2:00 PM', home: 'Indianapolis', away: '', channel: 'TNT', startTime: '14:00', endTime: '18:30', url: 'https://www.nascar.com/followlive/' },
        { date: '2026-08-09', time: '3:30 PM', home: 'Iowa', away: '', channel: 'USA Net', startTime: '15:30', endTime: '20:00', url: 'https://www.nascar.com/followlive/' },
        { date: '2026-08-15', time: '7:00 PM', home: 'Richmond', away: '', channel: 'USA Net', startTime: '19:00', endTime: '23:30', url: 'https://www.nascar.com/followlive/' },
        { date: '2026-08-23', time: '3:00 PM', home: 'New Hampshire', away: '', channel: 'USA Net', startTime: '15:00', endTime: '19:30', url: 'https://www.nascar.com/followlive/' },
        { date: '2026-08-29', time: '7:30 PM', home: 'Daytona', away: '', channel: 'NBC', startTime: '19:30', endTime: '23:59', url: 'https://www.nascar.com/followlive/' },
        { date: '2026-09-06', time: '5:00 PM', home: 'Darlington', away: 'Playoffs', channel: 'USA Net', startTime: '17:00', endTime: '21:30', url: 'https://www.nascar.com/followlive/' },
        { date: '2026-09-13', time: '3:00 PM', home: 'WWT', away: 'Playoffs', channel: 'USA Net', startTime: '15:00', endTime: '19:30', url: 'https://www.nascar.com/followlive/' },
        { date: '2026-09-19', time: '7:30 PM', home: 'Bristol', away: 'Playoffs', channel: 'USA Net', startTime: '19:30', endTime: '23:59', url: 'https://www.nascar.com/followlive/' },
        { date: '2026-09-27', time: '3:00 PM', home: 'Kansas', away: 'Playoffs', channel: 'USA Net', startTime: '15:00', endTime: '19:30', url: 'https://www.nascar.com/followlive/' },
        { date: '2026-10-04', time: '5:30 PM', home: 'Las Vegas', away: 'Playoffs', channel: 'USA Net', startTime: '17:30', endTime: '22:00', url: 'https://www.nascar.com/followlive/' },
        { date: '2026-10-11', time: '3:00 PM', home: 'Charlotte Road Course', away: 'Playoffs', channel: 'USA Net', startTime: '15:00', endTime: '19:30', url: 'https://www.nascar.com/followlive/' },
        { date: '2026-10-18', time: '3:00 PM', home: 'Phoenix', away: 'Playoffs', channel: 'USA Net', startTime: '15:00', endTime: '19:30', url: 'https://www.nascar.com/followlive/' },
        { date: '2026-10-25', time: '2:00 PM', home: 'Talladega', away: 'Playoffs', channel: 'NBC', startTime: '14:00', endTime: '18:30', url: 'https://www.nascar.com/followlive/' },
        { date: '2026-11-01', time: '2:00 PM', home: 'Martinsville', away: 'Playoffs', channel: 'NBC', startTime: '14:00', endTime: '18:30', url: 'https://www.nascar.com/followlive/' },
        { date: '2026-11-08', time: '3:00 PM', home: 'Miami', away: 'Championship', channel: 'NBC', startTime: '15:00', endTime: '19:30', url: 'https://www.nascar.com/followlive/' },
      ],

      'USWNT': [
{ date: '2026-01-27', time: '10:00 pm', startTime: '22:00', endTime: '23:59', away: 'Chile', home: 'United States', channel: 'TBS', url: 'https://www.fotmob.com/matches/usa-vs-chile/4yz4r48f#5135650' },

{ date: '2026-03-01', time: '5:00 pm', startTime: '17:00', endTime: '19:00', away: 'Argentina', home: 'United States', channel: 'TNT', url: 'https://www.fotmob.com/matches/usa-vs-argentina/1hyjta0#5135654' },

{ date: '2026-03-04', time: '6:30 pm', startTime: '18:30', endTime: '20:30', away: 'Canada', home: 'United States', channel: 'TNT', url: 'https://www.fotmob.com/matches/usa-vs-canada/1hyp09u#5135656' },

{ date: '2026-03-07', time: '3:30 pm', startTime: '15:30', endTime: '17:30', away: 'Colombia', home: 'United States', channel: 'TBS', url: 'https://www.fotmob.com/matches/usa-vs-colombia/duxxf56#5135658' },

{ date: '2026-04-11', time: '5:30 pm', startTime: '17:30', endTime: '19:30', away: 'Japan', home: 'United States', channel: 'TNT', url: 'https://www.fotmob.com/teams/5909/fixtures/usa' },

{ date: '2026-04-14', time: '10:00 pm', startTime: '22:00', endTime: '23:59', away: 'Japan', home: 'United States', channel: 'TNT', url: 'https://www.fotmob.com/teams/5909/fixtures/usa' },

  { date: '2026-04-17', time: '9:00 pm', startTime: '21:00', endTime: '23:00', away: 'Japan', home: 'United States', channel: 'TNT', url: 'https://www.fotmob.com/teams/5909/fixtures/usa' },
],

'IMSASportsCar': [
  { date: '2026-01-25', time: '1:00 am', startTime: '1:00', endTime: '14:00', away: '24 Hours of', home: 'Daytona', channel: 'Peacock, NBC', url: 'https://www.imsa.com/scoring/' }, // Add IMSA SportsCar Championship races here
  // Example format:
  // { date: '2026-01-24', time: '1:00 PM', startTime: '13:00', endTime: '18:00', home: 'Rolex 24 at Daytona', away: 'Daytona', channel: 'NBC', url: 'https://www.imsa.com/events/...' },
],

'LIVGolf':
[
{ date: '2026-02-04', time: '10:00 am', home: '1st Round', away: 'Riyadh', channel: 'GOLF', startTime: '10:00', endTime: '15:00', url: 'https://www.livgolf.com/schedule/riyadh-2026/live' },
{ date: '2026-02-05', time: '10:00 am', home: '2nd Round', away: 'Riyadh', channel: 'GOLF', startTime: '10:00', endTime: '15:00', url: 'https://www.livgolf.com/schedule/riyadh-2026/live' },
{ date: '2026-02-06', time: '10:00 am', home: '3rd Round', away: 'Riyadh', channel: 'GOLF', startTime: '10:00', endTime: '15:00', url: 'https://www.livgolf.com/schedule/riyadh-2026/live' },
{ date: '2026-02-07', time: '', home: 'Final Round', away: 'Riyadh', channel: 'GOLF', startTime: '', endTime: '', url: 'https://www.livgolf.com/schedule/riyadh-2026/live' },
],

'LPGATour': [
{ date: '2026-01-29', time: '11:30 am', startTime: '11:30', endTime: '16:30', home: 'Champions, R1', away: 'Tournament of', channel: 'GOLF', url: 'https://www.lpga.com/leaderboard' },
  { date: '2026-01-30', time: '11:30 am', startTime: '11:30', endTime: '16:30', home: 'Champions, R2', away: 'Tournament of', channel: 'GOLF', url: 'https://www.lpga.com/leaderboard' },
  { date: '2026-01-31', time: '2:00 pm', startTime: '14:00', endTime: '20:00', home: 'Champions, R3', away: 'Tournament of', channel: 'NBC, Peacock', url: 'https://www.lpga.com/leaderboard' },
  { date: '2026-02-01', time: '1:00 pm', startTime: '13:00', endTime: '19:00', home: 'Champions, R4', away: 'Tournament of', channel: 'NBC, Peacock', url: 'https://www.lpga.com/leaderboard' },
  { date: '2026-02-19', time: '10:00 pm', startTime: '22:00', endTime: '03:00', home: 'First Round', away: 'Thailand', channel: 'GOLF', url: 'https://www.lpga.com/leaderboard' },
  { date: '2026-02-20', time: '10:00 pm', startTime: '22:00', endTime: '03:00', home: 'Second Round', away: 'Thailand', channel: 'GOLF', url: 'https://www.lpga.com/leaderboard' },
  { date: '2026-02-21', time: '10:30 pm', startTime: '22:30', endTime: '03:30', home: 'Third Round', away: 'Thailand', channel: 'GOLF', url: 'https://www.lpga.com/leaderboard' },
  { date: '2026-02-22', time: '10:30 pm', startTime: '22:30', endTime: '03:30', home: 'Final Round', away: 'Thailand', channel: 'GOLF', url: 'https://www.lpga.com/leaderboard' },
  { date: '2026-02-26', time: '8:30 pm', startTime: '20:30', endTime: '01:30', home: 'First Round', away: 'HSBC', channel: 'GOLF', url: 'https://www.lpga.com/leaderboard' },
  { date: '2026-02-27', time: '8:30 pm', startTime: '20:30', endTime: '01:30', home: 'Second Round', away: 'HSBC', channel: 'GOLF', url: 'https://www.lpga.com/leaderboard' },
  { date: '2026-02-28', time: '9:30 pm', startTime: '21:30', endTime: '02:30', home: 'Third Round', away: 'HSBC', channel: 'GOLF', url: 'https://www.lpga.com/leaderboard' },
  { date: '2026-03-01', time: '9:30 pm', startTime: '21:30', endTime: '02:30', home: 'Final Round', away: 'HSBC', channel: 'GOLF', url: 'https://www.lpga.com/leaderboard' },
  { date: '2026-03-05', time: '11:00 pm', startTime: '23:00', endTime: '04:00', home: 'First Round', away: 'Blue Bay ', channel: 'GOLF', url: 'https://www.lpga.com/leaderboard' },
  { date: '2026-03-06', time: '11:00 pm', startTime: '23:00', endTime: '04:00', home: 'Second Round', away: 'Blue Bay ', channel: 'GOLF', url: 'https://www.lpga.com/leaderboard' },
  { date: '2026-03-07', time: '11:00 pm', startTime: '23:00', endTime: '04:00', home: 'Third Round', away: 'Blue Bay ', channel: 'GOLF', url: 'https://www.lpga.com/leaderboard' },
  { date: '2026-03-08', time: '11:00 pm', startTime: '23:00', endTime: '04:00', home: 'Final Round', away: 'Blue Bay ', channel: 'GOLF', url: 'https://www.lpga.com/leaderboard' },
  { date: '2026-03-19', time: '11:00 am', startTime: '11:00', endTime: '16:00', home: 'First Round', away: 'Founders ', channel: 'GOLF', url: 'https://www.lpga.com/leaderboard' },
  { date: '2026-03-20', time: '11:00 am', startTime: '11:00', endTime: '16:00', home: 'Second Round', away: 'Founders ', channel: 'GOLF', url: 'https://www.lpga.com/leaderboard' },
  { date: '2026-03-21', time: '3:00 pm', startTime: '15:00', endTime: '20:00', home: 'Third Round', away: 'Founders ', channel: 'GOLF', url: 'https://www.lpga.com/leaderboard' },
  { date: '2026-03-22', time: '3:00 pm', startTime: '15:00', endTime: '20:00', home: 'Final Round', away: 'Founders ', channel: 'GOLF', url: 'https://www.lpga.com/leaderboard' },
  { date: '2026-03-26', time: '6:00 pm', startTime: '18:00', endTime: '23:00', home: 'First Round', away: 'Ford Champ.', channel: 'NBCSports.com', url: 'https://www.lpga.com/leaderboard' },
  { date: '2026-03-26', time: '7:00 pm', startTime: '19:00', endTime: '00:00', home: 'First Round', away: 'Ford Champ.', channel: 'GOLF', url: 'https://www.lpga.com/leaderboard' },
  { date: '2026-03-27', time: '6:00 pm', startTime: '18:00', endTime: '23:00', home: 'Second Round', away: 'Ford Champ.', channel: 'NBCSports.com', url: 'https://www.lpga.com/leaderboard' },
  { date: '2026-03-27', time: '7:00 pm', startTime: '19:00', endTime: '00:00', home: 'Second Round', away: 'Ford Champ.', channel: 'GOLF', url: 'https://www.lpga.com/leaderboard' },
  { date: '2026-03-28', time: '6:00 pm', startTime: '18:00', endTime: '23:00', home: 'Third Round', away: 'Ford Champ.', channel: 'GOLF', url: 'https://www.lpga.com/leaderboard' },
  { date: '2026-03-29', time: '6:00 pm', startTime: '18:00', endTime: '23:00', home: 'Final Round', away: 'Ford Champ.', channel: 'GOLF', url: 'https://www.lpga.com/leaderboard' },
  { date: '2026-04-01', time: '1:30 pm', startTime: '13:30', endTime: '18:30', home: 'First Round', away: 'Augusta (A)', channel: 'GOLF, Masters Live', url: 'https://www.lpga.com/leaderboard' },
  { date: '2026-04-02', time: '1:30 pm', startTime: '13:30', endTime: '18:30', home: 'Second Round', away: 'Augusta (A)', channel: 'GOLF, Masters Live', url: 'https://www.lpga.com/leaderboard' },
  { date: '2026-04-04', time: '12:00 pm', startTime: '12:00', endTime: '17:00', home: 'Final Round', away: 'Augusta (A)', channel: 'NBC, Peacock, Masters Live', url: 'https://www.lpga.com/leaderboard' },
  { date: '2026-04-16', time: '6:00 pm', startTime: '18:00', endTime: '23:00', home: 'First Round', away: 'JM Eagle LA', channel: 'GOLF', url: 'https://www.lpga.com/leaderboard' },
  { date: '2026-04-17', time: '6:00 pm', startTime: '18:00', endTime: '23:00', home: 'Second Round', away: 'JM Eagle LA', channel: 'GOLF', url: 'https://www.lpga.com/leaderboard' },
  { date: '2026-04-18', time: '6:00 pm', startTime: '18:00', endTime: '23:00', home: 'Third Round', away: 'JM Eagle LA', channel: 'GOLF', url: 'https://www.lpga.com/leaderboard' },
  { date: '2026-04-19', time: '6:00 pm', startTime: '18:00', endTime: '23:00', home: 'Final Round', away: 'JM Eagle LA', channel: 'GOLF', url: 'https://www.lpga.com/leaderboard' },
  { date: '2026-04-23', time: '9:00 am', startTime: '09:00', endTime: '14:00', home: 'Featured Groups', away: 'Chevron', channel: 'ESPN+', url: 'https://www.lpga.com/leaderboard' },
  { date: '2026-04-23', time: '11:00 am', startTime: '11:00', endTime: '16:00', home: 'First Round', away: 'Chevron', channel: 'GOLF', url: 'https://www.lpga.com/leaderboard' },
  { date: '2026-04-24', time: '11:00 am', startTime: '11:00', endTime: '16:00', home: 'Second Round', away: 'Chevron', channel: 'GOLF', url: 'https://www.lpga.com/leaderboard' },
  { date: '2026-04-25', time: '3:00 pm', startTime: '15:00', endTime: '20:00', home: 'Third Round', away: 'Chevron', channel: 'NBC, Peacock', url: 'https://www.lpga.com/leaderboard' },
  { date: '2026-04-26', time: '3:00 pm', startTime: '15:00', endTime: '20:00', home: 'Final Round', away: 'Chevron', channel: 'NBC, Peacock', url: 'https://www.lpga.com/leaderboard' }
     ],

    'DPWorldTour': 
[
  { date: '2026-01-29', time: '', home: '1st Round', away: 'Bahrain', channel: 'GOLF', startTime: '', endTime: '', url: 'https://www.europeantour.com/dpworld-tour/bapco-energies-bahrain-championship-2026/' },
  { date: '2026-01-30', time: '3:30 am', home: '2nd Round', away: 'Bahrain', channel: 'GOLF', startTime: '3:30', endTime: '8:30', url: 'https://www.europeantour.com/dpworld-tour/bapco-energies-bahrain-championship-2026/' },
  { date: '2026-01-31', time: '4:00 am', home: '3rd Round', away: 'Bahrain', channel: 'GOLF', startTime: '4:00', endTime: '8:30', url: 'https://www.europeantour.com/dpworld-tour/bapco-energies-bahrain-championship-2026/' },
  { date: '2026-02-01', time: '3:30 am', home: 'Final Round', away: 'Bahrain', channel: 'GOLF', startTime: '3:30', endTime: '8:30', url: 'https://www.europeantour.com/dpworld-tour/bapco-energies-bahrain-championship-2026/' },
  
  { date: '2026-02-05', time: '4:00 am', home: '1st Round', away: 'Qatar', channel: 'GOLF', startTime: '04:00', endTime: '09:00', url: 'https://www.europeantour.com/dpworld-tour/qatar-masters-2026/' },

{ date: '2026-02-06', time: '4:00 am', home: '2nd Round', away: 'Qatar', channel: 'GOLF', startTime: '04:00', endTime: '09:00', url: 'https://www.europeantour.com/dpworld-tour/qatar-masters-2026/' },

{ date: '2026-02-07', time: '4:30 am', home: '3rd Round', away: 'Qatar', channel: 'GOLF', startTime: '04:30', endTime: '09:00', url: 'https://www.europeantour.com/dpworld-tour/qatar-masters-2026/' },

{ date: '2026-02-08', time: '3:30 am', home: 'Final Round', away: 'Qatar', channel: 'GOLF', startTime: '03:30', endTime: '08:30', url: 'https://www.europeantour.com/dpworld-tour/qatar-masters-2026/' },

  { date: '2026-02-19', time: '', home: '1st Round', away: 'Kenya', channel: 'GOLF', startTime: '', endTime: '', url: 'https://www.europeantour.com/dpworld-tour/magical-kenya-open-2026/' },
  { date: '2026-02-20', time: '', home: '2nd Round', away: 'Kenya', channel: 'GOLF', startTime: '', endTime: '', url: 'https://www.europeantour.com/dpworld-tour/magical-kenya-open-2026/' },
  { date: '2026-02-21', time: '', home: '3rd Round', away: 'Kenya', channel: 'GOLF', startTime: '', endTime: '', url: 'https://www.europeantour.com/dpworld-tour/magical-kenya-open-2026/' },
  { date: '2026-02-22', time: '', home: 'Final Round', away: 'Kenya', channel: 'GOLF', startTime: '', endTime: '', url: 'https://www.europeantour.com/dpworld-tour/magical-kenya-open-2026/' },
  { date: '2026-02-26', time: '', home: '1st Round', away: 'S.A. Open', channel: 'GOLF', startTime: '', endTime: '', url: 'https://www.europeantour.com/dpworld-tour/investec-south-african-open-championship-2026/' },
  { date: '2026-02-27', time: '', home: '2nd Round', away: 'S.A. Open', channel: 'GOLF', startTime: '', endTime: '', url: 'https://www.europeantour.com/dpworld-tour/investec-south-african-open-championship-2026/' },
  { date: '2026-02-28', time: '', home: '3rd Round', away: 'S.A. Open', channel: 'GOLF', startTime: '', endTime: '', url: 'https://www.europeantour.com/dpworld-tour/investec-south-african-open-championship-2026/' },
  { date: '2026-03-01', time: '', home: 'Final Round', away: 'S.A. Open', channel: 'GOLF', startTime: '', endTime: '', url: 'https://www.europeantour.com/dpworld-tour/investec-south-african-open-championship-2026/' },
  { date: '2026-03-05', time: '', home: '1st Round', away: 'Joburg', channel: 'GOLF', startTime: '', endTime: '', url: 'https://www.europeantour.com/dpworld-tour/joburg-open-2026/' },
  { date: '2026-03-06', time: '', home: '2nd Round', away: 'Joburg', channel: 'GOLF', startTime: '', endTime: '', url: 'https://www.europeantour.com/dpworld-tour/joburg-open-2026/' },
  { date: '2026-03-07', time: '', home: '3rd Round', away: 'Joburg', channel: 'GOLF', startTime: '', endTime: '', url: 'https://www.europeantour.com/dpworld-tour/joburg-open-2026/' },
  { date: '2026-03-08', time: '', home: 'Final Round', away: 'Joburg', channel: 'GOLF', startTime: '', endTime: '', url: 'https://www.europeantour.com/dpworld-tour/joburg-open-2026/' },
  { date: '2026-03-19', time: '', home: '1st Round', away: 'Hainan', channel: 'GOLF', startTime: '', endTime: '', url: 'https://www.europeantour.com/dpworld-tour/hainan-classic-2026/' },
  { date: '2026-03-20', time: '', home: '2nd Round', away: 'Hainan', channel: 'GOLF', startTime: '', endTime: '', url: 'https://www.europeantour.com/dpworld-tour/hainan-classic-2026/' },
  { date: '2026-03-21', time: '', home: '3rd Round', away: 'Hainan', channel: 'GOLF', startTime: '', endTime: '', url: 'https://www.europeantour.com/dpworld-tour/hainan-classic-2026/' },
  { date: '2026-03-22', time: '', home: 'Final Round', away: 'Hainan', channel: 'GOLF', startTime: '', endTime: '', url: 'https://www.europeantour.com/dpworld-tour/hainan-classic-2026/' },
  { date: '2026-03-26', time: '', home: '1st Round', away: 'Indian Open', channel: 'GOLF', startTime: '', endTime: '', url: 'https://www.europeantour.com/dpworld-tour/hero-indian-open-2026/' },
  { date: '2026-03-27', time: '', home: '2nd Round', away: 'Indian Open', channel: 'GOLF', startTime: '', endTime: '', url: 'https://www.europeantour.com/dpworld-tour/hero-indian-open-2026/' },
  { date: '2026-03-28', time: '', home: '3rd Round', away: 'Indian Open', channel: 'GOLF', startTime: '', endTime: '', url: 'https://www.europeantour.com/dpworld-tour/hero-indian-open-2026/' },
  { date: '2026-03-29', time: '', home: 'Final Round', away: 'Indian Open', channel: 'GOLF', startTime: '', endTime: '', url: 'https://www.europeantour.com/dpworld-tour/hero-indian-open-2026/' },
  { date: '2026-04-23', time: '', home: '1st Round', away: 'China Open', channel: 'GOLF', startTime: '', endTime: '', url: 'https://www.europeantour.com/dpworld-tour/volvo-china-open-2026/' },
  { date: '2026-04-24', time: '', home: '2nd Round', away: 'China Open', channel: 'GOLF', startTime: '', endTime: '', url: 'https://www.europeantour.com/dpworld-tour/volvo-china-open-2026/' },
  { date: '2026-04-25', time: '', home: '3rd Round', away: 'China Open', channel: 'GOLF', startTime: '', endTime: '', url: 'https://www.europeantour.com/dpworld-tour/volvo-china-open-2026/' },
  { date: '2026-04-26', time: '', home: 'Final Round', away: 'China Open', channel: 'GOLF', startTime: '', endTime: '', url: 'https://www.europeantour.com/dpworld-tour/volvo-china-open-2026/' },
  { date: '2026-04-30', time: '', home: '1st Round', away: 'Turkish Air', channel: 'GOLF', startTime: '', endTime: '', url: 'https://www.europeantour.com/dpworld-tour/turkish-airlines-open-2026/' },
  { date: '2026-05-01', time: '', home: '2nd Round', away: 'Turkish Air', channel: 'GOLF', startTime: '', endTime: '', url: 'https://www.europeantour.com/dpworld-tour/turkish-airlines-open-2026/' },
  { date: '2026-05-02', time: '', home: '3rd Round', away: 'Turkish Air', channel: 'GOLF', startTime: '', endTime: '', url: 'https://www.europeantour.com/dpworld-tour/turkish-airlines-open-2026/' },
  { date: '2026-05-03', time: '', home: 'Final Round', away: 'Turkish Air', channel: 'GOLF', startTime: '', endTime: '', url: 'https://www.europeantour.com/dpworld-tour/turkish-airlines-open-2026/' },
  { date: '2026-05-07', time: '', home: '1st Round', away: 'Catalunya', channel: 'GOLF', startTime: '', endTime: '', url: 'https://www.europeantour.com/dpworld-tour/estrella-damm-catalunya-championship-2026/' },
  { date: '2026-05-08', time: '', home: '2nd Round', away: 'Catalunya', channel: 'GOLF', startTime: '', endTime: '', url: 'https://www.europeantour.com/dpworld-tour/estrella-damm-catalunya-championship-2026/' },
  { date: '2026-05-09', time: '', home: '3rd Round', away: 'Catalunya', channel: 'GOLF', startTime: '', endTime: '', url: 'https://www.europeantour.com/dpworld-tour/estrella-damm-catalunya-championship-2026/' },
  { date: '2026-05-10', time: '', home: 'Final Round', away: 'Catalunya', channel: 'GOLF', startTime: '', endTime: '', url: 'https://www.europeantour.com/dpworld-tour/estrella-damm-catalunya-championship-2026/' },
  { date: '2026-05-21', time: '', home: '1st Round', away: 'Soudal Open', channel: 'GOLF', startTime: '', endTime: '', url: 'https://www.europeantour.com/dpworld-tour/soudal-open-2026/' },
  { date: '2026-05-22', time: '', home: '2nd Round', away: 'Soudal Open', channel: 'GOLF', startTime: '', endTime: '', url: 'https://www.europeantour.com/dpworld-tour/soudal-open-2026/' },
  { date: '2026-05-23', time: '', home: '3rd Round', away: 'Soudal Open', channel: 'GOLF', startTime: '', endTime: '', url: 'https://www.europeantour.com/dpworld-tour/soudal-open-2026/' },
  { date: '2026-05-24', time: '', home: 'Final Round', away: 'Soudal Open', channel: 'GOLF', startTime: '', endTime: '', url: 'https://www.europeantour.com/dpworld-tour/soudal-open-2026/' },
  { date: '2026-05-28', time: '', home: '1st Round', away: 'Alpine', channel: 'GOLF', startTime: '', endTime: '', url: 'https://www.europeantour.com/dpworld-tour/austrian-alpine-open-presented-by-kitzbuhel-tirol-2026/' },
  { date: '2026-05-29', time: '', home: '2nd Round', away: 'Alpine', channel: 'GOLF', startTime: '', endTime: '', url: 'https://www.europeantour.com/dpworld-tour/austrian-alpine-open-presented-by-kitzbuhel-tirol-2026/' },
  { date: '2026-05-30', time: '', home: '3rd Round', away: 'Alpine', channel: 'GOLF', startTime: '', endTime: '', url: 'https://www.europeantour.com/dpworld-tour/austrian-alpine-open-presented-by-kitzbuhel-tirol-2026/' },
  { date: '2026-05-31', time: '', home: 'Final Round', away: 'Alpine', channel: 'GOLF', startTime: '', endTime: '', url: 'https://www.europeantour.com/dpworld-tour/austrian-alpine-open-presented-by-kitzbuhel-tirol-2026/' },
  { date: '2026-06-04', time: '', home: '1st Round', away: 'KLM Open', channel: 'GOLF', startTime: '', endTime: '', url: 'https://www.europeantour.com/dpworld-tour/klm-open-2026/' },
  { date: '2026-06-05', time: '', home: '2nd Round', away: 'KLM Open', channel: 'GOLF', startTime: '', endTime: '', url: 'https://www.europeantour.com/dpworld-tour/klm-open-2026/' },
  { date: '2026-06-06', time: '', home: '3rd Round', away: 'KLM Open', channel: 'GOLF', startTime: '', endTime: '', url: 'https://www.europeantour.com/dpworld-tour/klm-open-2026/' },
  { date: '2026-06-07', time: '', home: 'Final Round', away: 'KLM Open', channel: 'GOLF', startTime: '', endTime: '', url: 'https://www.europeantour.com/dpworld-tour/klm-open-2026/' },
  { date: '2026-06-25', time: '', home: '1st Round', away: 'Open d\'Italia', channel: 'GOLF', startTime: '', endTime: '', url: 'https://www.europeantour.com/dpworld-tour/open-d-italia-2026/' },
  { date: '2026-06-26', time: '', home: '2nd Round', away: 'Open d\'Italia', channel: 'GOLF', startTime: '', endTime: '', url: 'https://www.europeantour.com/dpworld-tour/open-d-italia-2026/' },
  { date: '2026-06-27', time: '', home: '3rd Round', away: 'Open d\'Italia', channel: 'GOLF', startTime: '', endTime: '', url: 'https://www.europeantour.com/dpworld-tour/open-d-italia-2026/' },
  { date: '2026-06-28', time: '', home: 'Final Round', away: 'Open d\'Italia', channel: 'GOLF', startTime: '', endTime: '', url: 'https://www.europeantour.com/dpworld-tour/open-d-italia-2026/' },
  { date: '2026-07-02', time: '', home: '1st Round', away: 'BMW', channel: 'GOLF', startTime: '', endTime: '', url: 'https://www.europeantour.com/dpworld-tour/bmw-international-open-2026/' },
  { date: '2026-07-03', time: '', home: '2nd Round', away: 'BMW', channel: 'GOLF', startTime: '', endTime: '', url: 'https://www.europeantour.com/dpworld-tour/bmw-international-open-2026/' },
  { date: '2026-07-04', time: '', home: '3rd Round', away: 'BMW', channel: 'GOLF', startTime: '', endTime: '', url: 'https://www.europeantour.com/dpworld-tour/bmw-international-open-2026/' },
  { date: '2026-07-05', time: '', home: 'Final Round', away: 'BMW', channel: 'GOLF', startTime: '', endTime: '', url: 'https://www.europeantour.com/dpworld-tour/bmw-international-open-2026/' },
  { date: '2026-07-09', time: '6:00 am', home: '1st Round', away: 'Scottish Open', channel: 'GOLF', startTime: '06:00', endTime: '', url: 'https://www.europeantour.com/dpworld-tour/genesis-scottish-open-2026/' },
  { date: '2026-07-10', time: '6:00 am', home: '2nd Round', away: 'Scottish Open', channel: 'GOLF', startTime: '06:00', endTime: '', url: 'https://www.europeantour.com/dpworld-tour/genesis-scottish-open-2026/' },
  { date: '2026-07-11', time: '10:00 am', home: '3rd Round', away: 'Scottish Open', channel: 'CBS', startTime: '10:00', endTime: '', url: 'https://www.europeantour.com/dpworld-tour/genesis-scottish-open-2026/' },
  { date: '2026-07-12', time: '10:00 am', home: 'Final Round', away: 'Scottish Open', channel: 'CBS', startTime: '10:00', endTime: '', url: 'https://www.europeantour.com/dpworld-tour/genesis-scottish-open-2026/' },
  { date: '2026-07-16', time: '4:00 am', home: '1st Round', away: 'The Open', channel: 'USA Network', startTime: '04:00', endTime: '', url: 'https://www.theopen.com/royal-birkdale-154th-open' },
  { date: '2026-07-17', time: '4:00 am', home: '2nd Round', away: 'The Open', channel: 'USA Network', startTime: '04:00', endTime: '', url: 'https://www.theopen.com/royal-birkdale-154th-open' },
  { date: '2026-07-18', time: '7:00 am', home: '3rd Round', away: 'The Open', channel: 'NBC, Peacock', startTime: '07:00', endTime: '', url: 'https://www.theopen.com/royal-birkdale-154th-open' },
  { date: '2026-07-19', time: '7:00 am', home: 'Final Round', away: 'The Open', channel: 'NBC, Peacock', startTime: '07:00', endTime: '', url: 'https://www.theopen.com/royal-birkdale-154th-open' },
  { date: '2026-08-13', time: '', home: '1st Round', away: 'Danish', channel: 'GOLF', startTime: '', endTime: '', url: 'https://www.europeantour.com/dpworld-tour/danish-golf-championship-2026/' },
  { date: '2026-08-14', time: '', home: '2nd Round', away: 'Danish', channel: 'GOLF', startTime: '', endTime: '', url: 'https://www.europeantour.com/dpworld-tour/danish-golf-championship-2026/' },
  { date: '2026-08-15', time: '', home: '3rd Round', away: 'Danish', channel: 'GOLF', startTime: '', endTime: '', url: 'https://www.europeantour.com/dpworld-tour/danish-golf-championship-2026/' },
  { date: '2026-08-16', time: '', home: 'Final Round', away: 'Danish', channel: 'GOLF', startTime: '', endTime: '', url: 'https://www.europeantour.com/dpworld-tour/danish-golf-championship-2026/' }
],
       
'PGATourChampions': [

  { date: '2026-02-13', time: '11:00 am', startTime: '11:00', endTime: '14:00', home: 'Chubb', away: '1st Round', channel: 'GOLF', url: 'https://www.pgatour.com/pgatour-champions/leaderboard' },
  { date: '2026-02-14', time: '3:00 pm', startTime: '15:00', endTime: '18:00', home: 'Chubb', away: '2nd Round', channel: 'GOLF', url: 'https://www.pgatour.com/pgatour-champions/leaderboard' },
  { date: '2026-02-15', time: '3:00 pm', startTime: '15:00', endTime: '18:00', home: 'Chubb', away: 'Final Round', channel: 'GOLF', url: 'https://www.pgatour.com/pgatour-champions/leaderboard' },
  { date: '2026-03-06', time: '11:30 am', startTime: '11:30', endTime: '14:30', home: 'Football HOF', away: '1st Round', channel: 'GOLF', url: 'https://www.pgatour.com/pgatour-champions/leaderboard' },
  { date: '2026-03-07', time: '3:30 pm', startTime: '15:30', endTime: '18:30', home: 'Football HOF', away: '2nd Round', channel: 'GOLF', url: 'https://www.pgatour.com/pgatour-champions/leaderboard' },
  { date: '2026-03-08', time: '2:30 pm', startTime: '14:30', endTime: '17:30', home: 'Football HOF', away: 'Final Round', channel: 'GOLF', url: 'https://www.pgatour.com/pgatour-champions/leaderboard' },
  { date: '2026-03-20', time: '', startTime: '', endTime: '', home: 'Cologuard', away: '1st Round', channel: 'GOLF', url: 'https://www.pgatour.com/pgatour-champions/leaderboard' },
  { date: '2026-03-21', time: '', startTime: '', endTime: '', home: 'Cologuard', away: '2nd Round', channel: 'GOLF', url: 'https://www.pgatour.com/pgatour-champions/leaderboard' },
  { date: '2026-03-22', time: '', startTime: '', endTime: '', home: 'Cologuard', away: 'Final Round', channel: 'GOLF', url: 'https://www.pgatour.com/pgatour-champions/leaderboard' },
  { date: '2026-03-27', time: '', startTime: '', endTime: '', home: 'Hoag', away: '1st Round', channel: 'GOLF', url: 'https://www.pgatour.com/pgatour-champions/leaderboard' },
  { date: '2026-03-28', time: '', startTime: '', endTime: '', home: 'Hoag', away: '2nd Round', channel: 'GOLF', url: 'https://www.pgatour.com/pgatour-champions/leaderboard' },
  { date: '2026-03-29', time: '', startTime: '', endTime: '', home: 'Hoag', away: 'Final Round', channel: 'GOLF', url: 'https://www.pgatour.com/pgatour-champions/leaderboard' },
  { date: '2026-04-16', time: '', startTime: '', endTime: '', home: 'Sr. PGA Championship', away: '1st Round', channel: 'GOLF', url: 'https://www.pgatour.com/pgatour-champions/leaderboard' },
  { date: '2026-04-17', time: '', startTime: '', endTime: '', home: 'Sr. PGA Championship', away: '2nd Round', channel: 'GOLF', url: 'https://www.pgatour.com/pgatour-champions/leaderboard' },
  { date: '2026-04-18', time: '', startTime: '', endTime: '', home: 'Sr. PGA Championship', away: '3rd Round', channel: 'NBC, GOLF', url: 'https://www.pgatour.com/pgatour-champions/leaderboard' },
  { date: '2026-04-19', time: '', startTime: '', endTime: '', home: 'Sr. PGA Championship', away: 'Final Round', channel: 'NBC, GOLF', url: 'https://www.pgatour.com/pgatour-champions/leaderboard' },
  { date: '2026-04-24', time: '', startTime: '', endTime: '', home: 'Mitsubishi', away: '1st Round', channel: 'GOLF', url: 'https://www.pgatour.com/pgatour-champions/leaderboard' },
  { date: '2026-04-25', time: '', startTime: '', endTime: '', home: 'Mitsubishi', away: '2nd Round', channel: 'GOLF', url: 'https://www.pgatour.com/pgatour-champions/leaderboard' },
  { date: '2026-04-26', time: '', startTime: '', endTime: '', home: 'Mitsubishi', away: 'Final Round', channel: 'GOLF', url: 'https://www.pgatour.com/pgatour-champions/leaderboard' },
  { date: '2026-04-30', time: '11:00 am', startTime: '11:00', endTime: '14:00', home: 'Regions', away: '1st Round', channel: 'GOLF', url: 'https://www.pgatour.com/pgatour-champions/leaderboard' },
  { date: '2026-05-01', time: '11:00 am', startTime: '11:00', endTime: '14:00', home: 'Regions', away: '2nd Round', channel: 'GOLF', url: 'https://www.pgatour.com/pgatour-champions/leaderboard' },
  { date: '2026-05-02', time: '2:00 pm', startTime: '14:00', endTime: '17:00', home: 'Regions', away: '3rd Round', channel: 'GOLF', url: 'https://www.pgatour.com/pgatour-champions/leaderboard' },
  { date: '2026-05-03', time: '2:00 pm', startTime: '14:00', endTime: '17:00', home: 'Regions', away: 'Final Round', channel: 'GOLF', url: 'https://www.pgatour.com/pgatour-champions/leaderboard' },
  { date: '2026-05-08', time: '', startTime: '', endTime: '', home: 'Insperity', away: '1st Round', channel: 'GOLF', url: 'https://www.pgatour.com/pgatour-champions/leaderboard' },
  { date: '2026-05-09', time: '', startTime: '', endTime: '', home: 'Insperity', away: '2nd Round', channel: 'GOLF', url: 'https://www.pgatour.com/pgatour-champions/leaderboard' },
  { date: '2026-05-10', time: '', startTime: '', endTime: '', home: 'Insperity', away: 'Final Round', channel: 'GOLF', url: 'https://www.pgatour.com/pgatour-champions/leaderboard' },
  { date: '2026-05-21', time: '', startTime: '', endTime: '', home: 'Hassan II', away: '1st Round', channel: 'GOLF', url: 'https://www.pgatour.com/pgatour-champions/leaderboard' },
  { date: '2026-05-22', time: '', startTime: '', endTime: '', home: 'Hassan II', away: '2nd Round', channel: 'GOLF', url: 'https://www.pgatour.com/pgatour-champions/leaderboard' },
  { date: '2026-05-23', time: '', startTime: '', endTime: '', home: 'Hassan II', away: 'Final Round', channel: 'GOLF', url: 'https://www.pgatour.com/pgatour-champions/leaderboard' },
  { date: '2026-06-05', time: '', startTime: '', endTime: '', home: 'Am. Family', away: '1st Round', channel: 'GOLF', url: 'https://www.pgatour.com/pgatour-champions/leaderboard' },
  { date: '2026-06-06', time: '', startTime: '', endTime: '', home: 'Am. Family', away: '2nd Round', channel: 'GOLF', url: 'https://www.pgatour.com/pgatour-champions/leaderboard' },
  { date: '2026-06-07', time: '', startTime: '', endTime: '', home: 'Am. Family', away: 'Final Round', channel: 'GOLF', url: 'https://www.pgatour.com/pgatour-champions/leaderboard' },
  { date: '2026-06-12', time: '', startTime: '', endTime: '', home: 'Principal', away: '1st Round', channel: 'GOLF', url: 'https://www.pgatour.com/pgatour-champions/leaderboard' },
  { date: '2026-06-13', time: '', startTime: '', endTime: '', home: 'Principal', away: '2nd Round', channel: 'GOLF', url: 'https://www.pgatour.com/pgatour-champions/leaderboard' },
  { date: '2026-06-14', time: '', startTime: '', endTime: '', home: 'Principal', away: 'Final Round', channel: 'GOLF', url: 'https://www.pgatour.com/pgatour-champions/leaderboard' },
  { date: '2026-06-26', time: '', startTime: '', endTime: '', home: 'DICK\'S Open', away: '1st Round', channel: 'GOLF', url: 'https://www.pgatour.com/pgatour-champions/leaderboard' },
  { date: '2026-06-27', time: '', startTime: '', endTime: '', home: 'DICK\'S Open', away: '2nd Round', channel: 'GOLF', url: 'https://www.pgatour.com/pgatour-champions/leaderboard' },
  { date: '2026-06-28', time: '', startTime: '', endTime: '', home: 'DICK\'S Open', away: 'Final Round', channel: 'GOLF', url: 'https://www.pgatour.com/pgatour-champions/leaderboard' },
  { date: '2026-07-02', time: '', startTime: '', endTime: '', home: 'U.S Sr. Open', away: '1st Round', channel: 'GOLF', url: 'https://www.pgatour.com/pgatour-champions/leaderboard' },
  { date: '2026-07-03', time: '', startTime: '', endTime: '', home: 'U.S Sr. Open', away: '2nd Round', channel: 'GOLF', url: 'https://www.pgatour.com/pgatour-champions/leaderboard' },
  { date: '2026-07-04', time: '', startTime: '', endTime: '', home: 'U.S Sr. Open', away: '3rd Round', channel: 'NBC, GOLF', url: 'https://www.pgatour.com/pgatour-champions/leaderboard' },
  { date: '2026-07-05', time: '', startTime: '', endTime: '', home: 'U.S Sr. Open', away: 'Final Round', channel: 'NBC, GOLF', url: 'https://www.pgatour.com/pgatour-champions/leaderboard' },
  { date: '2026-07-09', time: '', startTime: '', endTime: '', home: 'Kaulig', away: '1st Round', channel: 'GOLF', url: 'https://www.pgatour.com/pgatour-champions/leaderboard' },
  { date: '2026-07-10', time: '', startTime: '', endTime: '', home: 'Kaulig', away: '2nd Round', channel: 'GOLF', url: 'https://www.pgatour.com/pgatour-champions/leaderboard' },
  { date: '2026-07-11', time: '', startTime: '', endTime: '', home: 'Kaulig', away: '3rd Round', channel: 'GOLF', url: 'https://www.pgatour.com/pgatour-champions/leaderboard' },
  { date: '2026-07-12', time: '', startTime: '', endTime: '', home: 'Kaulig', away: 'Final Round', channel: 'GOLF', url: 'https://www.pgatour.com/pgatour-champions/leaderboard' },
  { date: '2026-07-23', time: '8:30 am', startTime: '08:30', endTime: '11:30', home: 'Sr. Open', away: '1st Round', channel: 'GOLF', url: 'https://www.pgatour.com/pgatour-champions/leaderboard' },
  { date: '2026-07-24', time: '8:30 am', startTime: '08:30', endTime: '11:30', home: 'Sr. Open', away: '2nd Round', channel: 'GOLF', url: 'https://www.pgatour.com/pgatour-champions/leaderboard' },
  { date: '2026-07-25', time: '8:30 am', startTime: '08:30', endTime: '11:30', home: 'Sr. Open', away: '3rd Round', channel: 'NBC, GOLF', url: 'https://www.pgatour.com/pgatour-champions/leaderboard' },
  { date: '2026-07-26', time: '8:30 am', startTime: '08:30', endTime: '11:30', home: 'Sr. Open', away: 'Final Round', channel: 'NBC, GOLF', url: 'https://www.pgatour.com/pgatour-champions/leaderboard' },
  { date: '2026-07-31', time: '', startTime: '', endTime: '', home: 'Portugal', away: '1st Round', channel: 'GOLF', url: 'https://www.pgatour.com/pgatour-champions/leaderboard' },
  { date: '2026-08-01', time: '', startTime: '', endTime: '', home: 'Portugal', away: '2nd Round', channel: 'GOLF', url: 'https://www.pgatour.com/pgatour-champions/leaderboard' },
  { date: '2026-08-02', time: '', startTime: '', endTime: '', home: 'Portugal', away: 'Final Round', channel: 'GOLF', url: 'https://www.pgatour.com/pgatour-champions/leaderboard' },
  { date: '2026-08-14', time: '', startTime: '', endTime: '', home: 'Boeing', away: '1st Round', channel: 'GOLF', url: 'https://www.pgatour.com/pgatour-champions/leaderboard' },
  { date: '2026-08-15', time: '', startTime: '', endTime: '', home: 'Boeing', away: '2nd Round', channel: 'GOLF', url: 'https://www.pgatour.com/pgatour-champions/leaderboard' },
  { date: '2026-08-16', time: '', startTime: '', endTime: '', home: 'Boeing', away: 'Final Round', channel: 'GOLF', url: 'https://www.pgatour.com/pgatour-champions/leaderboard' },
  { date: '2026-08-21', time: '', startTime: '', endTime: '', home: 'Rogers', away: '1st Round', channel: 'GOLF', url: 'https://www.pgatour.com/pgatour-champions/leaderboard' },
  { date: '2026-08-22', time: '', startTime: '', endTime: '', home: 'Rogers', away: '2nd Round', channel: 'GOLF', url: 'https://www.pgatour.com/pgatour-champions/leaderboard' },
  { date: '2026-08-23', time: '', startTime: '', endTime: '', home: 'Rogers', away: 'Final Round', channel: 'GOLF', url: 'https://www.pgatour.com/pgatour-champions/leaderboard' },
  { date: '2026-08-28', time: '', startTime: '', endTime: '', home: 'Ally', away: '1st Round', channel: 'GOLF', url: 'https://www.pgatour.com/pgatour-champions/leaderboard' },
  { date: '2026-08-29', time: '', startTime: '', endTime: '', home: 'Ally', away: '2nd Round', channel: 'GOLF', url: 'https://www.pgatour.com/pgatour-champions/leaderboard' },
  { date: '2026-08-30', time: '', startTime: '', endTime: '', home: 'Ally', away: 'Final Round', channel: 'GOLF', url: 'https://www.pgatour.com/pgatour-champions/leaderboard' },
  { date: '2026-09-11', time: '', startTime: '', endTime: '', home: 'Sanford', away: '1st Round', channel: 'GOLF', url: 'https://www.pgatour.com/pgatour-champions/leaderboard' },
  { date: '2026-09-12', time: '', startTime: '', endTime: '', home: 'Sanford', away: '2nd Round', channel: 'GOLF', url: 'https://www.pgatour.com/pgatour-champions/leaderboard' },
  { date: '2026-09-13', time: '', startTime: '', endTime: '', home: 'Sanford', away: 'Final Round', channel: 'GOLF', url: 'https://www.pgatour.com/pgatour-champions/leaderboard' },
  { date: '2026-09-18', time: '', startTime: '', endTime: '', home: 'PURE', away: '1st Round', channel: 'GOLF', url: 'https://www.pgatour.com/pgatour-champions/leaderboard' },
  { date: '2026-09-19', time: '', startTime: '', endTime: '', home: 'PURE', away: '2nd Round', channel: 'GOLF', url: 'https://www.pgatour.com/pgatour-champions/leaderboard' },
  { date: '2026-09-20', time: '', startTime: '', endTime: '', home: 'PURE', away: 'Final Round', channel: 'GOLF', url: 'https://www.pgatour.com/pgatour-champions/leaderboard' },
  { date: '2026-10-02', time: '', startTime: '', endTime: '', home: 'Lehigh Valley', away: '1st Round', channel: 'GOLF', url: 'https://www.pgatour.com/pgatour-champions/leaderboard' },
  { date: '2026-10-03', time: '', startTime: '', endTime: '', home: 'Lehigh Valley', away: '2nd Round', channel: 'GOLF', url: 'https://www.pgatour.com/pgatour-champions/leaderboard' },
  { date: '2026-10-04', time: '', startTime: '', endTime: '', home: 'Lehigh Valley', away: 'Final Round', channel: 'GOLF', url: 'https://www.pgatour.com/pgatour-champions/leaderboard' },
  { date: '2026-10-09', time: '', startTime: '', endTime: '', home: ' FURYK & FRIENDS', away: '1st Round', channel: 'GOLF', url: 'https://www.pgatour.com/pgatour-champions/leaderboard' },
  { date: '2026-10-10', time: '', startTime: '', endTime: '', home: ' FURYK & FRIENDS', away: '2nd Round', channel: 'GOLF', url: 'https://www.pgatour.com/pgatour-champions/leaderboard' },
  { date: '2026-10-11', time: '', startTime: '', endTime: '', home: ' FURYK & FRIENDS', away: 'Final Round', channel: 'GOLF', url: 'https://www.pgatour.com/pgatour-champions/leaderboard' },
  { date: '2026-10-16', time: '', startTime: '', endTime: '', home: 'SAS', away: '1st Round', channel: 'GOLF', url: 'https://www.pgatour.com/pgatour-champions/leaderboard' },
  { date: '2026-10-17', time: '', startTime: '', endTime: '', home: 'SAS', away: '2nd Round', channel: 'GOLF', url: 'https://www.pgatour.com/pgatour-champions/leaderboard' },
  { date: '2026-10-18', time: '', startTime: '', endTime: '', home: 'SAS', away: 'Final Round', channel: 'GOLF', url: 'https://www.pgatour.com/pgatour-champions/leaderboard' },
  { date: '2026-10-23', time: '', startTime: '', endTime: '', home: 'Stifel', away: '1st Round', channel: 'GOLF', url: 'https://www.pgatour.com/pgatour-champions/leaderboard' },
  { date: '2026-10-24', time: '', startTime: '', endTime: '', home: 'Stifel', away: '2nd Round', channel: 'GOLF', url: 'https://www.pgatour.com/pgatour-champions/leaderboard' },
  { date: '2026-10-25', time: '', startTime: '', endTime: '', home: 'Stifel', away: 'Final Round', channel: 'GOLF', url: 'https://www.pgatour.com/pgatour-champions/leaderboard' },
  { date: '2026-10-30', time: '', startTime: '', endTime: '', home: 'Simmons', away: '1st Round', channel: 'GOLF', url: 'https://www.pgatour.com/pgatour-champions/leaderboard' },
  { date: '2026-10-31', time: '', startTime: '', endTime: '', home: 'Simmons', away: '2nd Round', channel: 'GOLF', url: 'https://www.pgatour.com/pgatour-champions/leaderboard' },
  { date: '2026-11-01', time: '', startTime: '', endTime: '', home: 'Simmons', away: 'Final Round', channel: 'GOLF', url: 'https://www.pgatour.com/pgatour-champions/leaderboard' },
  { date: '2026-11-12', time: '', startTime: '', endTime: '', home: 'Charles Schwab ', away: '', channel: 'GOLF', url: 'https://www.pgatour.com/pgatour-champions/leaderboard' },
  { date: '2026-11-13', time: '', startTime: '', endTime: '', home: 'Charles Schwab ', away: '', channel: 'GOLF', url: 'https://www.pgatour.com/pgatour-champions/leaderboard' },
  { date: '2026-11-14', time: '', startTime: '', endTime: '', home: 'Charles Schwab ', away: '', channel: 'GOLF', url: 'https://www.pgatour.com/pgatour-champions/leaderboard' },
  { date: '2026-11-15', time: '', startTime: '', endTime: '', home: 'Charles Schwab ', away: '', channel: 'GOLF', url: 'https://www.pgatour.com/pgatour-champions/leaderboard' },
  { date: '2026-12-19', time: '2:30 pm', startTime: '14:30', endTime: '17:30', home: 'PNC', away: '1st Round', channel: 'NBC, Peacock', url: 'https://www.pgatour.com/pgatour-champions/leaderboard' },
  { date: '2026-12-20', time: '1:30 pm', startTime: '13:30', endTime: '16:30', home: 'PNC', away: 'Final Round', channel: 'NBC, Peacock', url: 'https://www.pgatour.com/pgatour-champions/leaderboard' }
],
      
               
      
            // Add more leagues here as needed: Boxing, UFC, PGATour, LPGATour, PGATourChampions, NASCARCupSeries, DPWorldTour, LIVGolf, IMSASportsCar
        };
          
          const leagueDisplayNameMap = {
            'Boxing': 'Boxing',
            'UFC': 'UFC',
            'PGATour': 'PGA Tour',
            'LPGATour': 'LPGA Tour',
            'Tennis': 'Tennis',
            'PGATourChampions': 'PGA Champions',
            'NASCARCupSeries': 'NASCAR Cup Series',
            'DPWorldTour': 'DP World Tour',
            'LIVGolf': 'LIV Golf',
            'IMSASportsCar': 'IMSA SportsCar',
            'CFB': 'CFB'
          };
          
          if (Hardcoded_Today_Schedules[leagueKey]) {
            const leagueGames = Hardcoded_Today_Schedules[leagueKey].filter(g => g.date === gameDate);
            if (leagueGames[gameIndex]) {
              const originalGame = leagueGames[gameIndex];
              const leagueDisplayName = leagueDisplayNameMap[leagueKey] || leagueKey;
              
              gameData = {
                'Game ID': gameIdStr,
                'Away Team': originalGame.away,
                'Home Team': originalGame.home,
                'League': leagueDisplayName,
                'Sport': leagueKey === 'Tennis' ? 'Tennis' : (leagueKey.includes('Golf') ? 'Golf' : (leagueKey.includes('PGA') ? 'Golf' : (leagueKey === 'Boxing' || leagueKey === 'UFC' ? 'Combat' : 'Racing'))),
                'Match Status': 'SCHEDULED',
                'gameDate': gameDate,
                'channel': originalGame.channel || '',
                'Channel': originalGame.channel || '',
                'hardcodedTodayUrl': originalGame.url || '',
                'isHardcodedToday': true
              };
            }
          }
        }
        
        if (!gameData) {
          return res.status(404).json({ error: `Hardcoded game ${gameIdStr} not found in Hardcoded_Today_Schedules` });
        }
      } else {
        // Regular game - fetch from sportsGames or sportsGamesFuture based on date
        let gameDoc;
        if (isFutureDate) {
          // Future date: fetch from sportsGamesFuture
          gameDoc = await futureGamesRef.doc(gameIdStr).get();
          if (!gameDoc.exists) {
            return res.status(404).json({ error: `Game ${gameIdStr} not found in sportsGamesFuture collection for date ${dateStr}` });
          }
          // Verify the game's gameDate matches the requested date
          const gameDataFromDoc = gameDoc.data();
          if (gameDataFromDoc.gameDate !== dateStr) {
            return res.status(404).json({ error: `Game ${gameIdStr} in sportsGamesFuture has gameDate ${gameDataFromDoc.gameDate}, but requested date is ${dateStr}` });
          }
        } else {
          // Today or past: fetch from sportsGames
          gameDoc = await gamesRef.doc(gameIdStr).get();
          if (!gameDoc.exists) {
            return res.status(404).json({ error: `Game ${gameIdStr} not found in sportsGames collection` });
          }
        }
        
        gameData = gameDoc.data();
      }
      
      const featuredData = {
        ...gameData,
        gameDate: dateStr,
        'Game ID': gameIdStr
      };
      const sanitized = stripUndefinedForFirestore(featuredData);
      await docRef.set(sanitized);
      
      // Clear the featured games cache for this date to force refresh
      if (featuredGamesCache.has(dateStr)) {
        featuredGamesCache.delete(dateStr);
        featuredGamesCacheExpiry.delete(dateStr);
        console.log(`[toggleFeatured] Cleared featured games cache for ${dateStr} after adding game`);
      }
      
      res.status(200).json({
        success: true,
        message: 'Game added to Featured collection',
        gameId: gameIdStr,
        gameDate: dateStr
      });
    } else {
      // Remove from Featured collection
      const doc = await docRef.get();
      
      if (!doc.exists) {
        return res.status(404).json({ error: `Game ${gameIdStr} not found in Featured collection` });
      }
      
      await docRef.delete();
      
      // Clear the featured games cache for this date to force refresh
      if (featuredGamesCache.has(dateStr)) {
        featuredGamesCache.delete(dateStr);
        featuredGamesCacheExpiry.delete(dateStr);
        console.log(`[toggleFeatured] Cleared featured games cache for ${dateStr} after removing game`);
      }
      
      res.status(200).json({
        success: true,
        message: 'Game removed from Featured collection',
        gameId: gameIdStr,
        gameDate: dateStr
      });
    }
  } catch (error) {
    console.error('Error toggling featured status:', error);
    res.status(500).json({
      error: 'Failed to toggle featured status',
      details: error.message
    });
  }
};

// Update header text for a featured game
const updateFeaturedHeaderHandler = async (req, res) => {
  try {
    const { gameId, gameDate, headerText, applyToAllLeague } = req.body;
    
    if (!gameId) {
      return res.status(400).json({ error: 'gameId is required' });
    }
    
    // Compute gameDate if not provided (use America/New_York timezone)
    let dateStr = gameDate;
    if (!dateStr) {
      const now = new Date();
      dateStr = now.toLocaleDateString('en-CA', { timeZone: 'America/New_York' });
    }
    
    const db = admin.firestore();
    const featuredRef = db.collection('artifacts/flashlive-daily-scraper/public/data/Featured');
    
    const gameIdStr = String(gameId);
    const docId = `${dateStr}_${gameIdStr}`;
    const docRef = featuredRef.doc(docId);
    
    // Check if the game exists in Featured collection
    const doc = await docRef.get();
    
    if (!doc.exists) {
      return res.status(404).json({ error: `Game ${gameIdStr} not found in Featured collection` });
    }
    
    // Update the document with header text (save both field names for compatibility)
    const headerTextValue = headerText || '';
    await docRef.update({
      headerText: headerTextValue,
      'Header Text': headerTextValue,
      applyToAllLeague: applyToAllLeague || false
    });
    
    // If applyToAllLeague is true, update all other featured games in the same league
    if (applyToAllLeague && headerText) {
      const gameData = doc.data();
      const league = gameData.League || gameData.league;
      
      if (league) {
        const leagueGamesSnapshot = await featuredRef
          .where('gameDate', '==', dateStr)
          .where('League', '==', league)
          .get();
        
        const batch = db.batch();
        leagueGamesSnapshot.forEach(leagueDoc => {
          if (leagueDoc.id !== docId) {
            batch.update(leagueDoc.ref, {
              headerText: headerTextValue,
              'Header Text': headerTextValue,
              applyToAllLeague: false // Don't propagate the applyToAllLeague flag
            });
          }
        });
        
        if (!leagueGamesSnapshot.empty) {
          await batch.commit();
        }
      }
    }
    
    // Clear the featured games cache for this date to force refresh
    if (featuredGamesCache.has(dateStr)) {
      featuredGamesCache.delete(dateStr);
      featuredGamesCacheExpiry.delete(dateStr);
      console.log(`[updateFeaturedHeader] Cleared featured games cache for ${dateStr} after updating header text`);
    }
    
    res.status(200).json({
      success: true,
      message: 'Header text updated',
      gameId: gameIdStr,
      gameDate: dateStr,
      headerText: headerText || '',
      applyToAllLeague: applyToAllLeague || false
    });
  } catch (error) {
    console.error('Error updating featured header:', error);
    res.status(500).json({
      error: 'Failed to update header text',
      details: error.message
    });
  }
};

// Update league importance for all featured games in a league
const updateLeagueImportanceHandler = async (req, res) => {
  try {
    const { league, gameDate, leagueImportance } = req.body;
    
    if (!league) {
      return res.status(400).json({ error: 'league is required' });
    }
    
    if (leagueImportance !== null && leagueImportance !== undefined) {
      const importanceNum = Number(leagueImportance);
      if (isNaN(importanceNum) || importanceNum < 1 || importanceNum > 99) {
        return res.status(400).json({ error: 'leagueImportance must be a number between 1 and 99' });
      }
    }
    
    // Compute gameDate if not provided (use America/New_York timezone)
    let dateStr = gameDate;
    if (!dateStr) {
      const now = new Date();
      dateStr = now.toLocaleDateString('en-CA', { timeZone: 'America/New_York' });
    }
    
    const db = admin.firestore();
    const featuredRef = db.collection('artifacts/flashlive-daily-scraper/public/data/Featured');
    
    // Find all featured games for this league and date
    const leagueGamesSnapshot = await featuredRef
      .where('gameDate', '==', dateStr)
      .where('League', '==', league)
      .get();
    
    if (leagueGamesSnapshot.empty) {
      return res.status(404).json({ error: `No featured games found for league "${league}" on ${dateStr}. Please mark at least one game as Featured first.` });
    }
    
    // Update all games in the league with the new importance value
    const batch = db.batch();
    const importanceValue = leagueImportance !== null && leagueImportance !== undefined ? Number(leagueImportance) : null;
    
    leagueGamesSnapshot.forEach(doc => {
      const updateData = {};
      if (importanceValue !== null) {
        updateData.leagueImportance = importanceValue;
        updateData['League Importance'] = importanceValue;
      } else {
        // Remove importance if null/undefined
        updateData.leagueImportance = null;
        updateData['League Importance'] = null;
      }
      batch.update(doc.ref, updateData);
    });
    
    await batch.commit();
    
    // Clear the featured games cache for this date to force refresh
    if (featuredGamesCache.has(dateStr)) {
      featuredGamesCache.delete(dateStr);
      featuredGamesCacheExpiry.delete(dateStr);
      console.log(`[updateLeagueImportance] Cleared featured games cache for ${dateStr} after updating league importance`);
    }
    
    res.status(200).json({
      success: true,
      message: `Updated league importance for ${leagueGamesSnapshot.size} game(s)`,
      league: league,
      gameDate: dateStr,
      leagueImportance: importanceValue,
      gamesUpdated: leagueGamesSnapshot.size
    });
  } catch (error) {
    console.error('Error updating league importance:', error);
    res.status(500).json({
      error: 'Failed to update league importance',
      details: error.message
    });
  }
};

app.post('/perspectives/addManualPost', addManualPostHandler);
app.get('/perspectives/getGameSocialPosts', getGameSocialPostsHandler);
app.post('/perspectives/matchPost', matchPostHandler);
app.post('/perspectives/toggleFeatured', toggleFeaturedHandler);
app.post('/perspectives/updateFeaturedHeader', updateFeaturedHeaderHandler);
app.post('/perspectives/updateLeagueImportance', updateLeagueImportanceHandler);

// =================================================================
// SCRAPE THPORTH.COM CONTENT ENDPOINT
// =================================================================

/**
 * Scrape thporth.com to get all news articles, social posts, and videos
 * Returns content that can be filtered by keywords to match games
 */
const scrapeThporthContentHandler = async (req, res) => {
  let browser = null;
  try {
    const { contentType } = req.query;
    
    // Use Puppeteer to get fully rendered page (RSS.app widgets + rss-feed-service content)
    browser = await puppeteer.launch({
      headless: true,
      executablePath: process.env.PUPPETEER_EXECUTABLE_PATH || undefined,
      args: [
        '--no-sandbox',
        '--disable-setuid-sandbox',
        '--disable-dev-shm-usage',
        '--disable-accelerated-2d-canvas',
        '--disable-gpu'
      ]
    });
    
    const page = await browser.newPage();
    await page.goto('https://thporth.com', { waitUntil: 'networkidle2', timeout: 30000 });
    await page.waitForTimeout(4000); // Wait for RSS.app widgets AND rss-feed-service feeds to load
    
    const html = await page.content();
    await browser.close();
    browser = null;
    
    const $ = cheerio.load(html);
    
    const result = {
      news: [],
      social: [],
      media: [],
      scrapedAt: new Date().toISOString()
    };
    
    // Scrape news articles from the news column
    if (!contentType || contentType === 'news' || contentType === 'all') {
      // Exact selectors from shadow.html: .news-feed-content, rssapp-feed, .rssapp-item
      $('.news-feed-content rssapp-feed .rssapp-item, .news-feed-content .rssapp-item, rssapp-feed .rssapp-item').each((i, elem) => {
        const $item = $(elem);
        const title = $item.find('.rssapp-item-title, h3').first().text().trim();
        const link = $item.find('a').first().attr('href') || '';
        const description = $item.find('.rssapp-item-content, p').first().text().trim();
        const image = $item.find('img').first().attr('src') || '';
        
        if (title) {
          result.news.push({
            id: `news_${i}_${Date.now()}`,
            title,
            description,
            link: link.startsWith('http') ? link : `https://thporth.com${link}`,
            image,
            scrapedAt: new Date().toISOString()
          });
        }
      });
      
      // Also check inside news-feed-content divs directly
      $('.news-feed-content').each((i, container) => {
        const $container = $(container);
        $container.find('.rssapp-item, article, .headlines-item').each((j, elem) => {
          const $item = $(elem);
          const title = $item.find('.rssapp-item-title, h3, h2, a').first().text().trim();
          const link = $item.find('a').first().attr('href') || '';
          const description = $item.find('.rssapp-item-content, p').first().text().trim();
          
          if (title && !result.news.find(n => n.title === title && n.link === link)) {
            result.news.push({
              id: `news_${result.news.length}_${Date.now()}`,
              title,
              description,
              link: link.startsWith('http') ? link : `https://thporth.com${link}`,
              scrapedAt: new Date().toISOString()
            });
          }
        });
      });
      
      console.log(`[scrapeThporth] Found ${result.news.length} news articles`);
    }
    
    // Scrape social posts - gets both RSS.app widgets AND rss-feed-service content
    if (!contentType || contentType === 'social' || contentType === 'all') {
      $('#social-feed-container').each((i, container) => {
        const $container = $(container);
        
        // RSS.app items
        $container.find('rssapp-feed .rssapp-item, .rssapp-item').each((j, elem) => {
          const $item = $(elem);
          const text = $item.find('.rssapp-item-content, p').first().text().trim();
          const title = $item.find('.rssapp-item-title, h3').first().text().trim();
          const link = $item.find('a').first().attr('href') || '';
          const image = $item.find('img').first().attr('src') || '';
          const platform = link.includes('twitter.com') ? 'twitter' :
                          link.includes('x.com') ? 'x' :
                          link.includes('reddit.com') ? 'reddit' : 'unknown';
          
          if (text || title) {
            result.social.push({
              id: `social_${result.social.length}_${Date.now()}`,
              text: text || title,
              title: title || text,
              description: text || title,
              link: link.startsWith('http') ? link : `https://thporth.com${link}`,
              image,
              platform,
              scrapedAt: new Date().toISOString()
            });
          }
        });
        
        // Regular RSS feed items (from rss-feed-service)
        $container.find('li, article, .item').each((j, elem) => {
          const $item = $(elem);
          const text = $item.find('p, .description').first().text().trim();
          const title = $item.find('h3, h2, a').first().text().trim();
          const link = $item.find('a').first().attr('href') || '';
          
          if ((text || title) && !result.social.find(s => s.link === link && link)) {
            result.social.push({
              id: `social_${result.social.length}_${Date.now()}`,
              text: text || title,
              title: title || text,
              description: text || title,
              link: link.startsWith('http') ? link : `https://thporth.com${link}`,
              scrapedAt: new Date().toISOString()
            });
          }
        });
      });
      
      console.log(`[scrapeThporth] Found ${result.social.length} social posts`);
    }
    
    // Scrape videos/media - gets both RSS.app widgets AND rss-feed-service content
    if (!contentType || contentType === 'media' || contentType === 'all') {
      $('#videos-content, #dynamicVideosContent').each((i, container) => {
        const $container = $(container);
        
        // Video items
        $container.find('.video-item').each((j, elem) => {
          const $item = $(elem);
          const title = $item.find('h3, h2, a').first().text().trim();
          const link = $item.find('a').first().attr('href') || '';
          const thumbnail = $item.find('img.video-thumbnail, img').first().attr('src') || '';
          
          if (title || link) {
            result.media.push({
              id: `media_${result.media.length}_${Date.now()}`,
              title: title || 'Video',
              link: link.startsWith('http') ? link : `https://thporth.com${link}`,
              thumbnail,
              scrapedAt: new Date().toISOString()
            });
          }
        });
        
        // RSS.app video items
        $container.find('rssapp-feed .rssapp-item').each((j, elem) => {
          const $item = $(elem);
          const title = $item.find('.rssapp-item-title, h3').first().text().trim();
          const link = $item.find('a').first().attr('href') || '';
          const thumbnail = $item.find('img').first().attr('src') || '';
          
          if (title && !result.media.find(m => m.title === title && m.link === link)) {
            result.media.push({
              id: `media_${result.media.length}_${Date.now()}`,
              title,
              link: link.startsWith('http') ? link : `https://thporth.com${link}`,
              thumbnail,
              scrapedAt: new Date().toISOString()
            });
          }
        });
        
        // Regular RSS feed items (from rss-feed-service)
        $container.find('li, article, .item').each((j, elem) => {
          const $item = $(elem);
          const title = $item.find('h3, h2, a').first().text().trim();
          const link = $item.find('a').first().attr('href') || '';
          const thumbnail = $item.find('img').first().attr('src') || '';
          
          if (title && !result.media.find(m => m.title === title && m.link === link)) {
            result.media.push({
              id: `media_${result.media.length}_${Date.now()}`,
              title,
              link: link.startsWith('http') ? link : `https://thporth.com${link}`,
              thumbnail,
              scrapedAt: new Date().toISOString()
            });
          }
        });
      });
      
      // YouTube embeds
      $('iframe[src*="youtube.com"], iframe[src*="youtu.be"]').each((i, elem) => {
        const $iframe = $(elem);
        const src = $iframe.attr('src') || '';
        const videoId = src.match(/(?:youtube\.com\/embed\/|youtu\.be\/)([^?&]+)/)?.[1];
        
        if (videoId && !result.media.find(m => m.link && m.link.includes(videoId))) {
          result.media.push({
            id: `media_youtube_${i}_${Date.now()}`,
            title: $iframe.attr('title') || 'YouTube Video',
            link: `https://www.youtube.com/watch?v=${videoId}`,
            thumbnail: `https://img.youtube.com/vi/${videoId}/hqdefault.jpg`,
            platform: 'youtube',
            scrapedAt: new Date().toISOString()
          });
        }
      });
      
      console.log(`[scrapeThporth] Found ${result.media.length} media items`);
    }
    
    // Filter by contentType if specified
    if (contentType && contentType !== 'all') {
      res.status(200).json({
        success: true,
        contentType,
        items: result[contentType],
        count: result[contentType].length
      });
    } else {
      res.status(200).json({
        success: true,
        ...result,
        totalNews: result.news.length,
        totalSocial: result.social.length,
        totalMedia: result.media.length
      });
    }
    
  } catch (error) {
    console.error('[scrapeThporth] Error scraping thporth.com:', error);
    if (browser) {
      try {
        await browser.close();
      } catch (e) {
        console.error('[scrapeThporth] Error closing browser:', e);
      }
    }
    res.status(500).json({
      error: 'Failed to scrape thporth.com',
      details: error.message
    });
  }
};

app.get('/scrapeThporth', scrapeThporthContentHandler);
app.post('/scrapeThporth', scrapeThporthContentHandler);

// =================================================================
// PERSPECTIVES PIPELINE ENDPOINT
// =================================================================

const perspectivesPipelineHandler = async (req, res) => {
  try {
    const { runPerspectivesPipeline } = await import('./perspectives-pipeline.js');
    
    const {
      league,
      keywordSource, // Can be local file path (e.g., './nhl-keywords.csv') or Google Sheets CSV URL
      contentSources = null, // null = auto-load from perspectives-feed-config.js
      gameDate = null
    } = req.body;
    
    if (!league || !keywordSource) {
      return res.status(400).json({
        error: 'league and keywordSource are required',
        examples: {
          googleSheets: {
            league: 'NHL',
            keywordSource: 'https://docs.google.com/spreadsheets/d/SPREADSHEET_ID/export?gid=0&format=csv',
            contentSources: null // null = auto-load from perspectives-feed-config.js
          },
          localFile: {
            league: 'NHL',
            keywordSource: './nhl-keywords.csv',
            contentSources: null
          }
        }
      });
    }
    
    await runPerspectivesPipeline({
      league,
      keywordSource,
      contentSources,
      gameDate
    });
    
    res.status(200).json({
      success: true,
      message: `Perspectives pipeline completed for ${league}`
    });
  } catch (error) {
    console.error('[perspectivesPipeline] Error:', error);
    res.status(500).json({
      error: 'Failed to run Perspectives pipeline',
      details: error.message
    });
  }
};

app.post('/perspectives/runPipeline', perspectivesPipelineHandler);
app.get('/perspectives/runPipeline', perspectivesPipelineHandler);

// =================================================================
// LIVE SCORES JSON ENDPOINT
// =================================================================

// In-memory cache for today's games JSON
let todayGamesCache = null;
let todayGamesCacheTimestamp = null;
const TODAY_GAMES_CACHE_TTL = 120000; // 2 minutes cache (matches backend update frequency)

/**
 * Generate JSON object with all today's games from Firestore
 * Only reads from Firestore once, caches result for 5 seconds
 */
async function generateTodayGamesJSON() {
  const now = Date.now();
  
  // Return cached data if still valid
  if (todayGamesCache && todayGamesCacheTimestamp && (now - todayGamesCacheTimestamp) < TODAY_GAMES_CACHE_TTL) {
    return todayGamesCache;
  }
  
  const db = initializeFirebase();
  const todayStr = DateTime.now().setZone('America/New_York').toISODate();
  
  try {
    console.log(`[today.json] Fetching games for ${todayStr} from Firestore...`);
    
    const gamesRef = db.collection(`artifacts/flashlive-daily-scraper/public/data/sportsGames`);
    const snapshot = await gamesRef.where('gameDate', '==', todayStr).get();
    
    const games = [];
    snapshot.forEach(doc => {
      const data = doc.data();
      // Preserve original Firestore field names to match frontend expectations
      const gameData = {
        'Game ID': doc.id,
        ...data // Spread all original fields
      };
      games.push(gameData);
    });
    
    const result = {
      lastUpdated: new Date().toISOString(),
      date: todayStr,
      gameCount: games.length,
      games: games
    };
    
    // Update cache
    todayGamesCache = result;
    todayGamesCacheTimestamp = now;
    
    console.log(`[today.json] Generated JSON with ${games.length} games`);
    return result;
  } catch (error) {
    console.error('[today.json] Error generating JSON:', error);
    // Return cached data if available, even if expired
    if (todayGamesCache) {
      console.log('[today.json] Returning cached data due to error');
      return todayGamesCache;
    }
    throw error;
  }
}

/**
 * Handler for /data/today.json endpoint
 * Serves live games data as JSON
 */
const todayGamesJSONHandler = async (req, res) => {
  try {
    const json = await generateTodayGamesJSON();
    
    // Set CORS headers to allow frontend access
    res.set('Access-Control-Allow-Origin', '*');
    res.set('Access-Control-Allow-Methods', 'GET, OPTIONS');
    res.set('Access-Control-Allow-Headers', 'Content-Type, Cache-Control, Pragma');
    res.set('Content-Type', 'application/json');
    // Cache for 2 minutes (120 seconds) - matches live polling frequency
    res.set('Cache-Control', 'public, max-age=120, s-maxage=120');
    
    res.status(200).json(json);
  } catch (error) {
    console.error('[today.json] Handler error:', error);
    res.status(500).json({
      error: 'Failed to generate today\'s games JSON',
      message: error.message
    });
  }
};

// Handle OPTIONS requests for CORS preflight
app.options('/data/today.json', (req, res) => {
  res.set('Access-Control-Allow-Origin', '*');
  res.set('Access-Control-Allow-Methods', 'GET, OPTIONS');
  res.set('Access-Control-Allow-Headers', 'Content-Type, Cache-Control, Pragma');
  res.status(204).end();
});

// Serve today's games JSON at /data/today.json
app.get('/data/today.json', todayGamesJSONHandler);
app.get('/public/data/today.json', todayGamesJSONHandler);

// =================================================================
// STATIC DATA EXPORT ENDPOINTS
// These endpoints serve static JSON files generated from Firestore
// Backend reads from Firestore once, frontend fetches from these endpoints
// =================================================================

/**
 * Helper function to serialize Firestore Timestamps and data
 */
function serializeFirestoreData(data) {
  if (data === null || data === undefined) return data;
  if (data instanceof Date) return data.toISOString();
  if (data && typeof data === 'object' && data.toDate && typeof data.toDate === 'function') {
    return data.toDate().toISOString();
  }
  if (data && typeof data === 'object' && data._seconds !== undefined) {
    return new Date(data._seconds * 1000).toISOString();
  }
  if (Array.isArray(data)) {
    return data.map(serializeFirestoreData);
  }
  if (typeof data === 'object') {
    const result = {};
    for (const key in data) {
      result[key] = serializeFirestoreData(data[key]);
    }
    return result;
  }
  return data;
}

// In-memory cache for yesterday's games JSON
let yesterdayGamesCache = null;
let yesterdayGamesCacheExpiry = null; // Epoch ms when cache expires (next 3:55 AM ET)

/**
 * Get the next 3:55 AM ET timestamp (when index.js runs and updates data)
 */
function getNextPrepExpiryTimestamp() {
  try {
    const nowNY = DateTime.now().setZone('America/New_York');
    let nextRun = nowNY.set({ hour: 3, minute: 55, second: 0, millisecond: 0 });
    if (nowNY >= nextRun) {
      nextRun = nextRun.plus({ days: 1 });
    }
    return nextRun.toMillis();
  } catch (e) {
    // Fallback: 24h
    return Date.now() + 24 * 60 * 60 * 1000;
  }
}

/**
 * Generate JSON object with all yesterday's games from Firestore
 * Caches result until next 3:55 AM ET (when index.js runs)
 */
async function generateYesterdayGamesJSON() {
  const now = Date.now();
  
  // Return cached data if still valid (until next 3:55 AM ET)
  if (yesterdayGamesCache && yesterdayGamesCacheExpiry && now < yesterdayGamesCacheExpiry) {
    console.log(`[generateYesterdayGamesJSON] Returning cached data: ${yesterdayGamesCache.gameCount} games (cache expires at ${new Date(yesterdayGamesCacheExpiry).toISOString()})`);
    return yesterdayGamesCache;
  }
  
  const db = initializeFirebase();
  // Use Eastern Time to match gameDate storage (same as today.json)
  const nowInEastern = DateTime.now().setZone('America/New_York');
  const yesterdayStr = nowInEastern.minus({ days: 1 }).toISODate();
  
  console.log(`[generateYesterdayGamesJSON] Querying yesterdayScores for gameDate == "${yesterdayStr}" (Eastern Time)`);
  console.log(`[generateYesterdayGamesJSON] Current time: ${nowInEastern.toISO()} (Eastern)`);
  
  // Query yesterdayScores collection (where FINAL games are moved by morning run)
  // This includes ALL FINAL games from yesterday (both NCAA API and ESPN API leagues)
  const yesterdayScoresRef = db.collection('artifacts/flashlive-daily-scraper/public/data/yesterdayScores');
  const snapshot = await yesterdayScoresRef.where('gameDate', '==', yesterdayStr).get();
  
  console.log(`[generateYesterdayGamesJSON] Found ${snapshot.size} games in yesterdayScores for ${yesterdayStr}`);
  
  const games = [];
  const gameIdSet = new Set(); // Deduplicate by Game ID
  const canonicalKeySet = new Set(); // Deduplicate by canonicalGameKey
  
  snapshot.forEach(doc => {
    const data = doc.data();
    const gameId = data['Game ID'] || doc.id;
    const canonicalKey = data['canonicalGameKey'] || '';
    
    // Deduplicate: check both Game ID and canonicalGameKey
    // Skip if we've seen this Game ID before
    if (gameIdSet.has(gameId)) {
      return; // Skip duplicate by Game ID
    }
    
    // Skip if we've seen this canonicalGameKey before (catches games with different Game IDs but same teams/date)
    if (canonicalKey && canonicalKeySet.has(canonicalKey)) {
      return; // Skip duplicate by canonicalGameKey
    }
    
    // Add game
    gameIdSet.add(gameId);
    if (canonicalKey) {
      canonicalKeySet.add(canonicalKey);
    }
    games.push({
      'Game ID': gameId,
      ...serializeFirestoreData(data)
    });
  });
  
  const data = {
    lastUpdated: new Date().toISOString(),
    date: yesterdayStr,
    gameCount: games.length,
    games: games
  };
  
  console.log(`[generateYesterdayGamesJSON] Returning ${games.length} games for ${yesterdayStr}`);
  if (games.length === 0) {
    console.log(`[generateYesterdayGamesJSON] ‚ö†Ô∏è  WARNING: No games found in yesterdayScores for ${yesterdayStr}. Check if games were moved from sportsGames.`);
  }
  
  // Update cache (expires at next 3:55 AM ET when index.js runs)
  yesterdayGamesCache = data;
  yesterdayGamesCacheExpiry = getNextPrepExpiryTimestamp();
  
  return data;
}

// Function to move yesterday's games to yesterdayScores (reusable)
async function moveYesterdayGamesToScores() {
  const db = initializeFirebase();
  
  // Get yesterday's date in Eastern Time (matches gameDate storage)
  const nowInEastern = DateTime.now().setZone('America/New_York');
  const yesterdayStr = nowInEastern.minus({ days: 1 }).toISODate();
  
  console.log(`[moveYesterdayGamesToScores] Looking for games with gameDate == "${yesterdayStr}" (Eastern Time)`);
  console.log(`[moveYesterdayGamesToScores] Current time: ${nowInEastern.toISO()} (Eastern)`);
  
  const gamesRef = db.collection(`artifacts/flashlive-daily-scraper/public/data/sportsGames`);
  const yesterdayScoresRef = db.collection(`artifacts/flashlive-daily-scraper/public/data/yesterdayScores`);
  
  // Get ALL games from yesterday (not just FINAL)
  const snapshot = await gamesRef
    .where('gameDate', '==', yesterdayStr)
    .get();
  
  console.log(`[moveYesterdayGamesToScores] Found ${snapshot.size} games in sportsGames from yesterday (${yesterdayStr})`);
  
  // Check if games were already moved (to diagnose why move might find 0 games)
  const alreadyMovedSnapshot = await yesterdayScoresRef
    .where('gameDate', '==', yesterdayStr)
    .get();
  console.log(`[moveYesterdayGamesToScores] Already in yesterdayScores: ${alreadyMovedSnapshot.size} games`);
  
  // If we found 0 games but there are already games in yesterdayScores, that's expected (already moved)
  if (snapshot.size === 0 && alreadyMovedSnapshot.size > 0) {
    console.log(`[moveYesterdayGamesToScores] ‚ö†Ô∏è  No games found in sportsGames, but ${alreadyMovedSnapshot.size} games already exist in yesterdayScores - games were likely already moved in a previous run`);
  }
  
  // If we found 0 games and there are no games in yesterdayScores, that's a problem
  if (snapshot.size === 0 && alreadyMovedSnapshot.size === 0) {
    console.log(`[moveYesterdayGamesToScores] ‚ö†Ô∏è  WARNING: No games found in sportsGames AND no games in yesterdayScores for ${yesterdayStr}. This might indicate:`);
    console.log(`[moveYesterdayGamesToScores]    1. Games from yesterday were never stored with gameDate == "${yesterdayStr}"`);
    console.log(`[moveYesterdayGamesToScores]    2. Games were deleted before this move could run`);
    console.log(`[moveYesterdayGamesToScores]    3. Timezone mismatch - games stored with different date format`);
    
    // Try to find games with nearby dates to diagnose
    const nearbySnapshot = await gamesRef
      .where('gameDate', '>=', nowInEastern.minus({ days: 2 }).toISODate())
      .where('gameDate', '<=', nowInEastern.toISODate())
      .get();
    console.log(`[moveYesterdayGamesToScores]    Found ${nearbySnapshot.size} games with dates between ${nowInEastern.minus({ days: 2 }).toISODate()} and ${nowInEastern.toISODate()}`);
    if (nearbySnapshot.size > 0) {
      const dateCounts = {};
      nearbySnapshot.forEach(doc => {
        const date = doc.data().gameDate || 'unknown';
        dateCounts[date] = (dateCounts[date] || 0) + 1;
      });
      console.log(`[moveYesterdayGamesToScores]    Date breakdown:`, dateCounts);
    }
  }
  
  let movedCount = 0;
  let skippedCount = 0;
  const gameIdSet = new Set();
  const canonicalKeySet = new Set();
  
  for (const doc of snapshot.docs) {
    const data = doc.data();
    const gameId = data['Game ID'] || doc.id;
    const canonicalKey = data['canonicalGameKey'] || '';
    
    // Deduplicate
    if (gameIdSet.has(gameId)) {
      skippedCount++;
      continue;
    }
    
    if (canonicalKey && canonicalKeySet.has(canonicalKey)) {
      skippedCount++;
      continue;
    }
    
    try {
      const gameData = {
        ...data,
        gameDate: yesterdayStr
      };
      await yesterdayScoresRef.doc(String(gameId)).set(gameData, { merge: true });
      gameIdSet.add(gameId);
      if (canonicalKey) {
        canonicalKeySet.add(canonicalKey);
      }
      movedCount++;
    } catch (err) {
      console.error(`[moveYesterdayGamesToScores] Error moving game ${doc.id}:`, err);
    }
  }
  
  // Verify
  const verifySnapshot = await yesterdayScoresRef
    .where('gameDate', '==', yesterdayStr)
    .get();
  
  console.log(`[moveYesterdayGamesToScores] ‚úÖ Moved ${movedCount} games, skipped ${skippedCount} duplicates. Total in yesterdayScores: ${verifySnapshot.size}`);
  
  // CRITICAL: Clear the cache so generateYesterdayGamesJSON() will re-query with fresh data
  // Otherwise, if the cache was populated before games were moved, it will keep returning empty results
  yesterdayGamesCache = null;
  yesterdayGamesCacheExpiry = null;
  console.log(`[moveYesterdayGamesToScores] Cleared yesterdayGamesCache to force refresh on next request`);
  
  // Also clear yesterday's featured games cache (if it exists) to ensure fresh data
  // The cache will naturally expire at next morningRefresh, but clearing it ensures immediate refresh
  if (featuredGamesCache.has(yesterdayStr)) {
    featuredGamesCache.delete(yesterdayStr);
    featuredGamesCacheExpiry.delete(yesterdayStr);
    console.log(`[moveYesterdayGamesToScores] Cleared featured games cache for ${yesterdayStr} to force refresh on next request`);
  }
  
  return {
    success: true,
    moved: movedCount,
    skipped: skippedCount,
    totalInYesterdayScores: verifySnapshot.size,
    yesterdayDate: yesterdayStr
  };
}

// Fix yesterday's games endpoint - moves all games from yesterday to yesterdayScores
app.post('/fixYesterdayGames', async (req, res) => {
  try {
    console.log('--- fixYesterdayGames endpoint called ---');
    const result = await moveYesterdayGamesToScores();
    res.status(200).json({
      ...result,
      message: `Fixed yesterday's games`
    });
  } catch (error) {
    console.error('[fixYesterdayGames] Error:', error);
    res.status(500).json({
      error: 'Failed to fix yesterday games',
      message: error.message
    });
  }
});

// Serve yesterday's scores JSON
app.get('/data/yesterday.json', async (req, res) => {
  try {
    const json = await generateYesterdayGamesJSON();

    // Set CORS headers to allow frontend access
    res.set('Access-Control-Allow-Origin', '*');
    res.set('Access-Control-Allow-Methods', 'GET, OPTIONS');
    res.set('Access-Control-Allow-Headers', 'Content-Type, Cache-Control, Pragma');
    res.set('Content-Type', 'application/json');
    // Cache for 20 hours (72000 seconds) - yesterday's games only update once per day
    res.set('Cache-Control', 'public, max-age=72000, s-maxage=72000');

    res.status(200).json(json);
  } catch (error) {
    console.error('[yesterday.json] Handler error:', error);
    res.status(500).json({
      error: 'Failed to generate yesterday\'s games JSON',
      message: error.message
    });
  }
});

// In-memory cache for featured games JSON (per date)
const featuredGamesCache = new Map();
const featuredGamesCacheExpiry = new Map(); // Expiry timestamps per date
const FEATURED_GAMES_CACHE_TTL_TODAY = 120000; // 2 minutes cache for today's games (live, updating)

/**
 * Generate JSON object with featured games for a specific date from Firestore
 * - Today's games: cached for 2 minutes (live, updating)
 * - Yesterday's games: cached until next morningRefresh (3:55 AM ET) - final scores, won't change
 */
async function generateFeaturedGamesJSON(dateStr) {
  const now = Date.now();
  const todayStr = DateTime.now().setZone('America/New_York').toISODate();
  const targetDate = dateStr || todayStr;
  const cacheKey = targetDate;
  const isToday = targetDate === todayStr;
  
  // Return cached data if still valid
  const cached = featuredGamesCache.get(cacheKey);
  const cachedExpiry = featuredGamesCacheExpiry.get(cacheKey);
  if (cached && cachedExpiry && now < cachedExpiry) {
    console.log(`[featured.json] Returning cached data for ${targetDate} (expires at ${new Date(cachedExpiry).toISOString()})`);
    return cached;
  }
  
  const db = initializeFirebase();
  
  try {
    console.log(`[featured.json] Fetching featured games for ${targetDate} from Firestore...`);
    
    const featuredRef = db.collection('artifacts/flashlive-daily-scraper/public/data/Featured');
    const snapshot = await featuredRef.where('gameDate', '==', targetDate).get();
    
    // Hardcoded_Today_Schedules data structure (for enriching featured hardcoded games)
    const Hardcoded_Today_Schedules = {

      'CFB': [
{ date: '2026-01-27', time: '7:00 pm', startTime: '19:00', endTime: '22:00', away: 'East-West', home: 'Shrine Bowl', channel: 'NFL Network', url: 'https://x.com/ShrineBowl' },


],


'TGL': [
  {
    date: '2026-02-09',
    time: '7:00 pm',
    startTime: '19:00',
    endTime: '21:00',
    away: 'The Bay',
    home: 'Los Angeles',
    channel: 'ESPN2',
    url: 'https://tglgolf.com/match/2026/108?webview=1'
  },
  {
    date: '2026-02-23',
    time: '5:00 pm',
    startTime: '17:00',
    endTime: '19:00',
    away: 'Atlanta',
    home: 'Boston',
    channel: 'ESPN2',
    url: 'https://tglgolf.com/match/2026/109?webview=1'
  },
  {
    date: '2026-02-23',
    time: '9:00 pm',
    startTime: '21:00',
    endTime: '23:00',
    away: 'Los Angeles',
    home: 'Atlanta',
    channel: 'ESPN2',
    url: 'https://tglgolf.com/match/2026/110?webview=1'
  },
  {
    date: '2026-02-24',
    time: '5:00 pm',
    startTime: '17:00',
    endTime: '19:00',
    away: 'New York',
    home: 'The Bay',
    channel: 'ESPN',
    url: 'https://tglgolf.com/match/2026/111?webview=1'
  },
  {
    date: '2026-02-24',
    time: '9:00 pm',
    startTime: '21:00',
    endTime: '23:00',
    away: 'Boston',
    home: 'New York',
    channel: 'ESPN',
    url: 'https://tglgolf.com/match/2026/112?webview=1'
  },
  {
    date: '2026-03-01',
    time: '9:00 pm',
    startTime: '21:00',
    endTime: '23:00',
    away: 'Jupiter',
    home: 'Boston',
    channel: 'ESPN',
    url: 'https://tglgolf.com/match/2026/113?webview=1'
  },
  {
    date: '2026-03-02',
    time: '7:00 pm',
    startTime: '19:00',
    endTime: '21:00',
    away: 'Los Angeles',
    home: 'New York',
    channel: 'ESPN2',
    url: 'https://tglgolf.com/match/2026/114?webview=1'
  },
  {
    date: '2026-03-03',
    time: '9:00 pm',
    startTime: '21:00',
    endTime: '23:00',
    away: 'The Bay',
    home: 'Jupiter',
    channel: 'ESPN',
    url: 'https://tglgolf.com/match/2026/115?webview=1'
  }
],


  'PGATour': [
  { date: '2026-01-22', time: '11:30 am', startTime: '11:30', endTime: '17:15', home: 'The AMEX', away: 'First Round', channel: 'ESPN+, GOLF', url: 'https://www.pgatour.com/leaderboard' },
{ date: '2026-01-23', time: '11:30 am', startTime: '11:30', endTime: '17:15', home: 'The AMEX', away: 'Second Round', channel: 'ESPN+, GOLF', url: 'https://www.pgatour.com/leaderboard' },
{ date: '2026-01-24', time: '11:30 am', startTime: '11:30', endTime: '17:30', home: 'The AMEX', away: 'Third Round', channel: 'ESPN+, GOLF', url: 'https://www.pgatour.com/leaderboard' },
{ date: '2026-01-25', time: '11:30 am', startTime: '11:30', endTime: '17:30', home: 'The AMEX', away: 'Final Round', channel: 'ESPN+, GOLF', url: 'https://www.pgatour.com/leaderboard' },

{ date: '2026-01-29', time: '3:00 pm', startTime: '15:00', endTime: '20:45', home: 'Farmers', away: 'First Round', channel: 'GOLF', url: 'https://www.pgatour.com/leaderboard' },
{ date: '2026-01-30', time: '3:00 pm', startTime: '15:00', endTime: '20:45', home: 'Farmers', away: 'Second Round', channel: 'GOLF', url: 'https://www.pgatour.com/leaderboard' },
{ date: '2026-01-31', time: '3:00 pm', startTime: '15:00', endTime: '21:00', home: 'Farmers', away: 'Third Round', channel: 'CBS', url: 'https://www.pgatour.com/leaderboard' },
{ date: '2026-02-01', time: '3:00 pm', startTime: '15:00', endTime: '21:00', home: 'Farmers', away: 'Final Round', channel: 'CBS', url: 'https://www.pgatour.com/leaderboard' },

{ date: '2026-02-05', time: '1:00 pm', startTime: '13:00', endTime: '18:45', home: 'Phoenix Open', away: 'First Round', channel: 'GOLF', url: 'https://www.pgatour.com/leaderboard' },
{ date: '2026-02-06', time: '1:00 pm', startTime: '13:00', endTime: '18:45', home: 'Phoenix Open', away: 'Second Round', channel: 'GOLF', url: 'https://www.pgatour.com/leaderboard' },
{ date: '2026-02-07', time: '1:00 pm', startTime: '13:00', endTime: '19:00', home: 'Phoenix Open', away: 'Third Round', channel: 'CBS', url: 'https://www.pgatour.com/leaderboard' },
{ date: '2026-02-08', time: '1:00 pm', startTime: '13:00', endTime: '19:00', home: 'Phoenix Open', away: 'Final Round', channel: 'CBS', url: 'https://www.pgatour.com/leaderboard' },

{ date: '2026-02-12', time: '12:00 pm', startTime: '12:00', endTime: '17:45', home: 'Pebble Beach', away: 'First Round', channel: 'GOLF', url: 'https://www.pgatour.com/leaderboard' },
{ date: '2026-02-13', time: '12:00 pm', startTime: '12:00', endTime: '17:45', home: 'Pebble Beach', away: 'Second Round', channel: 'GOLF', url: 'https://www.pgatour.com/leaderboard' },
{ date: '2026-02-14', time: '12:00 pm', startTime: '12:00', endTime: '18:00', home: 'Pebble Beach', away: 'Third Round', channel: 'CBS', url: 'https://www.pgatour.com/leaderboard' },
{ date: '2026-02-15', time: '12:00 pm', startTime: '12:00', endTime: '18:00', home: 'Pebble Beach', away: 'Final Round', channel: 'CBS', url: 'https://www.pgatour.com/leaderboard' },

{ date: '2026-02-19', time: '1:00 pm', startTime: '13:00', endTime: '18:45', home: 'Genesis', away: 'First Round', channel: 'GOLF', url: 'https://www.pgatour.com/leaderboard' },
{ date: '2026-02-20', time: '1:00 pm', startTime: '13:00', endTime: '18:45', home: 'Genesis', away: 'Second Round', channel: 'GOLF', url: 'https://www.pgatour.com/leaderboard' },
{ date: '2026-02-21', time: '12:00 pm', startTime: '12:00', endTime: '18:00', home: 'Genesis', away: 'Third Round', channel: 'CBS', url: 'https://www.pgatour.com/leaderboard' },
{ date: '2026-02-22', time: '12:00 pm', startTime: '12:00', endTime: '18:00', home: 'Genesis', away: 'Final Round', channel: 'CBS', url: 'https://www.pgatour.com/leaderboard' },

{ date: '2026-02-26', time: '', startTime: '', endTime: '', home: 'Cognizant', away: 'First Round', channel: 'GOLF', url: 'https://www.pgatour.com/leaderboard' },
{ date: '2026-02-27', time: '', startTime: '', endTime: '', home: 'Cognizant', away: 'Second Round', channel: 'GOLF', url: 'https://www.pgatour.com/leaderboard' },
{ date: '2026-02-28', time: '3:00 pm', startTime: '15:00', endTime: '21:00', home: 'Cognizant', away: 'Third Round', channel: 'NBC', url: 'https://www.pgatour.com/leaderboard' },
{ date: '2026-03-01', time: '3:00 pm', startTime: '15:00', endTime: '21:00', home: 'Cognizant', away: 'Final Round', channel: 'NBC', url: 'https://www.pgatour.com/leaderboard' },

{ date: '2026-03-05', time: '2:00 pm', startTime: '14:00', endTime: '19:45', home: 'Arnold Palmer', away: 'First Round', channel: 'GOLF', url: 'https://www.pgatour.com/leaderboard' },
{ date: '2026-03-06', time: '2:00 pm', startTime: '14:00', endTime: '19:45', home: 'Arnold Palmer', away: 'Second Round', channel: 'GOLF', url: 'https://www.pgatour.com/leaderboard' },
{ date: '2026-03-07', time: '2:30 pm', startTime: '14:30', endTime: '20:30', home: 'Arnold Palmer', away: 'Third Round', channel: 'NBC', url: 'https://www.pgatour.com/leaderboard' },
{ date: '2026-03-08', time: '2:30 pm', startTime: '14:30', endTime: '20:30', home: 'Arnold Palmer', away: 'Final Round', channel: 'NBC', url: 'https://www.pgatour.com/leaderboard' },

{ date: '2026-03-12', time: '1:00 pm', startTime: '13:00', endTime: '18:45', home: 'THE PLAYERS', away: 'First Round', channel: 'GOLF', url: 'https://www.pgatour.com/leaderboard' },
{ date: '2026-03-13', time: '1:00 pm', startTime: '13:00', endTime: '18:45', home: 'THE PLAYERS', away: 'Second Round', channel: 'GOLF', url: 'https://www.pgatour.com/leaderboard' },
{ date: '2026-03-14', time: '2:00 pm', startTime: '14:00', endTime: '20:00', home: 'THE PLAYERS', away: 'Third Round', channel: 'NBC', url: 'https://www.pgatour.com/leaderboard' },
{ date: '2026-03-15', time: '1:00 pm', startTime: '13:00', endTime: '19:00', home: 'THE PLAYERS', away: 'Final Round', channel: 'NBC', url: 'https://www.pgatour.com/leaderboard' },
],

'UFC': [
  { date: '2026-01-24', time: '5:00 PM', startTime: '17:00', endTime: '19:00', home: 'Gaethje-Pimblett', away: 'UFC 324 Early Prelims', channel: 'Paramount+', url: 'https://www.ufc.com/event/ufc-324' },
  { date: '2026-01-24', time: '7:00 PM', startTime: '19:00', endTime: '21:00', home: 'Gaethje-Pimblett', away: 'UFC 324 Prelims', channel: 'Paramount+', url: 'https://www.ufc.com/event/ufc-324' },
  { date: '2026-01-24', time: '9:00 PM', startTime: '21:00', endTime: '23:59', home: 'Gaethje-Pimblett', away: 'UFC 324 Main Card', channel: 'Paramount+', url: 'https://www.ufc.com/event/ufc-324' },

  { date: '2026-01-31', time: '5:00 PM', startTime: '17:00', endTime: '19:00', home: 'Volkanovski-Lopes 2', away: 'UFC 325 Early Prelims', channel: 'Paramount+', url: 'https://www.ufc.com/event/ufc-325' },
  { date: '2026-01-31', time: '7:00 PM', startTime: '19:00', endTime: '21:00', home: 'Volkanovski-Lopes 2', away: 'UFC 325 Prelims', channel: 'Paramount+', url: 'https://www.ufc.com/event/ufc-325' },
  { date: '2026-01-31', time: '9:00 PM', startTime: '21:00', endTime: '23:59', home: 'Volkanovski-Lopes 2', away: 'UFC 325 Main Card', channel: 'Paramount+', url: 'https://www.ufc.com/event/ufc-325' },

  { date: '2026-02-07', time: '6:00 PM', startTime: '18:00', endTime: '20:00', home: 'Bautista-Oliveira', away: 'UFC Fight Night Prelims', channel: 'Paramount+', url: 'https://www.ufc.com/event/ufc-fight-night-february-07-2026' },
  { date: '2026-02-07', time: '9:00 PM', startTime: '21:00', endTime: '23:59', home: 'Bautista-Oliveira', away: 'UFC Fight Night Main Card', channel: 'Paramount+', url: 'https://www.ufc.com/event/ufc-fight-night-february-07-2026' },

  { date: '2026-02-21', time: '5:00 PM', startTime: '17:00', endTime: '19:00', home: 'Strickland-Hernandez', away: 'UFC Fight Night Prelims', channel: 'Paramount+', url: 'https://www.ufc.com/event/ufc-fight-night-february-21-2026' },
  { date: '2026-02-21', time: '8:00 PM', startTime: '20:00', endTime: '23:30', home: 'Strickland-Hernandez', away: 'UFC Fight Night Main Card', channel: 'Paramount+', url: 'https://www.ufc.com/event/ufc-fight-night-february-21-2026' },

  { date: '2026-02-28', time: '6:00 PM', startTime: '18:00', endTime: '20:00', home: 'Moreno-Almabayev', away: 'UFC Fight Night Prelims', channel: 'Paramount+', url: 'https://www.ufc.com/event/ufc-fight-night-february-28-2026' },
  { date: '2026-02-28', time: '9:00 PM', startTime: '21:00', endTime: '23:59', home: 'Moreno-Almabayev', away: 'UFC Fight Night Main Card', channel: 'Paramount+', url: 'https://www.ufc.com/event/ufc-fight-night-february-28-2026' },

  { date: '2026-03-07', time: '5:00 PM', startTime: '17:00', endTime: '19:00', home: 'Holloway-Oliveira 2', away: 'UFC 326 Early Prelims', channel: 'Paramount+', url: 'https://www.ufc.com/event/ufc-326' },
  { date: '2026-03-07', time: '7:00 PM', startTime: '19:00', endTime: '21:00', home: 'Holloway-Oliveira 2', away: 'UFC 326 Prelims', channel: 'Paramount+', url: 'https://www.ufc.com/event/ufc-326' },
  { date: '2026-03-07', time: '9:00 PM', startTime: '21:00', endTime: '23:59', home: 'Holloway-Oliveira 2', away: 'UFC 326 Main Card', channel: 'Paramount+', url: 'https://www.ufc.com/event/ufc-326' },

  { date: '2026-03-14', time: '6:00 PM', startTime: '18:00', endTime: '20:00', home: 'Emmett-Vallejos', away: 'UFC Fight Night Prelims', channel: 'Paramount+', url: 'https://www.ufc.com/event/ufc-fight-night-march-14-2026' },
  { date: '2026-03-14', time: '9:00 PM', startTime: '21:00', endTime: '23:59', home: 'Emmett-Vallejos', away: 'UFC Fight Night Main Card', channel: 'Paramount+', url: 'https://www.ufc.com/event/ufc-fight-night-march-14-2026' },

  { date: '2026-03-21', time: '1:00 PM', startTime: '13:00', endTime: '15:00', home: 'TBA-TBA', away: 'UFC Fight Night Prelims', channel: 'Paramount+' },
  { date: '2026-03-21', time: '4:00 PM', startTime: '16:00', endTime: '19:30', home: 'TBA-TBA', away: 'UFC Fight Night Main Card', channel: 'Paramount+' },

  { date: '2026-03-28', time: '6:00 PM', startTime: '18:00', endTime: '20:00', home: 'Adesanya-Pyfer', away: 'UFC Fight Night Prelims', channel: 'Paramount+', url: 'https://www.ufc.com/event/ufc-fight-night-march-28-2026' },
  { date: '2026-03-28', time: '9:00 PM', startTime: '21:00', endTime: '23:59', home: 'Adesanya-Pyfer', away: 'UFC Fight Night Main Card', channel: 'Paramount+', url: 'https://www.ufc.com/event/ufc-fight-night-march-28-2026' }
],

'Boxing': [
{ date: '2026-01-23', time: '7:00 PM', home: 'Sanchez', away: 'Rubio', channel: 'DAZN', startTime: '19:00', endTime: '23:30' },
{ date: '2026-01-23', time: '9:00 PM', home: 'Walsh', away: 'Ocampo', channel: 'Paramount+', startTime: '21:00', endTime: '23:59' },
{ date: '2026-01-24', time: '8:00 PM', home: 'Muratalla', away: 'Cruz', channel: 'DAZN', startTime: '20:00', endTime: '23:59' },
{ date: '2026-01-30', time: '6:00 PM', home: 'Flores', away: 'Castillo', channel: 'ProBox TV', startTime: '18:00', endTime: '22:30' },
{ date: '2026-01-31', time: '12:00 AM', home: 'Zayas', away: 'Baraou', channel: '', startTime: '00:00', endTime: '23:59' },
{ date: '2026-01-31', time: '1:00 PM', home: 'Murtazaliev', away: 'Kelly', channel: 'DAZN', startTime: '13:00', endTime: '17:30' },
{ date: '2026-01-31', time: '8:00 PM', home: 'Lopez', away: 'Stevenson', channel: 'DAZN', startTime: '20:00', endTime: '23:59' },
{ date: '2026-01-31', time: '12:00 AM', home: 'Azim', away: 'Lemos', channel: 'BBC Two', startTime: '00:00', endTime: '23:59' },
{ date: '2026-01-31', time: '12:00 AM', home: 'Scull', away: 'Bank', channel: 'DAZN', startTime: '00:00', endTime: '23:59' },
{ date: '2026-02-05', time: '6:30 PM', home: 'Ramirez', away: 'Richards', channel: 'Punchinggrace.com', startTime: '18:30', endTime: '23:00' },
{ date: '2026-02-06', time: '9:00 PM', home: 'Medina', away: 'Curiel', channel: 'DAZN', startTime: '21:00', endTime: '23:59' },
{ date: '2026-02-07', time: '2:00 PM', home: 'Ball', away: 'Figueroa', channel: 'DAZN', startTime: '14:00', endTime: '18:30' },
{ date: '2026-02-10', time: '8:00 PM', home: 'Pagan', away: 'Jimenez', channel: 'DAZN', startTime: '20:00', endTime: '23:59' },
{ date: '2026-02-14', time: '12:00 AM', home: 'Ajagba', away: 'Martin', channel: 'Paramount+', startTime: '00:00', endTime: '23:59' },
{ date: '2026-02-15', time: '12:00 AM', home: 'Nishida', away: 'Mercado', channel: '', startTime: '00:00', endTime: '23:59' },
{ date: '2026-02-15', time: '12:00 PM', home: 'Muxanga', away: 'Byfield', channel: 'DAZN', startTime: '12:00', endTime: '16:30' },
{ date: '2026-02-21', time: '1:00 PM', home: 'Wood', away: 'Warrington', channel: 'DAZN', startTime: '13:00', endTime: '17:30' },
{ date: '2026-02-21', time: '12:00 AM', home: 'Santillan', away: 'Cepeda', channel: '', startTime: '00:00', endTime: '23:59' },
{ date: '2026-02-21', time: '7:00 PM', home: 'Barrios', away: 'Garcia', channel: 'DAZN', startTime: '19:00', endTime: '23:30' },
{ date: '2026-02-22', time: '8:00 PM', home: 'Shields', away: 'Crews-Dezurn', channel: 'DAZN', startTime: '20:00', endTime: '23:59' },
{ date: '2026-02-28', time: '4:00 PM', home: 'Nunez', away: 'Navarrete', channel: 'DAZN', startTime: '16:00', endTime: '20:30' },
{ date: '2026-02-28', time: '5:00 PM', home: 'Pierce', away: 'Parra', channel: 'Amazon Prime', startTime: '17:00', endTime: '21:30' },
{ date: '2026-02-28', time: '2:00 PM', home: 'Ursu', away: 'Cooper', channel: 'DAZN', startTime: '14:00', endTime: '18:30' },
{ date: '2026-03-05', time: '12:00 AM', home: 'Butler', away: 'Hiseni', channel: 'Punchinggrace.com', startTime: '00:00', endTime: '23:59' },
{ date: '2026-03-14', time: '3:00 PM', home: 'Dickens', away: 'Cacace', channel: 'DAZN', startTime: '15:00', endTime: '19:30' },
{ date: '2026-03-28', time: '1:45 PM', home: 'Itauma', away: 'Franklin', channel: 'DAZN', startTime: '13:45', endTime: '18:15' },
{ date: '2026-04-18', time: '12:00 AM', home: 'Adams', away: 'Agyarko', channel: '', startTime: '00:00', endTime: '23:59' }


],

'NASCARCupSeries': [
  { date: '2026-02-04', time: '6:00 PM', home: 'Bowman Gray', away: 'Clash at', channel: 'FOX', startTime: '18:00', endTime: '22:00', url: 'https://www.nascar.com/followlive/' },
    { date: '2026-02-12', time: '7:00 PM', home: 'Duel #1', away: 'Daytona', channel: 'FS1', startTime: '19:00', endTime: '23:30', url: 'https://www.nascar.com/followlive/' },
  { date: '2026-02-12', time: '8:45 PM', home: 'Duel #2', away: 'Daytona', channel: 'FS1', startTime: '20:45', endTime: '23:59', url: 'https://www.nascar.com/followlive/' },
  { date: '2026-02-15', time: '2:30 PM', home: 'Daytona 500', away: '', channel: 'FOX', startTime: '14:30', endTime: '19:00', url: 'https://www.nascar.com/followlive/' },
  { date: '2026-02-22', time: '3:00 PM', home: 'Atlanta', away: '', channel: 'FOX', startTime: '15:00', endTime: '19:30', url: 'https://www.nascar.com/followlive/' },
  { date: '2026-03-01', time: '3:30 PM', home: 'Circuit of the Americas', away: 'COTA', channel: 'FOX', startTime: '15:30', endTime: '20:00', url: 'https://www.nascar.com/followlive/' },
  { date: '2026-03-08', time: '3:30 PM', home: 'Phoenix', away: '', channel: 'FS1', startTime: '15:30', endTime: '20:00', url: 'https://www.nascar.com/followlive/' },
  { date: '2026-03-15', time: '4:00 PM', home: 'Las Vegas', away: '', channel: 'FS1', startTime: '16:00', endTime: '20:30', url: 'https://www.nascar.com/followlive/' },
  { date: '2026-03-22', time: '3:00 PM', home: 'Darlington', away: '', channel: 'FS1', startTime: '15:00', endTime: '19:30', url: 'https://www.nascar.com/followlive/' },
  { date: '2026-03-29', time: '3:30 PM', home: 'Martinsville', away: '', channel: 'FS1', startTime: '15:30', endTime: '20:00', url: 'https://www.nascar.com/followlive/' },
  { date: '2026-04-12', time: '3:00 PM', home: 'Bristol', away: '', channel: 'FS1', startTime: '15:00', endTime: '19:30', url: 'https://www.nascar.com/followlive/' },
  { date: '2026-04-19', time: '2:00 PM', home: 'Kansas', away: '', channel: 'FOX', startTime: '14:00', endTime: '18:30', url: 'https://www.nascar.com/followlive/' },
  { date: '2026-04-26', time: '3:00 PM', home: 'Talladega', away: '', channel: 'FOX', startTime: '15:00', endTime: '19:30', url: 'https://www.nascar.com/followlive/' },
  { date: '2026-05-03', time: '3:30 PM', home: 'Texas', away: '', channel: 'FS1', startTime: '15:30', endTime: '20:00', url: 'https://www.nascar.com/followlive/' },
  { date: '2026-05-10', time: '3:00 PM', home: 'Watkins Glen', away: '', channel: 'FS1', startTime: '15:00', endTime: '19:30', url: 'https://www.nascar.com/followlive/' },
  { date: '2026-05-17', time: '3:00 PM', home: 'All Star Race', away: 'Dover', channel: 'FS1', startTime: '15:00', endTime: '19:30', url: 'https://www.nascar.com/followlive/' },
  { date: '2026-05-24', time: '6:00 PM', home: 'Charlotte', away: '', channel: 'Prime Video', startTime: '18:00', endTime: '22:30', url: 'https://www.nascar.com/followlive/' },
  { date: '2026-05-31', time: '7:00 PM', home: 'Nashville', away: '', channel: 'Prime Video', startTime: '19:00', endTime: '23:30', url: 'https://www.nascar.com/followlive/' },
  { date: '2026-06-07', time: '3:00 PM', home: 'Michigan', away: '', channel: 'Prime Video', startTime: '15:00', endTime: '19:30', url: 'https://www.nascar.com/followlive/' },
  { date: '2026-06-14', time: '3:00 PM', home: 'Pocono', away: '', channel: 'Prime Video', startTime: '15:00', endTime: '19:30', url: 'https://www.nascar.com/followlive/' },
  { date: '2026-06-28', time: '3:30 PM', home: 'Sonoma', away: 'Sonoma Raceway', channel: 'TNT', startTime: '15:30', endTime: '20:00', url: 'https://www.nascar.com/followlive/' },
  { date: '2026-07-05', time: '6:00 PM', home: 'Chicago', away: '', channel: 'TNT', startTime: '18:00', endTime: '22:30', url: 'https://www.nascar.com/followlive/' },
  { date: '2026-07-12', time: '7:00 PM', home: 'Atlanta', away: '', channel: 'TNT', startTime: '19:00', endTime: '23:30', url: 'https://www.nascar.com/followlive/' },
  { date: '2026-07-19', time: '7:00 PM', home: 'North Wilkesboro', away: '', channel: 'TNT', startTime: '19:00', endTime: '23:30', url: 'https://www.nascar.com/followlive/' },
  { date: '2026-07-26', time: '2:00 PM', home: 'Indianapolis', away: '', channel: 'TNT', startTime: '14:00', endTime: '18:30', url: 'https://www.nascar.com/followlive/' },
  { date: '2026-08-09', time: '3:30 PM', home: 'Iowa', away: '', channel: 'USA Net', startTime: '15:30', endTime: '20:00', url: 'https://www.nascar.com/followlive/' },
  { date: '2026-08-15', time: '7:00 PM', home: 'Richmond', away: '', channel: 'USA Net', startTime: '19:00', endTime: '23:30', url: 'https://www.nascar.com/followlive/' },
  { date: '2026-08-23', time: '3:00 PM', home: 'New Hampshire', away: '', channel: 'USA Net', startTime: '15:00', endTime: '19:30', url: 'https://www.nascar.com/followlive/' },
  { date: '2026-08-29', time: '7:30 PM', home: 'Daytona', away: '', channel: 'NBC', startTime: '19:30', endTime: '23:59', url: 'https://www.nascar.com/followlive/' },
  { date: '2026-09-06', time: '5:00 PM', home: 'Darlington', away: 'Playoffs', channel: 'USA Net', startTime: '17:00', endTime: '21:30', url: 'https://www.nascar.com/followlive/' },
  { date: '2026-09-13', time: '3:00 PM', home: 'WWT', away: 'Playoffs', channel: 'USA Net', startTime: '15:00', endTime: '19:30', url: 'https://www.nascar.com/followlive/' },
  { date: '2026-09-19', time: '7:30 PM', home: 'Bristol', away: 'Playoffs', channel: 'USA Net', startTime: '19:30', endTime: '23:59', url: 'https://www.nascar.com/followlive/' },
  { date: '2026-09-27', time: '3:00 PM', home: 'Kansas', away: 'Playoffs', channel: 'USA Net', startTime: '15:00', endTime: '19:30', url: 'https://www.nascar.com/followlive/' },
  { date: '2026-10-04', time: '5:30 PM', home: 'Las Vegas', away: 'Playoffs', channel: 'USA Net', startTime: '17:30', endTime: '22:00', url: 'https://www.nascar.com/followlive/' },
  { date: '2026-10-11', time: '3:00 PM', home: 'Charlotte Road Course', away: 'Playoffs', channel: 'USA Net', startTime: '15:00', endTime: '19:30', url: 'https://www.nascar.com/followlive/' },
  { date: '2026-10-18', time: '3:00 PM', home: 'Phoenix', away: 'Playoffs', channel: 'USA Net', startTime: '15:00', endTime: '19:30', url: 'https://www.nascar.com/followlive/' },
  { date: '2026-10-25', time: '2:00 PM', home: 'Talladega', away: 'Playoffs', channel: 'NBC', startTime: '14:00', endTime: '18:30', url: 'https://www.nascar.com/followlive/' },
  { date: '2026-11-01', time: '2:00 PM', home: 'Martinsville', away: 'Playoffs', channel: 'NBC', startTime: '14:00', endTime: '18:30', url: 'https://www.nascar.com/followlive/' },
  { date: '2026-11-08', time: '3:00 PM', home: 'Miami', away: 'Championship', channel: 'NBC', startTime: '15:00', endTime: '19:30', url: 'https://www.nascar.com/followlive/' },
],

'USWNT': [
  { date: '2026-01-27', time: '10:00 pm', startTime: '22:00', endTime: '23:59', away: 'Chile', home: 'United States', channel: 'TBS', url: 'https://www.fotmob.com/matches/usa-vs-chile/4yz4r48f#5135650' },
  
  { date: '2026-03-01', time: '5:00 pm', startTime: '17:00', endTime: '19:00', away: 'Argentina', home: 'United States', channel: 'TNT', url: 'https://www.fotmob.com/matches/usa-vs-argentina/1hyjta0#5135654' },
  
  { date: '2026-03-04', time: '6:30 pm', startTime: '18:30', endTime: '20:30', away: 'Canada', home: 'United States', channel: 'TNT', url: 'https://www.fotmob.com/matches/usa-vs-canada/1hyp09u#5135656' },
  
  { date: '2026-03-07', time: '3:30 pm', startTime: '15:30', endTime: '17:30', away: 'Colombia', home: 'United States', channel: 'TBS', url: 'https://www.fotmob.com/matches/usa-vs-colombia/duxxf56#5135658' },
  
  { date: '2026-04-11', time: '5:30 pm', startTime: '17:30', endTime: '19:30', away: 'Japan', home: 'United States', channel: 'TNT', url: 'https://www.fotmob.com/teams/5909/fixtures/usa' },
  
  { date: '2026-04-14', time: '10:00 pm', startTime: '22:00', endTime: '23:59', away: 'Japan', home: 'United States', channel: 'TNT', url: 'https://www.fotmob.com/teams/5909/fixtures/usa' },
  
  { date: '2026-04-17', time: '9:00 pm', startTime: '21:00', endTime: '23:00', away: 'Japan', home: 'United States', channel: 'TNT', url: 'https://www.fotmob.com/teams/5909/fixtures/usa' },
  ],

'IMSASportsCar': [
  { date: '2026-01-25', time: '1:00 am', startTime: '1:00', endTime: '14:00', away: '24 Hours of', home: 'Daytona', channel: 'Peacock, NBC', url: 'https://www.imsa.com/scoring/' }, // Add IMSA SportsCar Championship races here
  // Example format:
  // { date: '2026-01-24', time: '1:00 PM', startTime: '13:00', endTime: '18:00', home: 'Rolex 24 at Daytona', away: 'Daytona', channel: 'NBC', url: 'https://www.imsa.com/events/...' },
],

'LIVGolf':
[
{ date: '2026-02-04', time: '10:00 am', home: '1st Round', away: 'Riyadh', channel: 'GOLF', startTime: '10:00', endTime: '15:00', url: 'https://www.livgolf.com/schedule/riyadh-2026/live' },
{ date: '2026-02-05', time: '10:00 am', home: '2nd Round', away: 'Riyadh', channel: 'GOLF', startTime: '10:00', endTime: '15:00', url: 'https://www.livgolf.com/schedule/riyadh-2026/live' },
{ date: '2026-02-06', time: '10:00 am', home: '3rd Round', away: 'Riyadh', channel: 'GOLF', startTime: '10:00', endTime: '15:00', url: 'https://www.livgolf.com/schedule/riyadh-2026/live' },
{ date: '2026-02-07', time: '', home: 'Final Round', away: 'Riyadh', channel: 'GOLF', startTime: '', endTime: '', url: 'https://www.livgolf.com/schedule/riyadh-2026/live' },
],

'DPWorldTour': 
[
  { date: '2026-01-29', time: '', home: '1st Round', away: 'Bahrain', channel: 'GOLF', startTime: '', endTime: '', url: 'https://www.europeantour.com/dpworld-tour/bapco-energies-bahrain-championship-2026/' },
  { date: '2026-01-30', time: '3:30 am', home: '2nd Round', away: 'Bahrain', channel: 'GOLF', startTime: '3:30', endTime: '8:30', url: 'https://www.europeantour.com/dpworld-tour/bapco-energies-bahrain-championship-2026/' },
  { date: '2026-01-31', time: '4:00 am', home: '3rd Round', away: 'Bahrain', channel: 'GOLF', startTime: '4:00', endTime: '8:30', url: 'https://www.europeantour.com/dpworld-tour/bapco-energies-bahrain-championship-2026/' },
  { date: '2026-02-01', time: '3:30 am', home: 'Final Round', away: 'Bahrain', channel: 'GOLF', startTime: '3:30', endTime: '8:30', url: 'https://www.europeantour.com/dpworld-tour/bapco-energies-bahrain-championship-2026/' },
  
  { date: '2026-02-05', time: '4:00 am', home: '1st Round', away: 'Qatar', channel: 'GOLF', startTime: '04:00', endTime: '09:00', url: 'https://www.europeantour.com/dpworld-tour/qatar-masters-2026/' },

{ date: '2026-02-06', time: '4:00 am', home: '2nd Round', away: 'Qatar', channel: 'GOLF', startTime: '04:00', endTime: '09:00', url: 'https://www.europeantour.com/dpworld-tour/qatar-masters-2026/' },

{ date: '2026-02-07', time: '4:30 am', home: '3rd Round', away: 'Qatar', channel: 'GOLF', startTime: '04:30', endTime: '09:00', url: 'https://www.europeantour.com/dpworld-tour/qatar-masters-2026/' },

{ date: '2026-02-08', time: '3:30 am', home: 'Final Round', away: 'Qatar', channel: 'GOLF', startTime: '03:30', endTime: '08:30', url: 'https://www.europeantour.com/dpworld-tour/qatar-masters-2026/' },

  { date: '2026-02-19', time: '', home: '1st Round', away: 'Kenya', channel: 'GOLF', startTime: '', endTime: '', url: 'https://www.europeantour.com/dpworld-tour/magical-kenya-open-2026/' },
  { date: '2026-02-20', time: '', home: '2nd Round', away: 'Kenya', channel: 'GOLF', startTime: '', endTime: '', url: 'https://www.europeantour.com/dpworld-tour/magical-kenya-open-2026/' },
  { date: '2026-02-21', time: '', home: '3rd Round', away: 'Kenya', channel: 'GOLF', startTime: '', endTime: '', url: 'https://www.europeantour.com/dpworld-tour/magical-kenya-open-2026/' },
  { date: '2026-02-22', time: '', home: 'Final Round', away: 'Kenya', channel: 'GOLF', startTime: '', endTime: '', url: 'https://www.europeantour.com/dpworld-tour/magical-kenya-open-2026/' },
  { date: '2026-02-26', time: '', home: '1st Round', away: 'S.A. Open', channel: 'GOLF', startTime: '', endTime: '', url: 'https://www.europeantour.com/dpworld-tour/investec-south-african-open-championship-2026/' },
  { date: '2026-02-27', time: '', home: '2nd Round', away: 'S.A. Open', channel: 'GOLF', startTime: '', endTime: '', url: 'https://www.europeantour.com/dpworld-tour/investec-south-african-open-championship-2026/' },
  { date: '2026-02-28', time: '', home: '3rd Round', away: 'S.A. Open', channel: 'GOLF', startTime: '', endTime: '', url: 'https://www.europeantour.com/dpworld-tour/investec-south-african-open-championship-2026/' },
  { date: '2026-03-01', time: '', home: 'Final Round', away: 'S.A. Open', channel: 'GOLF', startTime: '', endTime: '', url: 'https://www.europeantour.com/dpworld-tour/investec-south-african-open-championship-2026/' },
  { date: '2026-03-05', time: '', home: '1st Round', away: 'Joburg', channel: 'GOLF', startTime: '', endTime: '', url: 'https://www.europeantour.com/dpworld-tour/joburg-open-2026/' },
  { date: '2026-03-06', time: '', home: '2nd Round', away: 'Joburg', channel: 'GOLF', startTime: '', endTime: '', url: 'https://www.europeantour.com/dpworld-tour/joburg-open-2026/' },
  { date: '2026-03-07', time: '', home: '3rd Round', away: 'Joburg', channel: 'GOLF', startTime: '', endTime: '', url: 'https://www.europeantour.com/dpworld-tour/joburg-open-2026/' },
  { date: '2026-03-08', time: '', home: 'Final Round', away: 'Joburg', channel: 'GOLF', startTime: '', endTime: '', url: 'https://www.europeantour.com/dpworld-tour/joburg-open-2026/' },
  { date: '2026-03-19', time: '', home: '1st Round', away: 'Hainan', channel: 'GOLF', startTime: '', endTime: '', url: 'https://www.europeantour.com/dpworld-tour/hainan-classic-2026/' },
  { date: '2026-03-20', time: '', home: '2nd Round', away: 'Hainan', channel: 'GOLF', startTime: '', endTime: '', url: 'https://www.europeantour.com/dpworld-tour/hainan-classic-2026/' },
  { date: '2026-03-21', time: '', home: '3rd Round', away: 'Hainan', channel: 'GOLF', startTime: '', endTime: '', url: 'https://www.europeantour.com/dpworld-tour/hainan-classic-2026/' },
  { date: '2026-03-22', time: '', home: 'Final Round', away: 'Hainan', channel: 'GOLF', startTime: '', endTime: '', url: 'https://www.europeantour.com/dpworld-tour/hainan-classic-2026/' },
  { date: '2026-03-26', time: '', home: '1st Round', away: 'Indian Open', channel: 'GOLF', startTime: '', endTime: '', url: 'https://www.europeantour.com/dpworld-tour/hero-indian-open-2026/' },
  { date: '2026-03-27', time: '', home: '2nd Round', away: 'Indian Open', channel: 'GOLF', startTime: '', endTime: '', url: 'https://www.europeantour.com/dpworld-tour/hero-indian-open-2026/' },
  { date: '2026-03-28', time: '', home: '3rd Round', away: 'Indian Open', channel: 'GOLF', startTime: '', endTime: '', url: 'https://www.europeantour.com/dpworld-tour/hero-indian-open-2026/' },
  { date: '2026-03-29', time: '', home: 'Final Round', away: 'Indian Open', channel: 'GOLF', startTime: '', endTime: '', url: 'https://www.europeantour.com/dpworld-tour/hero-indian-open-2026/' },
  { date: '2026-04-23', time: '', home: '1st Round', away: 'China Open', channel: 'GOLF', startTime: '', endTime: '', url: 'https://www.europeantour.com/dpworld-tour/volvo-china-open-2026/' },
  { date: '2026-04-24', time: '', home: '2nd Round', away: 'China Open', channel: 'GOLF', startTime: '', endTime: '', url: 'https://www.europeantour.com/dpworld-tour/volvo-china-open-2026/' },
  { date: '2026-04-25', time: '', home: '3rd Round', away: 'China Open', channel: 'GOLF', startTime: '', endTime: '', url: 'https://www.europeantour.com/dpworld-tour/volvo-china-open-2026/' },
  { date: '2026-04-26', time: '', home: 'Final Round', away: 'China Open', channel: 'GOLF', startTime: '', endTime: '', url: 'https://www.europeantour.com/dpworld-tour/volvo-china-open-2026/' },
  { date: '2026-04-30', time: '', home: '1st Round', away: 'Turkish Air', channel: 'GOLF', startTime: '', endTime: '', url: 'https://www.europeantour.com/dpworld-tour/turkish-airlines-open-2026/' },
  { date: '2026-05-01', time: '', home: '2nd Round', away: 'Turkish Air', channel: 'GOLF', startTime: '', endTime: '', url: 'https://www.europeantour.com/dpworld-tour/turkish-airlines-open-2026/' },
  { date: '2026-05-02', time: '', home: '3rd Round', away: 'Turkish Air', channel: 'GOLF', startTime: '', endTime: '', url: 'https://www.europeantour.com/dpworld-tour/turkish-airlines-open-2026/' },
  { date: '2026-05-03', time: '', home: 'Final Round', away: 'Turkish Air', channel: 'GOLF', startTime: '', endTime: '', url: 'https://www.europeantour.com/dpworld-tour/turkish-airlines-open-2026/' },
  { date: '2026-05-07', time: '', home: '1st Round', away: 'Catalunya', channel: 'GOLF', startTime: '', endTime: '', url: 'https://www.europeantour.com/dpworld-tour/estrella-damm-catalunya-championship-2026/' },
  { date: '2026-05-08', time: '', home: '2nd Round', away: 'Catalunya', channel: 'GOLF', startTime: '', endTime: '', url: 'https://www.europeantour.com/dpworld-tour/estrella-damm-catalunya-championship-2026/' },
  { date: '2026-05-09', time: '', home: '3rd Round', away: 'Catalunya', channel: 'GOLF', startTime: '', endTime: '', url: 'https://www.europeantour.com/dpworld-tour/estrella-damm-catalunya-championship-2026/' },
  { date: '2026-05-10', time: '', home: 'Final Round', away: 'Catalunya', channel: 'GOLF', startTime: '', endTime: '', url: 'https://www.europeantour.com/dpworld-tour/estrella-damm-catalunya-championship-2026/' },
  { date: '2026-05-21', time: '', home: '1st Round', away: 'Soudal Open', channel: 'GOLF', startTime: '', endTime: '', url: 'https://www.europeantour.com/dpworld-tour/soudal-open-2026/' },
  { date: '2026-05-22', time: '', home: '2nd Round', away: 'Soudal Open', channel: 'GOLF', startTime: '', endTime: '', url: 'https://www.europeantour.com/dpworld-tour/soudal-open-2026/' },
  { date: '2026-05-23', time: '', home: '3rd Round', away: 'Soudal Open', channel: 'GOLF', startTime: '', endTime: '', url: 'https://www.europeantour.com/dpworld-tour/soudal-open-2026/' },
  { date: '2026-05-24', time: '', home: 'Final Round', away: 'Soudal Open', channel: 'GOLF', startTime: '', endTime: '', url: 'https://www.europeantour.com/dpworld-tour/soudal-open-2026/' },
  { date: '2026-05-28', time: '', home: '1st Round', away: 'Alpine', channel: 'GOLF', startTime: '', endTime: '', url: 'https://www.europeantour.com/dpworld-tour/austrian-alpine-open-presented-by-kitzbuhel-tirol-2026/' },
  { date: '2026-05-29', time: '', home: '2nd Round', away: 'Alpine', channel: 'GOLF', startTime: '', endTime: '', url: 'https://www.europeantour.com/dpworld-tour/austrian-alpine-open-presented-by-kitzbuhel-tirol-2026/' },
  { date: '2026-05-30', time: '', home: '3rd Round', away: 'Alpine', channel: 'GOLF', startTime: '', endTime: '', url: 'https://www.europeantour.com/dpworld-tour/austrian-alpine-open-presented-by-kitzbuhel-tirol-2026/' },
  { date: '2026-05-31', time: '', home: 'Final Round', away: 'Alpine', channel: 'GOLF', startTime: '', endTime: '', url: 'https://www.europeantour.com/dpworld-tour/austrian-alpine-open-presented-by-kitzbuhel-tirol-2026/' },
  { date: '2026-06-04', time: '', home: '1st Round', away: 'KLM Open', channel: 'GOLF', startTime: '', endTime: '', url: 'https://www.europeantour.com/dpworld-tour/klm-open-2026/' },
  { date: '2026-06-05', time: '', home: '2nd Round', away: 'KLM Open', channel: 'GOLF', startTime: '', endTime: '', url: 'https://www.europeantour.com/dpworld-tour/klm-open-2026/' },
  { date: '2026-06-06', time: '', home: '3rd Round', away: 'KLM Open', channel: 'GOLF', startTime: '', endTime: '', url: 'https://www.europeantour.com/dpworld-tour/klm-open-2026/' },
  { date: '2026-06-07', time: '', home: 'Final Round', away: 'KLM Open', channel: 'GOLF', startTime: '', endTime: '', url: 'https://www.europeantour.com/dpworld-tour/klm-open-2026/' },
  { date: '2026-06-25', time: '', home: '1st Round', away: 'Open d\'Italia', channel: 'GOLF', startTime: '', endTime: '', url: 'https://www.europeantour.com/dpworld-tour/open-d-italia-2026/' },
  { date: '2026-06-26', time: '', home: '2nd Round', away: 'Open d\'Italia', channel: 'GOLF', startTime: '', endTime: '', url: 'https://www.europeantour.com/dpworld-tour/open-d-italia-2026/' },
  { date: '2026-06-27', time: '', home: '3rd Round', away: 'Open d\'Italia', channel: 'GOLF', startTime: '', endTime: '', url: 'https://www.europeantour.com/dpworld-tour/open-d-italia-2026/' },
  { date: '2026-06-28', time: '', home: 'Final Round', away: 'Open d\'Italia', channel: 'GOLF', startTime: '', endTime: '', url: 'https://www.europeantour.com/dpworld-tour/open-d-italia-2026/' },
  { date: '2026-07-02', time: '', home: '1st Round', away: 'BMW', channel: 'GOLF', startTime: '', endTime: '', url: 'https://www.europeantour.com/dpworld-tour/bmw-international-open-2026/' },
  { date: '2026-07-03', time: '', home: '2nd Round', away: 'BMW', channel: 'GOLF', startTime: '', endTime: '', url: 'https://www.europeantour.com/dpworld-tour/bmw-international-open-2026/' },
  { date: '2026-07-04', time: '', home: '3rd Round', away: 'BMW', channel: 'GOLF', startTime: '', endTime: '', url: 'https://www.europeantour.com/dpworld-tour/bmw-international-open-2026/' },
  { date: '2026-07-05', time: '', home: 'Final Round', away: 'BMW', channel: 'GOLF', startTime: '', endTime: '', url: 'https://www.europeantour.com/dpworld-tour/bmw-international-open-2026/' },
  { date: '2026-07-09', time: '6:00 am', home: '1st Round', away: 'Scottish Open', channel: 'GOLF', startTime: '06:00', endTime: '', url: 'https://www.europeantour.com/dpworld-tour/genesis-scottish-open-2026/' },
  { date: '2026-07-10', time: '6:00 am', home: '2nd Round', away: 'Scottish Open', channel: 'GOLF', startTime: '06:00', endTime: '', url: 'https://www.europeantour.com/dpworld-tour/genesis-scottish-open-2026/' },
  { date: '2026-07-11', time: '10:00 am', home: '3rd Round', away: 'Scottish Open', channel: 'CBS', startTime: '10:00', endTime: '', url: 'https://www.europeantour.com/dpworld-tour/genesis-scottish-open-2026/' },
  { date: '2026-07-12', time: '10:00 am', home: 'Final Round', away: 'Scottish Open', channel: 'CBS', startTime: '10:00', endTime: '', url: 'https://www.europeantour.com/dpworld-tour/genesis-scottish-open-2026/' },
  { date: '2026-07-16', time: '4:00 am', home: '1st Round', away: 'The Open', channel: 'USA Network', startTime: '04:00', endTime: '', url: 'https://www.theopen.com/royal-birkdale-154th-open' },
  { date: '2026-07-17', time: '4:00 am', home: '2nd Round', away: 'The Open', channel: 'USA Network', startTime: '04:00', endTime: '', url: 'https://www.theopen.com/royal-birkdale-154th-open' },
  { date: '2026-07-18', time: '7:00 am', home: '3rd Round', away: 'The Open', channel: 'NBC, Peacock', startTime: '07:00', endTime: '', url: 'https://www.theopen.com/royal-birkdale-154th-open' },
  { date: '2026-07-19', time: '7:00 am', home: 'Final Round', away: 'The Open', channel: 'NBC, Peacock', startTime: '07:00', endTime: '', url: 'https://www.theopen.com/royal-birkdale-154th-open' },
  { date: '2026-08-13', time: '', home: '1st Round', away: 'Danish', channel: 'GOLF', startTime: '', endTime: '', url: 'https://www.europeantour.com/dpworld-tour/danish-golf-championship-2026/' },
  { date: '2026-08-14', time: '', home: '2nd Round', away: 'Danish', channel: 'GOLF', startTime: '', endTime: '', url: 'https://www.europeantour.com/dpworld-tour/danish-golf-championship-2026/' },
  { date: '2026-08-15', time: '', home: '3rd Round', away: 'Danish', channel: 'GOLF', startTime: '', endTime: '', url: 'https://www.europeantour.com/dpworld-tour/danish-golf-championship-2026/' },
  { date: '2026-08-16', time: '', home: 'Final Round', away: 'Danish', channel: 'GOLF', startTime: '', endTime: '', url: 'https://www.europeantour.com/dpworld-tour/danish-golf-championship-2026/' }
],
       

'LPGATour': [
{ date: '2026-01-29', time: '11:30 am', startTime: '11:30', endTime: '16:30', home: 'Champions, R1', away: 'Tournament of', channel: 'GOLF', url: 'https://www.lpga.com/leaderboard' },
  { date: '2026-01-30', time: '11:30 am', startTime: '11:30', endTime: '16:30', home: 'Champions, R2', away: 'Tournament of', channel: 'GOLF', url: 'https://www.lpga.com/leaderboard' },
  { date: '2026-01-31', time: '2:00 pm', startTime: '14:00', endTime: '20:00', home: 'Champions, R3', away: 'Tournament of', channel: 'NBC, Peacock', url: 'https://www.lpga.com/leaderboard' },
  { date: '2026-02-01', time: '1:00 pm', startTime: '13:00', endTime: '19:00', home: 'Champions, R4', away: 'Tournament of', channel: 'NBC, Peacock', url: 'https://www.lpga.com/leaderboard' },
  { date: '2026-02-19', time: '10:00 pm', startTime: '22:00', endTime: '03:00', home: 'First Round', away: 'Thailand', channel: 'GOLF', url: 'https://www.lpga.com/leaderboard' },
  { date: '2026-02-20', time: '10:00 pm', startTime: '22:00', endTime: '03:00', home: 'Second Round', away: 'Thailand', channel: 'GOLF', url: 'https://www.lpga.com/leaderboard' },
  { date: '2026-02-21', time: '10:30 pm', startTime: '22:30', endTime: '03:30', home: 'Third Round', away: 'Thailand', channel: 'GOLF', url: 'https://www.lpga.com/leaderboard' },
  { date: '2026-02-22', time: '10:30 pm', startTime: '22:30', endTime: '03:30', home: 'Final Round', away: 'Thailand', channel: 'GOLF', url: 'https://www.lpga.com/leaderboard' },
  { date: '2026-02-26', time: '8:30 pm', startTime: '20:30', endTime: '01:30', home: 'First Round', away: 'HSBC', channel: 'GOLF', url: 'https://www.lpga.com/leaderboard' },
  { date: '2026-02-27', time: '8:30 pm', startTime: '20:30', endTime: '01:30', home: 'Second Round', away: 'HSBC', channel: 'GOLF', url: 'https://www.lpga.com/leaderboard' },
  { date: '2026-02-28', time: '9:30 pm', startTime: '21:30', endTime: '02:30', home: 'Third Round', away: 'HSBC', channel: 'GOLF', url: 'https://www.lpga.com/leaderboard' },
  { date: '2026-03-01', time: '9:30 pm', startTime: '21:30', endTime: '02:30', home: 'Final Round', away: 'HSBC', channel: 'GOLF', url: 'https://www.lpga.com/leaderboard' },
  { date: '2026-03-05', time: '11:00 pm', startTime: '23:00', endTime: '04:00', home: 'First Round', away: 'Blue Bay ', channel: 'GOLF', url: 'https://www.lpga.com/leaderboard' },
  { date: '2026-03-06', time: '11:00 pm', startTime: '23:00', endTime: '04:00', home: 'Second Round', away: 'Blue Bay ', channel: 'GOLF', url: 'https://www.lpga.com/leaderboard' },
  { date: '2026-03-07', time: '11:00 pm', startTime: '23:00', endTime: '04:00', home: 'Third Round', away: 'Blue Bay ', channel: 'GOLF', url: 'https://www.lpga.com/leaderboard' },
  { date: '2026-03-08', time: '11:00 pm', startTime: '23:00', endTime: '04:00', home: 'Final Round', away: 'Blue Bay ', channel: 'GOLF', url: 'https://www.lpga.com/leaderboard' },
  { date: '2026-03-19', time: '11:00 am', startTime: '11:00', endTime: '16:00', home: 'First Round', away: 'Founders ', channel: 'GOLF', url: 'https://www.lpga.com/leaderboard' },
  { date: '2026-03-20', time: '11:00 am', startTime: '11:00', endTime: '16:00', home: 'Second Round', away: 'Founders ', channel: 'GOLF', url: 'https://www.lpga.com/leaderboard' },
  { date: '2026-03-21', time: '3:00 pm', startTime: '15:00', endTime: '20:00', home: 'Third Round', away: 'Founders ', channel: 'GOLF', url: 'https://www.lpga.com/leaderboard' },
  { date: '2026-03-22', time: '3:00 pm', startTime: '15:00', endTime: '20:00', home: 'Final Round', away: 'Founders ', channel: 'GOLF', url: 'https://www.lpga.com/leaderboard' },
  { date: '2026-03-26', time: '6:00 pm', startTime: '18:00', endTime: '23:00', home: 'First Round', away: 'Ford Champ.', channel: 'NBCSports.com', url: 'https://www.lpga.com/leaderboard' },
  { date: '2026-03-26', time: '7:00 pm', startTime: '19:00', endTime: '00:00', home: 'First Round', away: 'Ford Champ.', channel: 'GOLF', url: 'https://www.lpga.com/leaderboard' },
  { date: '2026-03-27', time: '6:00 pm', startTime: '18:00', endTime: '23:00', home: 'Second Round', away: 'Ford Champ.', channel: 'NBCSports.com', url: 'https://www.lpga.com/leaderboard' },
  { date: '2026-03-27', time: '7:00 pm', startTime: '19:00', endTime: '00:00', home: 'Second Round', away: 'Ford Champ.', channel: 'GOLF', url: 'https://www.lpga.com/leaderboard' },
  { date: '2026-03-28', time: '6:00 pm', startTime: '18:00', endTime: '23:00', home: 'Third Round', away: 'Ford Champ.', channel: 'GOLF', url: 'https://www.lpga.com/leaderboard' },
  { date: '2026-03-29', time: '6:00 pm', startTime: '18:00', endTime: '23:00', home: 'Final Round', away: 'Ford Champ.', channel: 'GOLF', url: 'https://www.lpga.com/leaderboard' },
  { date: '2026-04-01', time: '1:30 pm', startTime: '13:30', endTime: '18:30', home: 'First Round', away: 'Augusta (A)', channel: 'GOLF, Masters Live', url: 'https://www.lpga.com/leaderboard' },
  { date: '2026-04-02', time: '1:30 pm', startTime: '13:30', endTime: '18:30', home: 'Second Round', away: 'Augusta (A)', channel: 'GOLF, Masters Live', url: 'https://www.lpga.com/leaderboard' },
  { date: '2026-04-04', time: '12:00 pm', startTime: '12:00', endTime: '17:00', home: 'Final Round', away: 'Augusta (A)', channel: 'NBC, Peacock, Masters Live', url: 'https://www.lpga.com/leaderboard' },
  { date: '2026-04-16', time: '6:00 pm', startTime: '18:00', endTime: '23:00', home: 'First Round', away: 'JM Eagle LA', channel: 'GOLF', url: 'https://www.lpga.com/leaderboard' },
  { date: '2026-04-17', time: '6:00 pm', startTime: '18:00', endTime: '23:00', home: 'Second Round', away: 'JM Eagle LA', channel: 'GOLF', url: 'https://www.lpga.com/leaderboard' },
  { date: '2026-04-18', time: '6:00 pm', startTime: '18:00', endTime: '23:00', home: 'Third Round', away: 'JM Eagle LA', channel: 'GOLF', url: 'https://www.lpga.com/leaderboard' },
  { date: '2026-04-19', time: '6:00 pm', startTime: '18:00', endTime: '23:00', home: 'Final Round', away: 'JM Eagle LA', channel: 'GOLF', url: 'https://www.lpga.com/leaderboard' },
  { date: '2026-04-23', time: '9:00 am', startTime: '09:00', endTime: '14:00', home: 'Featured Groups', away: 'Chevron', channel: 'ESPN+', url: 'https://www.lpga.com/leaderboard' },
  { date: '2026-04-23', time: '11:00 am', startTime: '11:00', endTime: '16:00', home: 'First Round', away: 'Chevron', channel: 'GOLF', url: 'https://www.lpga.com/leaderboard' },
  { date: '2026-04-24', time: '11:00 am', startTime: '11:00', endTime: '16:00', home: 'Second Round', away: 'Chevron', channel: 'GOLF', url: 'https://www.lpga.com/leaderboard' },
  { date: '2026-04-25', time: '3:00 pm', startTime: '15:00', endTime: '20:00', home: 'Third Round', away: 'Chevron', channel: 'NBC, Peacock', url: 'https://www.lpga.com/leaderboard' },
  { date: '2026-04-26', time: '3:00 pm', startTime: '15:00', endTime: '20:00', home: 'Final Round', away: 'Chevron', channel: 'NBC, Peacock', url: 'https://www.lpga.com/leaderboard' }
     ],

     'PGATourChampions': [

  { date: '2026-02-13', time: '11:00 am', startTime: '11:00', endTime: '14:00', home: 'Chubb', away: '1st Round', channel: 'GOLF', url: 'https://www.pgatour.com/pgatour-champions/leaderboard' },
  { date: '2026-02-14', time: '3:00 pm', startTime: '15:00', endTime: '18:00', home: 'Chubb', away: '2nd Round', channel: 'GOLF', url: 'https://www.pgatour.com/pgatour-champions/leaderboard' },
  { date: '2026-02-15', time: '3:00 pm', startTime: '15:00', endTime: '18:00', home: 'Chubb', away: 'Final Round', channel: 'GOLF', url: 'https://www.pgatour.com/pgatour-champions/leaderboard' },
  { date: '2026-03-06', time: '11:30 am', startTime: '11:30', endTime: '14:30', home: 'Football HOF', away: '1st Round', channel: 'GOLF', url: 'https://www.pgatour.com/pgatour-champions/leaderboard' },
  { date: '2026-03-07', time: '3:30 pm', startTime: '15:30', endTime: '18:30', home: 'Football HOF', away: '2nd Round', channel: 'GOLF', url: 'https://www.pgatour.com/pgatour-champions/leaderboard' },
  { date: '2026-03-08', time: '2:30 pm', startTime: '14:30', endTime: '17:30', home: 'Football HOF', away: 'Final Round', channel: 'GOLF', url: 'https://www.pgatour.com/pgatour-champions/leaderboard' },
  { date: '2026-03-20', time: '', startTime: '', endTime: '', home: 'Cologuard', away: '1st Round', channel: 'GOLF', url: 'https://www.pgatour.com/pgatour-champions/leaderboard' },
  { date: '2026-03-21', time: '', startTime: '', endTime: '', home: 'Cologuard', away: '2nd Round', channel: 'GOLF', url: 'https://www.pgatour.com/pgatour-champions/leaderboard' },
  { date: '2026-03-22', time: '', startTime: '', endTime: '', home: 'Cologuard', away: 'Final Round', channel: 'GOLF', url: 'https://www.pgatour.com/pgatour-champions/leaderboard' },
  { date: '2026-03-27', time: '', startTime: '', endTime: '', home: 'Hoag', away: '1st Round', channel: 'GOLF', url: 'https://www.pgatour.com/pgatour-champions/leaderboard' },
  { date: '2026-03-28', time: '', startTime: '', endTime: '', home: 'Hoag', away: '2nd Round', channel: 'GOLF', url: 'https://www.pgatour.com/pgatour-champions/leaderboard' },
  { date: '2026-03-29', time: '', startTime: '', endTime: '', home: 'Hoag', away: 'Final Round', channel: 'GOLF', url: 'https://www.pgatour.com/pgatour-champions/leaderboard' },
  { date: '2026-04-16', time: '', startTime: '', endTime: '', home: 'Sr. PGA Championship', away: '1st Round', channel: 'GOLF', url: 'https://www.pgatour.com/pgatour-champions/leaderboard' },
  { date: '2026-04-17', time: '', startTime: '', endTime: '', home: 'Sr. PGA Championship', away: '2nd Round', channel: 'GOLF', url: 'https://www.pgatour.com/pgatour-champions/leaderboard' },
  { date: '2026-04-18', time: '', startTime: '', endTime: '', home: 'Sr. PGA Championship', away: '3rd Round', channel: 'NBC, GOLF', url: 'https://www.pgatour.com/pgatour-champions/leaderboard' },
  { date: '2026-04-19', time: '', startTime: '', endTime: '', home: 'Sr. PGA Championship', away: 'Final Round', channel: 'NBC, GOLF', url: 'https://www.pgatour.com/pgatour-champions/leaderboard' },
  { date: '2026-04-24', time: '', startTime: '', endTime: '', home: 'Mitsubishi', away: '1st Round', channel: 'GOLF', url: 'https://www.pgatour.com/pgatour-champions/leaderboard' },
  { date: '2026-04-25', time: '', startTime: '', endTime: '', home: 'Mitsubishi', away: '2nd Round', channel: 'GOLF', url: 'https://www.pgatour.com/pgatour-champions/leaderboard' },
  { date: '2026-04-26', time: '', startTime: '', endTime: '', home: 'Mitsubishi', away: 'Final Round', channel: 'GOLF', url: 'https://www.pgatour.com/pgatour-champions/leaderboard' },
  { date: '2026-04-30', time: '11:00 am', startTime: '11:00', endTime: '14:00', home: 'Regions', away: '1st Round', channel: 'GOLF', url: 'https://www.pgatour.com/pgatour-champions/leaderboard' },
  { date: '2026-05-01', time: '11:00 am', startTime: '11:00', endTime: '14:00', home: 'Regions', away: '2nd Round', channel: 'GOLF', url: 'https://www.pgatour.com/pgatour-champions/leaderboard' },
  { date: '2026-05-02', time: '2:00 pm', startTime: '14:00', endTime: '17:00', home: 'Regions', away: '3rd Round', channel: 'GOLF', url: 'https://www.pgatour.com/pgatour-champions/leaderboard' },
  { date: '2026-05-03', time: '2:00 pm', startTime: '14:00', endTime: '17:00', home: 'Regions', away: 'Final Round', channel: 'GOLF', url: 'https://www.pgatour.com/pgatour-champions/leaderboard' },
  { date: '2026-05-08', time: '', startTime: '', endTime: '', home: 'Insperity', away: '1st Round', channel: 'GOLF', url: 'https://www.pgatour.com/pgatour-champions/leaderboard' },
  { date: '2026-05-09', time: '', startTime: '', endTime: '', home: 'Insperity', away: '2nd Round', channel: 'GOLF', url: 'https://www.pgatour.com/pgatour-champions/leaderboard' },
  { date: '2026-05-10', time: '', startTime: '', endTime: '', home: 'Insperity', away: 'Final Round', channel: 'GOLF', url: 'https://www.pgatour.com/pgatour-champions/leaderboard' },
  { date: '2026-05-21', time: '', startTime: '', endTime: '', home: 'Hassan II', away: '1st Round', channel: 'GOLF', url: 'https://www.pgatour.com/pgatour-champions/leaderboard' },
  { date: '2026-05-22', time: '', startTime: '', endTime: '', home: 'Hassan II', away: '2nd Round', channel: 'GOLF', url: 'https://www.pgatour.com/pgatour-champions/leaderboard' },
  { date: '2026-05-23', time: '', startTime: '', endTime: '', home: 'Hassan II', away: 'Final Round', channel: 'GOLF', url: 'https://www.pgatour.com/pgatour-champions/leaderboard' },
  { date: '2026-06-05', time: '', startTime: '', endTime: '', home: 'Am. Family', away: '1st Round', channel: 'GOLF', url: 'https://www.pgatour.com/pgatour-champions/leaderboard' },
  { date: '2026-06-06', time: '', startTime: '', endTime: '', home: 'Am. Family', away: '2nd Round', channel: 'GOLF', url: 'https://www.pgatour.com/pgatour-champions/leaderboard' },
  { date: '2026-06-07', time: '', startTime: '', endTime: '', home: 'Am. Family', away: 'Final Round', channel: 'GOLF', url: 'https://www.pgatour.com/pgatour-champions/leaderboard' },
  { date: '2026-06-12', time: '', startTime: '', endTime: '', home: 'Principal', away: '1st Round', channel: 'GOLF', url: 'https://www.pgatour.com/pgatour-champions/leaderboard' },
  { date: '2026-06-13', time: '', startTime: '', endTime: '', home: 'Principal', away: '2nd Round', channel: 'GOLF', url: 'https://www.pgatour.com/pgatour-champions/leaderboard' },
  { date: '2026-06-14', time: '', startTime: '', endTime: '', home: 'Principal', away: 'Final Round', channel: 'GOLF', url: 'https://www.pgatour.com/pgatour-champions/leaderboard' },
  { date: '2026-06-26', time: '', startTime: '', endTime: '', home: 'DICK\'S Open', away: '1st Round', channel: 'GOLF', url: 'https://www.pgatour.com/pgatour-champions/leaderboard' },
  { date: '2026-06-27', time: '', startTime: '', endTime: '', home: 'DICK\'S Open', away: '2nd Round', channel: 'GOLF', url: 'https://www.pgatour.com/pgatour-champions/leaderboard' },
  { date: '2026-06-28', time: '', startTime: '', endTime: '', home: 'DICK\'S Open', away: 'Final Round', channel: 'GOLF', url: 'https://www.pgatour.com/pgatour-champions/leaderboard' },
  { date: '2026-07-02', time: '', startTime: '', endTime: '', home: 'U.S Sr. Open', away: '1st Round', channel: 'GOLF', url: 'https://www.pgatour.com/pgatour-champions/leaderboard' },
  { date: '2026-07-03', time: '', startTime: '', endTime: '', home: 'U.S Sr. Open', away: '2nd Round', channel: 'GOLF', url: 'https://www.pgatour.com/pgatour-champions/leaderboard' },
  { date: '2026-07-04', time: '', startTime: '', endTime: '', home: 'U.S Sr. Open', away: '3rd Round', channel: 'NBC, GOLF', url: 'https://www.pgatour.com/pgatour-champions/leaderboard' },
  { date: '2026-07-05', time: '', startTime: '', endTime: '', home: 'U.S Sr. Open', away: 'Final Round', channel: 'NBC, GOLF', url: 'https://www.pgatour.com/pgatour-champions/leaderboard' },
  { date: '2026-07-09', time: '', startTime: '', endTime: '', home: 'Kaulig', away: '1st Round', channel: 'GOLF', url: 'https://www.pgatour.com/pgatour-champions/leaderboard' },
  { date: '2026-07-10', time: '', startTime: '', endTime: '', home: 'Kaulig', away: '2nd Round', channel: 'GOLF', url: 'https://www.pgatour.com/pgatour-champions/leaderboard' },
  { date: '2026-07-11', time: '', startTime: '', endTime: '', home: 'Kaulig', away: '3rd Round', channel: 'GOLF', url: 'https://www.pgatour.com/pgatour-champions/leaderboard' },
  { date: '2026-07-12', time: '', startTime: '', endTime: '', home: 'Kaulig', away: 'Final Round', channel: 'GOLF', url: 'https://www.pgatour.com/pgatour-champions/leaderboard' },
  { date: '2026-07-23', time: '8:30 am', startTime: '08:30', endTime: '11:30', home: 'Sr. Open', away: '1st Round', channel: 'GOLF', url: 'https://www.pgatour.com/pgatour-champions/leaderboard' },
  { date: '2026-07-24', time: '8:30 am', startTime: '08:30', endTime: '11:30', home: 'Sr. Open', away: '2nd Round', channel: 'GOLF', url: 'https://www.pgatour.com/pgatour-champions/leaderboard' },
  { date: '2026-07-25', time: '8:30 am', startTime: '08:30', endTime: '11:30', home: 'Sr. Open', away: '3rd Round', channel: 'NBC, GOLF', url: 'https://www.pgatour.com/pgatour-champions/leaderboard' },
  { date: '2026-07-26', time: '8:30 am', startTime: '08:30', endTime: '11:30', home: 'Sr. Open', away: 'Final Round', channel: 'NBC, GOLF', url: 'https://www.pgatour.com/pgatour-champions/leaderboard' },
  { date: '2026-07-31', time: '', startTime: '', endTime: '', home: 'Portugal', away: '1st Round', channel: 'GOLF', url: 'https://www.pgatour.com/pgatour-champions/leaderboard' },
  { date: '2026-08-01', time: '', startTime: '', endTime: '', home: 'Portugal', away: '2nd Round', channel: 'GOLF', url: 'https://www.pgatour.com/pgatour-champions/leaderboard' },
  { date: '2026-08-02', time: '', startTime: '', endTime: '', home: 'Portugal', away: 'Final Round', channel: 'GOLF', url: 'https://www.pgatour.com/pgatour-champions/leaderboard' },
  { date: '2026-08-14', time: '', startTime: '', endTime: '', home: 'Boeing', away: '1st Round', channel: 'GOLF', url: 'https://www.pgatour.com/pgatour-champions/leaderboard' },
  { date: '2026-08-15', time: '', startTime: '', endTime: '', home: 'Boeing', away: '2nd Round', channel: 'GOLF', url: 'https://www.pgatour.com/pgatour-champions/leaderboard' },
  { date: '2026-08-16', time: '', startTime: '', endTime: '', home: 'Boeing', away: 'Final Round', channel: 'GOLF', url: 'https://www.pgatour.com/pgatour-champions/leaderboard' },
  { date: '2026-08-21', time: '', startTime: '', endTime: '', home: 'Rogers', away: '1st Round', channel: 'GOLF', url: 'https://www.pgatour.com/pgatour-champions/leaderboard' },
  { date: '2026-08-22', time: '', startTime: '', endTime: '', home: 'Rogers', away: '2nd Round', channel: 'GOLF', url: 'https://www.pgatour.com/pgatour-champions/leaderboard' },
  { date: '2026-08-23', time: '', startTime: '', endTime: '', home: 'Rogers', away: 'Final Round', channel: 'GOLF', url: 'https://www.pgatour.com/pgatour-champions/leaderboard' },
  { date: '2026-08-28', time: '', startTime: '', endTime: '', home: 'Ally', away: '1st Round', channel: 'GOLF', url: 'https://www.pgatour.com/pgatour-champions/leaderboard' },
  { date: '2026-08-29', time: '', startTime: '', endTime: '', home: 'Ally', away: '2nd Round', channel: 'GOLF', url: 'https://www.pgatour.com/pgatour-champions/leaderboard' },
  { date: '2026-08-30', time: '', startTime: '', endTime: '', home: 'Ally', away: 'Final Round', channel: 'GOLF', url: 'https://www.pgatour.com/pgatour-champions/leaderboard' },
  { date: '2026-09-11', time: '', startTime: '', endTime: '', home: 'Sanford', away: '1st Round', channel: 'GOLF', url: 'https://www.pgatour.com/pgatour-champions/leaderboard' },
  { date: '2026-09-12', time: '', startTime: '', endTime: '', home: 'Sanford', away: '2nd Round', channel: 'GOLF', url: 'https://www.pgatour.com/pgatour-champions/leaderboard' },
  { date: '2026-09-13', time: '', startTime: '', endTime: '', home: 'Sanford', away: 'Final Round', channel: 'GOLF', url: 'https://www.pgatour.com/pgatour-champions/leaderboard' },
  { date: '2026-09-18', time: '', startTime: '', endTime: '', home: 'PURE', away: '1st Round', channel: 'GOLF', url: 'https://www.pgatour.com/pgatour-champions/leaderboard' },
  { date: '2026-09-19', time: '', startTime: '', endTime: '', home: 'PURE', away: '2nd Round', channel: 'GOLF', url: 'https://www.pgatour.com/pgatour-champions/leaderboard' },
  { date: '2026-09-20', time: '', startTime: '', endTime: '', home: 'PURE', away: 'Final Round', channel: 'GOLF', url: 'https://www.pgatour.com/pgatour-champions/leaderboard' },
  { date: '2026-10-02', time: '', startTime: '', endTime: '', home: 'Lehigh Valley', away: '1st Round', channel: 'GOLF', url: 'https://www.pgatour.com/pgatour-champions/leaderboard' },
  { date: '2026-10-03', time: '', startTime: '', endTime: '', home: 'Lehigh Valley', away: '2nd Round', channel: 'GOLF', url: 'https://www.pgatour.com/pgatour-champions/leaderboard' },
  { date: '2026-10-04', time: '', startTime: '', endTime: '', home: 'Lehigh Valley', away: 'Final Round', channel: 'GOLF', url: 'https://www.pgatour.com/pgatour-champions/leaderboard' },
  { date: '2026-10-09', time: '', startTime: '', endTime: '', home: ' FURYK & FRIENDS', away: '1st Round', channel: 'GOLF', url: 'https://www.pgatour.com/pgatour-champions/leaderboard' },
  { date: '2026-10-10', time: '', startTime: '', endTime: '', home: ' FURYK & FRIENDS', away: '2nd Round', channel: 'GOLF', url: 'https://www.pgatour.com/pgatour-champions/leaderboard' },
  { date: '2026-10-11', time: '', startTime: '', endTime: '', home: ' FURYK & FRIENDS', away: 'Final Round', channel: 'GOLF', url: 'https://www.pgatour.com/pgatour-champions/leaderboard' },
  { date: '2026-10-16', time: '', startTime: '', endTime: '', home: 'SAS', away: '1st Round', channel: 'GOLF', url: 'https://www.pgatour.com/pgatour-champions/leaderboard' },
  { date: '2026-10-17', time: '', startTime: '', endTime: '', home: 'SAS', away: '2nd Round', channel: 'GOLF', url: 'https://www.pgatour.com/pgatour-champions/leaderboard' },
  { date: '2026-10-18', time: '', startTime: '', endTime: '', home: 'SAS', away: 'Final Round', channel: 'GOLF', url: 'https://www.pgatour.com/pgatour-champions/leaderboard' },
  { date: '2026-10-23', time: '', startTime: '', endTime: '', home: 'Stifel', away: '1st Round', channel: 'GOLF', url: 'https://www.pgatour.com/pgatour-champions/leaderboard' },
  { date: '2026-10-24', time: '', startTime: '', endTime: '', home: 'Stifel', away: '2nd Round', channel: 'GOLF', url: 'https://www.pgatour.com/pgatour-champions/leaderboard' },
  { date: '2026-10-25', time: '', startTime: '', endTime: '', home: 'Stifel', away: 'Final Round', channel: 'GOLF', url: 'https://www.pgatour.com/pgatour-champions/leaderboard' },
  { date: '2026-10-30', time: '', startTime: '', endTime: '', home: 'Simmons', away: '1st Round', channel: 'GOLF', url: 'https://www.pgatour.com/pgatour-champions/leaderboard' },
  { date: '2026-10-31', time: '', startTime: '', endTime: '', home: 'Simmons', away: '2nd Round', channel: 'GOLF', url: 'https://www.pgatour.com/pgatour-champions/leaderboard' },
  { date: '2026-11-01', time: '', startTime: '', endTime: '', home: 'Simmons', away: 'Final Round', channel: 'GOLF', url: 'https://www.pgatour.com/pgatour-champions/leaderboard' },
  { date: '2026-11-12', time: '', startTime: '', endTime: '', home: 'Charles Schwab ', away: '', channel: 'GOLF', url: 'https://www.pgatour.com/pgatour-champions/leaderboard' },
  { date: '2026-11-13', time: '', startTime: '', endTime: '', home: 'Charles Schwab ', away: '', channel: 'GOLF', url: 'https://www.pgatour.com/pgatour-champions/leaderboard' },
  { date: '2026-11-14', time: '', startTime: '', endTime: '', home: 'Charles Schwab ', away: '', channel: 'GOLF', url: 'https://www.pgatour.com/pgatour-champions/leaderboard' },
  { date: '2026-11-15', time: '', startTime: '', endTime: '', home: 'Charles Schwab ', away: '', channel: 'GOLF', url: 'https://www.pgatour.com/pgatour-champions/leaderboard' },
  { date: '2026-12-19', time: '2:30 pm', startTime: '14:30', endTime: '17:30', home: 'PNC', away: '1st Round', channel: 'NBC, Peacock', url: 'https://www.pgatour.com/pgatour-champions/leaderboard' },
  { date: '2026-12-20', time: '1:30 pm', startTime: '13:30', endTime: '16:30', home: 'PNC', away: 'Final Round', channel: 'NBC, Peacock', url: 'https://www.pgatour.com/pgatour-champions/leaderboard' }
],
         

      // Add more leagues here as needed: Boxing, UFC, PGATour, LPGATour, PGATourChampions, NASCARCupSeries, DPWorldTour, LIVGolf, IMSASportsCar
  };
    
    const leagueDisplayNameMap = {
      'Boxing': 'Boxing',
      'UFC': 'UFC',
      'PGATour': 'PGA Tour',
      'LPGATour': 'LPGA Tour',
      'Tennis': 'Tennis',
      'PGATourChampions': 'PGA Champions',
      'NASCARCupSeries': 'NASCAR Cup Series',
      'DPWorldTour': 'DP World Tour',
      'LIVGolf': 'LIV Golf',
      'IMSASportsCar': 'IMSA SportsCar',
      'CFB': 'CFB'
    };
    
    const games = [];
    snapshot.forEach(doc => {
      const data = doc.data();
      const gameId = data['Game ID'] || data.gameId || '';
      
      // Check if this is a featured hardcoded game (Game ID starts with "hardcoded-")
      if (gameId.startsWith('hardcoded-')) {
        // Parse Game ID: hardcoded-{leagueKey}-{date}-{index}
        // Example: hardcoded-Tennis-2026-01-28-0
        // Need to handle date with dashes, so split and reconstruct
        const parts = gameId.split('-');
        if (parts.length >= 6) {
          const leagueKey = parts[1]; // e.g., "Tennis"
          // Date is parts[2], parts[3], parts[4] (e.g., "2026", "01", "28")
          const gameDate = `${parts[2]}-${parts[3]}-${parts[4]}`; // e.g., "2026-01-28"
          const gameIndex = parseInt(parts[5]) || 0;
          
          // Find the original hardcoded game data
          if (Hardcoded_Today_Schedules[leagueKey]) {
            const leagueGames = Hardcoded_Today_Schedules[leagueKey].filter(g => g.date === gameDate);
            if (leagueGames[gameIndex]) {
              const originalGame = leagueGames[gameIndex];
              const leagueDisplayName = leagueDisplayNameMap[leagueKey] || leagueKey;
              
              // Convert startTime to Firestore Timestamp
              let startTimeTimestamp = null;
              if (originalGame.startTime && gameDate) {
                // Prefer the time string (e.g., "7:00 pm") if available, otherwise convert from 24-hour startTime
                let timeStr = originalGame.time;
                if (!timeStr && originalGame.startTime) {
                  // Convert 24-hour format (e.g., "19:00") to 12-hour format (e.g., "7:00 PM")
                  const [hours, minutes] = originalGame.startTime.split(':').map(Number);
                  if (!isNaN(hours) && !isNaN(minutes)) {
                    const ampm = hours >= 12 ? 'PM' : 'AM';
                    const displayHours = hours === 0 ? 12 : (hours > 12 ? hours - 12 : hours);
                    timeStr = `${displayHours}:${minutes.toString().padStart(2, '0')} ${ampm}`;
                  }
                }
                if (timeStr) {
                  startTimeTimestamp = createFirestoreTimestamp(gameDate, timeStr);
                }
              }
              
              // Enrich with original hardcoded game data
              const enrichedGame = {
                id: doc.id,
                ...serializeFirestoreData(data),
                'Away Team': originalGame.away,
                'Home Team': originalGame.home,
                'League': leagueDisplayName,
                'Sport': leagueKey === 'Tennis' ? 'Tennis' : (leagueKey === 'CFB' ? 'American Football' : (leagueKey.includes('Golf') ? 'Golf' : (leagueKey.includes('PGA') ? 'Golf' : (leagueKey === 'Boxing' || leagueKey === 'UFC' ? 'Combat' : 'Racing')))),
                'Match Status': 'SCHEDULED',
                'gameDate': gameDate,
                'channel': originalGame.channel || '',
                'Channel': originalGame.channel || '',
                'hardcodedTodayUrl': originalGame.url || '',
                'isHardcodedToday': true
              };
              
              // Add Start Time if we successfully created a timestamp
              if (startTimeTimestamp) {
                enrichedGame['Start Time'] = startTimeTimestamp;
              }
              
              games.push(enrichedGame);
              return; // Skip default push
            }
          }
          // If hardcoded game not found in schedules, fall back to Featured document data
          // This allows featured games to display even if removed from schedules (e.g., yesterday's games)
          games.push({
            id: doc.id,
            ...serializeFirestoreData(data)
          });
          return; // Skip default push
        }
      }
      
      // Regular featured game (not hardcoded)
      games.push({
        id: doc.id,
        ...serializeFirestoreData(data)
      });
    });
    
    games.sort((a, b) => {
      if (a.order !== undefined && b.order !== undefined) {
        return a.order - b.order;
      }
      return 0;
    });
    
    const result = {
      lastUpdated: new Date().toISOString(),
      date: targetDate,
      gameCount: games.length,
      games: games
    };
    
    // Set cache expiry based on whether it's today or yesterday
    let expiryTimestamp;
    if (isToday) {
      // Today's games: 2-minute cache (live, updating)
      expiryTimestamp = now + FEATURED_GAMES_CACHE_TTL_TODAY;
    } else {
      // Yesterday's games: cache until next morningRefresh (3:55 AM ET) - final scores, won't change
      expiryTimestamp = getNextPrepExpiryTimestamp();
    }
    
    // Update cache
    featuredGamesCache.set(cacheKey, result);
    featuredGamesCacheExpiry.set(cacheKey, expiryTimestamp);
    
    console.log(`[featured.json] Generated JSON with ${games.length} featured games for ${targetDate} (expires at ${new Date(expiryTimestamp).toISOString()})`);
    return result;
  } catch (error) {
    console.error(`[featured.json] Error generating JSON for ${targetDate}:`, error);
    // Return cached data if available, even if expired
    if (cached) {
      console.log(`[featured.json] Returning cached data due to error`);
      return cached;
    }
    throw error;
  }
}

// Serve featured games JSON
app.get('/data/featured.json', async (req, res) => {
  try {
    // Support optional ?date=YYYY-MM-DD query parameter for yesterday's featured games
    const dateParam = req.query.date;
    const todayStr = DateTime.now().setZone('America/New_York').toISODate();
    const isToday = !dateParam || dateParam === todayStr;
    const json = await generateFeaturedGamesJSON(dateParam);
    
    res.set('Access-Control-Allow-Origin', '*');
    res.set('Content-Type', 'application/json');
    
    // Set cache headers based on whether it's today or yesterday
    if (isToday) {
      // Today's featured games: 2-minute cache (live, updating)
      res.set('Cache-Control', 'public, max-age=120, s-maxage=120');
    } else {
      // Yesterday's featured games: cache until next morningRefresh (20 hours) - final scores, won't change
      res.set('Cache-Control', 'public, max-age=72000, s-maxage=72000');
    }
    
    res.json(json);
  } catch (error) {
    res.status(500).json({ error: error.message });
  }
});

// Serve F1 Driver Standings JSON
app.get('/data/f1-driver-standings.json', async (req, res) => {
  try {
    const db = initializeFirebase();
    const snapshot = await db.collection('F1DriverStandings').get();
    
    const standings = [];
    snapshot.forEach(doc => {
      standings.push({
        id: doc.id,
        ...serializeFirestoreData(doc.data())
      });
    });
    
    const data = {
      lastUpdated: new Date().toISOString(),
      standings: standings
    };
    
    res.set('Access-Control-Allow-Origin', '*');
    res.set('Content-Type', 'application/json');
    res.json(data);
  } catch (error) {
    res.status(500).json({ error: error.message });
  }
});

// Serve F1 Constructor Standings JSON
app.get('/data/f1-constructor-standings.json', async (req, res) => {
  try {
    const db = initializeFirebase();
    const snapshot = await db.collection('F1ConstructorStandings').get();
    
    const standings = [];
    snapshot.forEach(doc => {
      standings.push({
        id: doc.id,
        ...serializeFirestoreData(doc.data())
      });
    });
    
    const data = {
      lastUpdated: new Date().toISOString(),
      standings: standings
    };
    
    res.set('Access-Control-Allow-Origin', '*');
    res.set('Content-Type', 'application/json');
    res.json(data);
  } catch (error) {
    res.status(500).json({ error: error.message });
  }
});

// Serve F1 Schedule JSON
app.get('/data/f1-schedule.json', async (req, res) => {
  try {
    const db = initializeFirebase();
    const snapshot = await db.collection('FormulaOne').get();
    
    const events = [];
    snapshot.forEach(doc => {
      events.push({
        id: doc.id,
        ...serializeFirestoreData(doc.data())
      });
    });
    
    const data = {
      lastUpdated: new Date().toISOString(),
      events: events
    };
    
    res.set('Access-Control-Allow-Origin', '*');
    res.set('Content-Type', 'application/json');
    res.json(data);
  } catch (error) {
    res.status(500).json({ error: error.message });
  }
});

// Serve Standings JSON (all leagues)
app.get('/data/standings.json', async (req, res) => {
  try {
    const db = initializeFirebase();
    
    // Map of all standings collections (matching frontend collectionMap)
    const collectionsMap = {
      'EPLStandings': 'EPLStandings',
      'LaLigaStandings': 'LaLigaStandings',
      'SerieAStandings': 'SerieAStandings',
      'BundesligaStandings': 'BundesligaStandings',
      'Ligue1Standings': 'Ligue1Standings',
      'MLSStandings': 'MLSStandings',
      'LigaMXStandings': 'LigaMXStandings',
      'NWSLStandings': 'NWSLStandings',
      'UEFAEuropaLeagueStandings': 'UEFAEuropaLeagueStandings',
      'UEFAConferenceLeagueStandings': 'UEFAConferenceLeagueStandings',
      'NFLStandings': 'NFLStandings',
      'MLBStandings': 'MLBStandings',
      'NBAStandings': 'NBAStandings',
      'NHLStandings': 'NHLStandings',
      'NCAAFStandings': 'NCAAFStandings',
      'NCAAMStandings': 'NCAAMStandings',
      'NCAAWStandings': 'NCAAWStandings',
      'AFCChampionsLeagueStandings': 'AFCChampionsLeagueStandings',
      'F1DriverStandings': 'F1DriverStandings',
      'FACupStandings': 'FACupStandings',
      'PGATourStandings': 'PGATourStandings',
      'LPGATourStandings': 'LPGATourStandings',
      'UFCStandings': 'UFCStandings',
      'BoxingStandings': 'BoxingStandings',
      'NASCARCupSeriesStandings': 'NASCARCupSeriesStandings',
      'TennisStandings': 'TennisStandings',
      'LIVGolfStandings': 'LIVGolfStandings',
      'IndyCarStandings': 'IndyCarStandings',
      'MotoGPStandings': 'MotoGPStandings',
      'TrackAndFieldStandings': 'TrackAndFieldStandings',
      'SoccerStandings': 'SoccerStandings',
      'NCAABaseballStandings': 'NCAABaseballStandings',
      'NCAASoftballStandings': 'NCAASoftballStandings',
      'WorldCupU17Standings': 'WorldCupU17Standings',
      'WorldCupU17PlayOffsStandings': 'WorldCupU17PlayOffsStandings',
      'standings': 'standings' // Generic standings collection (for UCL, WNBA)
    };
    
    const allStandings = {};
    
    // Fetch from all collections in parallel
    const promises = Object.entries(collectionsMap).map(async ([key, collectionName]) => {
      try {
        const snapshot = await db.collection(collectionName).get();
        const teams = [];
        snapshot.forEach(doc => {
          teams.push(serializeFirestoreData(doc.data()));
        });
        if (teams.length > 0) {
          allStandings[key] = teams;
        }
      } catch (error) {
        console.error(`Error fetching ${collectionName}:`, error);
        // Continue with other collections even if one fails
      }
    });
    
    await Promise.all(promises);
    
    // Also fetch from generic 'standings' collection with league field
    try {
      const genericSnapshot = await db.collection('standings').get();
      const genericStandings = {};
      genericSnapshot.forEach(doc => {
        const data = serializeFirestoreData(doc.data());
        const league = data.league || 'unknown';
        if (!genericStandings[league]) {
          genericStandings[league] = [];
        }
        genericStandings[league].push(data);
      });
      // Merge into allStandings
      Object.assign(allStandings, genericStandings);
    } catch (error) {
      console.error('Error fetching generic standings:', error);
    }
    
    const data = {
      lastUpdated: new Date().toISOString(),
      standings: allStandings
    };
    
    res.set('Access-Control-Allow-Origin', '*');
    res.set('Content-Type', 'application/json');
    res.json(data);
  } catch (error) {
    res.status(500).json({ error: error.message });
  }
});

// Serve MLB Stats JSON
app.get('/data/mlb-stats.json', async (req, res) => {
  try {
    const db = initializeFirebase();
    const snapshot = await db.collection('mlb_stats').get();
    
    const stats = {};
    snapshot.forEach(doc => {
      stats[doc.id] = serializeFirestoreData(doc.data());
    });
    
    const data = {
      lastUpdated: new Date().toISOString(),
      stats: stats
    };
    
    res.set('Access-Control-Allow-Origin', '*');
    res.set('Content-Type', 'application/json');
    res.json(data);
  } catch (error) {
    res.status(500).json({ error: error.message });
  }
});

// Serve NBA Stats JSON
app.get('/data/nba-stats.json', async (req, res) => {
  try {
    const db = initializeFirebase();
    const playerStatsSnapshot = await db.collection('nbaStats').get();
    const teamStatsSnapshot = await db.collection('nbaTeamStats').get();
    
    const playerStats = {};
    playerStatsSnapshot.forEach(doc => {
      playerStats[doc.id] = serializeFirestoreData(doc.data());
    });
    
    const teamStats = {};
    teamStatsSnapshot.forEach(doc => {
      teamStats[doc.id] = serializeFirestoreData(doc.data());
    });
    
    const data = {
      lastUpdated: new Date().toISOString(),
      playerStats: playerStats,
      teamStats: teamStats
    };
    
    res.set('Access-Control-Allow-Origin', '*');
    res.set('Content-Type', 'application/json');
    res.json(data);
  } catch (error) {
    res.status(500).json({ error: error.message });
  }
});

// Serve CFP Standings JSON
// Serve Top 25 rankings for NCAA leagues
app.get('/data/top25/:leagueKey.json', async (req, res) => {
  try {
    const { leagueKey } = req.params;
    const db = initializeFirebase();
    
    const collectionMap = {
      'NCAAF': 'NCAAFStandings',
      'NCAAM': 'NCAAMStandings',
      'NCAAW': 'NCAAWStandings'
    };
    
    const collectionName = collectionMap[leagueKey];
    if (!collectionName) {
      return res.status(400).json({ error: 'Invalid league key' });
    }
    
    const snapshot = await db.collection(collectionName).get();
    const teams = [];
    
    snapshot.forEach(doc => {
      const team = serializeFirestoreData(doc.data());
      // Only include teams with Top25Rank
      if (team.Top25Rank !== null && team.Top25Rank !== undefined) {
        teams.push(team);
      }
    });
    
    // Sort by rank
    teams.sort((a, b) => {
      const rankA = parseInt(a.Top25Rank) || 999;
      const rankB = parseInt(b.Top25Rank) || 999;
      return rankA - rankB;
    });
    
    res.set('Access-Control-Allow-Origin', '*');
    res.set('Content-Type', 'application/json');
    res.json({
      lastUpdated: new Date().toISOString(),
      teams: teams
    });
  } catch (error) {
    console.error(`Error fetching Top 25 for ${req.params.leagueKey}:`, error);
    res.status(500).json({ error: error.message });
  }
});

// Serve NCAA standings for a specific league
app.get('/data/ncaa-standings/:leagueKey.json', async (req, res) => {
  try {
    const { leagueKey } = req.params;
    const db = initializeFirebase();
    
    const collectionMap = {
      'NCAAF': 'NCAAFStandings',
      'NCAAM': 'NCAAMStandings',
      'NCAAW': 'NCAAWStandings'
    };
    
    const collectionName = collectionMap[leagueKey];
    if (!collectionName) {
      return res.status(400).json({ error: 'Invalid league key' });
    }
    
    const snapshot = await db.collection(collectionName).get();
    const teams = [];
    
    snapshot.forEach(doc => {
      teams.push(serializeFirestoreData(doc.data()));
    });
    
    res.set('Access-Control-Allow-Origin', '*');
    res.set('Content-Type', 'application/json');
    res.json({
      lastUpdated: new Date().toISOString(),
      teams: teams
    });
  } catch (error) {
    console.error(`Error fetching standings for ${req.params.leagueKey}:`, error);
    res.status(500).json({ error: error.message });
  }
});

app.get('/data/cfp-standings.json', async (req, res) => {
  try {
    const db = initializeFirebase();
    const snapshot = await db.collection('CFP').get();
    
    const standings = [];
    snapshot.forEach(doc => {
      standings.push({
        id: doc.id,
        ...serializeFirestoreData(doc.data())
      });
    });
    
    const data = {
      lastUpdated: new Date().toISOString(),
      standings: standings
    };
    
    res.set('Access-Control-Allow-Origin', '*');
    res.set('Content-Type', 'application/json');
    res.json(data);
  } catch (error) {
    res.status(500).json({ error: error.message });
  }
});

// Serve Today Slate JSON
app.get('/data/today-slate.json', async (req, res) => {
  try {
    const db = initializeFirebase();
    const docRef = db.collection('system').doc('todaySlate');
    const doc = await docRef.get();
    
    const data = {
      lastUpdated: new Date().toISOString(),
      slate: doc.exists ? serializeFirestoreData(doc.data()) : null
    };
    
    res.set('Access-Control-Allow-Origin', '*');
    res.set('Content-Type', 'application/json');
    res.json(data);
  } catch (error) {
    res.status(500).json({ error: error.message });
  }
});

// Endpoint to get game-specific content (replaces direct Firestore access)
app.get('/data/game/:gameId.json', async (req, res) => {
  try {
    const db = initializeFirebase();
    const gameId = req.params.gameId;
    
    const gamesRef = db.collection("artifacts/flashlive-daily-scraper/public/data/sportsGames");
    
    // First try to find by document ID (games are written with Game ID as doc ID)
    let gameDoc = await gamesRef.doc(gameId).get();
    
    // If not found by document ID, try querying by Game ID field
    if (!gameDoc.exists) {
      const snapshot = await gamesRef.where('Game ID', '==', gameId).limit(1).get();
      if (!snapshot.empty) {
        gameDoc = snapshot.docs[0];
      }
    }
    
    // Also check yesterdayScores collection if still not found
    if (!gameDoc.exists) {
      const yesterdayRef = db.collection("artifacts/flashlive-daily-scraper/public/data/yesterdayScores");
      let yesterdayDoc = await yesterdayRef.doc(gameId).get();
      if (!yesterdayDoc.exists) {
        const yesterdaySnapshot = await yesterdayRef.where('Game ID', '==', gameId).limit(1).get();
        if (!yesterdaySnapshot.empty) {
          yesterdayDoc = yesterdaySnapshot.docs[0];
        }
      }
      if (yesterdayDoc.exists) {
        gameDoc = yesterdayDoc;
      }
    }
    
    if (!gameDoc.exists) {
      res.status(404).json({ error: 'Game not found', gameId: gameId });
      return;
    }
    
    const data = {
      'Game ID': gameDoc.data()['Game ID'] || gameDoc.id,
      ...serializeFirestoreData(gameDoc.data())
    };
    
    res.set('Access-Control-Allow-Origin', '*');
    res.set('Content-Type', 'application/json');
    res.json(data);
  } catch (error) {
    res.status(500).json({ error: error.message });
  }
});

// Endpoint to get upcoming games for a specific league collection
// Example: /data/nfl-upcoming.json, /data/nba-upcoming.json, etc.
app.get('/data/:collectionName-upcoming.json', async (req, res) => {
  try {
    const db = initializeFirebase();
    const collectionName = req.params.collectionName;
    
    // Validate collection name (prevent path traversal attacks)
    if (!collectionName || !/^[a-zA-Z0-9]+$/.test(collectionName)) {
      res.status(400).json({ error: 'Invalid collection name' });
      return;
    }
    
    // Read from Firestore collection (e.g., "NFL", "NBA", "MLB")
    // Note: Collection names are case-sensitive in Firestore, so we need to handle the case
    // Frontend sends lowercase (nfl, nba) but Firestore collections are uppercase (NFL, NBA)
    const firestoreCollectionName = collectionName.charAt(0).toUpperCase() + collectionName.slice(1).toLowerCase();
    
    // Handle special cases where collection name doesn't match simple capitalization
    const collectionNameMap = {
      'nfl': 'NFL',
      'nba': 'NBA',
      'mlb': 'MLB',
      'nhl': 'NHL',
      'mls': 'MLS',
      'premierleague': 'PremierLeague',
      'laliga': 'LaLiga',
      'seriea': 'SerieA',
      'bundesliga': 'Bundesliga',
      'ligue1': 'Ligue1',
      'ncaaf': 'NCAAF',
      'wnba': 'WNBA',
      'soccer': 'Soccer',
      'uefachampionsleague': 'UEFAChampionsLeague',
      'afcchampionsleague': 'AFCChampionsLeague',
      'facup': 'FACup',
      'ligamx': 'LigaMX',
      'nwsl': 'NWSL',
      'uefaeuropaleague': 'UEFAEuropaLeague',
      'uefaconferenceleague': 'UEFAConferenceLeague',
      'formulaone': 'FormulaOne',
      'pgatour': 'PGATour',
      'ufc': 'UFC',
      'boxing': 'Boxing',
      'nascarcupseries': 'NASCARCupSeries',
      'tennis': 'Tennis',
      'livgolf': 'LIVGolf',
      'indycar': 'IndyCar',
      'ncaam': 'NCAAM',
      'ncaaw': 'NCAAW',
      'ncaabaseball': 'NCAABaseball',
      'ncaasoftball': 'NCAASoftball',
      'worldcupu17': 'WorldCupU17',
      'worldcupu17playoffs': 'WorldCupU17PlayOffs',
      'motogp': 'MotoGP',
      'lpgatour': 'LPGATour',
      'trackandfield': 'TrackAndField'
    };
    
    const actualCollectionName = collectionNameMap[collectionName.toLowerCase()] || firestoreCollectionName;
    
    const upcomingRef = db.collection(actualCollectionName);
    const snapshot = await upcomingRef.get();
    
    const games = [];
    snapshot.forEach(doc => {
      const data = doc.data();
      games.push({
        id: doc.id,
        ...serializeFirestoreData(data)
      });
    });
    
    const result = {
      lastUpdated: new Date().toISOString(),
      collectionName: actualCollectionName,
      gameCount: games.length,
      games: games
    };
    
    res.set('Access-Control-Allow-Origin', '*');
    res.set('Access-Control-Allow-Methods', 'GET, OPTIONS');
    res.set('Access-Control-Allow-Headers', 'Content-Type, Cache-Control, Pragma');
    res.set('Content-Type', 'application/json');
    res.set('Cache-Control', 'no-store, no-cache, must-revalidate, proxy-revalidate');
    res.set('Pragma', 'no-cache');
    res.set('Expires', '0');
    
    res.status(200).json(result);
  } catch (error) {
    console.error(`[upcoming.json] Error fetching ${req.params.collectionName}:`, error);
    res.status(500).json({ 
      error: 'Failed to fetch upcoming games',
      message: error.message 
    });
  }
});

// Handle OPTIONS requests for CORS preflight
app.options('/data/:collectionName-upcoming.json', (req, res) => {
  res.set('Access-Control-Allow-Origin', '*');
  res.set('Access-Control-Allow-Methods', 'GET, OPTIONS');
  res.set('Access-Control-Allow-Headers', 'Content-Type, Cache-Control, Pragma');
  res.status(204).end();
});

// Catch-all route to log all requests (for debugging Gen2 routing)
app.use((req, res, next) => {
  if (req.path !== '/pollESPNLiveData' && req.path !== '/morningRefresh' && req.path !== '/') {
    console.log(`‚ö†Ô∏è Unhandled request: ${req.method} ${req.path} from ${req.headers?.['user-agent'] || 'unknown'}`);
  }
  next();
});

// For local development only
if (process.env.NODE_ENV !== 'production' && !process.env.FUNCTION_TARGET) {
  const PORT = process.env.PORT || 8080;
  app.listen(PORT, () => {
    console.log(`Server listening on port ${PORT}`);
  });
}

// Export for Cloud Functions
export default app;











