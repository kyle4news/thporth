// index.js
import { DateTime } from 'luxon';
import admin from 'firebase-admin';
import { google } from 'googleapis';
import fetch from 'node-fetch';
import express from 'express';
import * as cheerio from 'cheerio';
import puppeteer from 'puppeteer';
import { createRequire } from 'module';
const require = createRequire(import.meta.url);

// Import Perspectives functions (will be loaded when endpoints are called)
let perspectivesCore;
async function loadPerspectivesCore() {
  if (!perspectivesCore) {
    perspectivesCore = await import('./perspectives-core.js');
  }
  return perspectivesCore;
}




// Firebase Admin initialization using application default credentials
let db;
function initializeFirebase() {
if (db) return db; // Return existing db instance if already initialized
if (!admin.apps.length) {
 admin.initializeApp({
   credential: admin.credential.applicationDefault(),
   projectId: process.env.FIREBASE_PROJECT_ID
 });
}
db = admin.firestore();
console.log('Firebase Firestore initialized.');
return db;
}




const SPREADSHEET_ID = process.env.SPREADSHEET_ID;
const SHEET_NAME = process.env.SHEET_NAME;
const RAPIDAPI_KEY = process.env.RAPIDAPI_KEY;
const RAPIDAPI_HOST = process.env.RAPIDAPI_HOST;
const FIREBASE_PROJECT_ID = process.env.FIREBASE_PROJECT_ID;
const API_REQUEST_DELAY_MS = 1500;
// Delay to allow Apps Script onChange (UTC->EST) to finish before reading/filtering
const SHEETS_CONVERSION_DELAY_MS = parseInt(process.env.SHEETS_CONVERSION_DELAY_MS || '60000', 10);

// Google Sheets configuration for importing games
const SHEET_ID = '1gGY9dr485hf4WrdGkx01kC6Gw7oTuKeYYh_UQD5qkt4';
const SHEET_ID_2 = '1qpr6PShU_wGH0JzBQGqklYEqwV1c0Ho8KhSjgBxhtN8';
const SHEET_ID_3 = '1Kbkg7jZOoiynLX5QPnM-T6M3gSYRZxMgOyJ5xxfHN4Q';
const SHEET_ID_4 = '1Yw2A9-7hgGaZEOftq9REuRPp9SCF6hTBmtx79MN790s';
const MANUAL_LEAGUES_TO_SPORTSGAMES = ['MotoGP', 'Boxing', 'UFC', 'PGATour', 'LPGATour', 'LIVGolf', 'USMNT', 'FormulaOne', 'NCAAM', 'NCAAW'];
const LEAGUE_DISPLAY_NAME_MAP = {
  'MotoGP': 'MotoGP',
  'Boxing': 'Boxing',
  'UFC': 'UFC',
  'PGATour': 'PGA Tour',
  'LPGATour': 'LPGA Tour',
  'LIVGolf': 'LIV Golf',
  'USMNT': 'USMNT',
  'FormulaOne': 'Formula 1',
  'NCAAM': 'USA: NCAA',
  'NCAAW': 'USA: NCAA Women'
};
const LEAGUE_TO_SPORT_MAP = {
  'MotoGP': 'Motorsport',
  'Boxing': 'Boxing',
  'UFC': 'Boxing',
  'PGATour': 'Motorsport',
  'LPGATour': 'Motorsport',
  'LIVGolf': 'Motorsport',
  'USMNT': 'Soccer',
  'FormulaOne': 'Motorsport',
  'NCAAM': 'Basketball',
  'NCAAW': 'Basketball'
};
const MANUAL_LEAGUE_CONFIGS = {
  'MotoGP': {
    sheetName: 'MotoGP',
    fields: {
      date: 'Date',
      time: 'Time',
      awayTeam: 'Away Team',
      homeTeam: 'Home Team',
      channel: 'Channel'
    }
  },
  'Boxing': {
    sheetName: 'Boxing',
    fields: {
      date: 'Date',
      time: 'Time',
      awayTeam: 'Away Team',
      homeTeam: 'Home Team',
      channel: 'Channel'
    }
  },
  'UFC': {
    sheetName: 'UFC',
    fields: {
      date: 'Date',
      time: 'Time',
      awayTeam: 'Away Team',
      homeTeam: 'Home Team',
      channel: 'Channel'
    }
  },
  'PGATour': {
    sheetName: 'PGATour',
    fields: {
      date: 'Date',
      time: 'Time',
      awayTeam: 'Away Team',
      homeTeam: 'Home Team',
      channel: 'Channel'
    }
  },
  'LPGATour': {
    sheetName: 'LPGATour',
    fields: {
      date: 'Date',
      time: 'Time',
      awayTeam: 'Away Team',
      homeTeam: 'Home Team',
      channel: 'Channel'
    }
  },
  'LIVGolf': {
    sheetName: 'LIVGolf',
    fields: {
      date: 'Date',
      time: 'Time',
      awayTeam: 'Away Team',
      homeTeam: 'Home Team',
      channel: 'Channel'
    }
  },
  'USMNT': {
    sheetName: 'USMNT',
    fields: {
      date: 'Date',
      time: 'Time',
      awayTeam: 'Away Team',
      homeTeam: 'Home Team',
      channel: 'Channel'
    }
  },
  'FormulaOne': {
    sheetName: 'FormulaOne',
    fields: {
      date: 'Date',
      time: 'Time',
      awayTeam: 'Away Team',
      homeTeam: 'Home Team',
      channel: 'Channel'
    }
  },
  'NCAAM': {
    sheetName: 'NCAAM',
    fields: {
      date: 'Date',
      time: 'Time',
      awayTeam: 'Away Team',
      homeTeam: 'Home Team',
      channel: 'Channel'
    }
  },
  'NCAAW': {
    sheetName: 'NCAAW',
    fields: {
      date: 'Date',
      time: 'Time',
      awayTeam: 'Away Team',
      homeTeam: 'Home Team',
      channel: 'Channel'
    }
  }
};




// Allowed leagues with sport-specific filtering
const ALLOWED_LEAGUE_KEYWORDS = {
// Soccer-specific leagues
'Soccer': [
  "Euro Women", "Europe: Conference League - League phase", "Leagues Cup", "Europa League", "North & Central America: Leagues Cup - Play Offs",
  // "World: Club Friendly", // Commented out - can be easily re-added later
  "Conference League", "Portugal: Super Cup", "UEFA Champions League", "Europe: Champions League - League phase",
  "World: Friendly International",
  "England: Premier League", "England: EFL Cup", "England: FA Cup", "Italy: Coppa Italia", "USA: MLS - Play Offs",
  "Turkey: Super Lig", "Europe: Europa League - Qualification", "Europe: Europa League - League phase", "Europe: Champions League Women - Qualification - Second stage",
  "Europe: Conference League - Qualification", "Germany: Bundesliga", "Portugal: Liga Portugal", "Italy: Serie A",
  "France: Ligue 1", "South America: Copa Libertadores - Play Offs", "Brazil: Serie A Betano", "World: World Cup U20", "World: World Cup U17",
  "South America: Copa Sudamericana - Play Offs", "Europe: Champions League - Qualification",
  "Germany: DFB Pokal", "World: Club Friendly", "Spain: LaLiga", "USA: NWSL Women", "USA: NWSL Women - Play Offs","USA: MLS", "USA: MLS - Play Offs", "Mexico: Liga MX", "Mexico: Liga MX - Apertura", "Mexico: Liga MX - Clausura", "Mexico: Liga MX - Apertura - Play In", "Mexico: Liga MX - Apertura - Play Offs", "Saudi Arabia: Saudi Professional League",
  // ‚úÖ Newly added
  "England: Championship", "World: World Cup U20 - Play Offs", "World: World Cup U17 - Play Offs", "USA: USL Championship", "Europe: Champions League Women - League phase", "Scotland: Premiership", "England: WSL", "Netherlands: Eredivisie", "North & Central America: Campeones Cup", "Argentina: Torneo Betano - Clausura", "Argentina: Torneo Betano - Apertura", "Argentina: Torneo Betano - Clausura - Play Offs", "Scotland: Scottish Cup", "Belgium: Jupiler Pro League", "Spain: Copa del Rey"
],
// Basketball-specific leagues
'Basketball': [
  "USA: NBA", "NBA", "USA: WNBA", "WNBA", "World: AmeriCup", "USA: NBA - Pre-season", "USA: NCAA", "USA: NCAA Women",
  // ‚úÖ Newly added
  "USA: WNBA - Play Offs"
],
// American Football-specific leagues
'American Football': [
  "NFL", "USA: NFL", "USA: NCAA", "USA: NFL - Pre-season", "Canada: CFL"
],
// Tennis-specific leagues
'Tennis': [
  "USA: Cleveland WTA, hard",
  "USA: US Open ATP, hard", "USA: US Open WTA, hard"
],
// Auto Racing specific leagues
'Auto Racing': [
  "NASCAR Cup Series"
],
// Cricket-specific leagues
'Cricket': [
  "World: ICC World Cup Women", "World: Twenty20 International", "World: Test Series", "World: One Day International"
],
// Hockey-specific leagues
'Hockey': [
  "USA: NHL", "NHL", "USA: NHL - Pre-season", "Canada: OHL", "USA: NCAA"
],
// Golf-specific leagues
'Golf': [
  // ‚úÖ Newly added
  "World: Ryder Cup", "DP World Tour", "PGA Champions"
],
// Motorsport-specific leagues (using regex-like matching in filter)
'Motorsport': [
  // TEMPORARILY DISABLED: Formula 1 is now handled via manual entry
  // All Formula 1 events will be matched by game.League.includes('Formula 1') in deduplication
  // "Formula 1"
]
};




const sportsToFetch = [
// { slug: 'soccer', id: 1, name: 'Soccer' },
// { slug: 'tennis', id: 2, name: 'Tennis' },
// { slug: 'basketball', id: 3, name: 'Basketball' },
// { slug: 'hockey', id: 4, name: 'Hockey' },
// { slug: 'football', id: 5, name: 'American Football' },
// { slug: 'baseball', id: 6, name: 'Baseball' },
// { slug: 'rugby_union', id: 8, name: 'Rugby Union' },
// { slug: 'volleyball', id: 12, name: 'Volleyball' },
// { slug: 'cricket', id: 13, name: 'Cricket' },
// { slug: 'boxing', id: 16, name: 'Boxing' },
// { slug: 'beach_volleyball', id: 17, name: 'Beach Volleyball' },
// { slug: 'aussie_rules', id: 18, name: 'Aussie Rules' },
// { slug: 'rugby_league', id: 19, name: 'Rugby League' },
// { slug: 'water_polo', id: 22, name: 'Water Polo' },
// { slug: 'golf', id: 23, name: 'Golf' },
// { slug: 'mma', id: 28, name: 'MMA' },
// { slug: 'motorsport', id: 31, name: 'Motorsport' },
// { slug: 'autoracing', id: 32, name: 'Autoracing' },
// { slug: 'motoracing', id: 33, name: 'Motoracing' },
// { slug: 'cycling', id: 34, name: 'Cycling' },
// { slug: 'horse_racing', id: 35, name: 'Horse Racing' },
// { slug: 'winter_sports', id: 37, name: 'Winter Sports' },
// { slug: 'ski_jumping', id: 38, name: 'Ski Jumping' },
// { slug: 'alpine_skiing', id: 39, name: 'Alpine Skiing' },
// { slug: 'cross_country', id: 40, name: 'Cross Country' }
];




// Mapping of leagues to their RapidAPI sport slug, sport ID, and league name for the new function
const leaguesToFetch = [
{ slug: 'golf', id: 23, leagueName: 'PGA Tour' },
{ slug: 'tennis', id: 2, leagueName: 'ATP' },
{ slug: 'tennis', id: 2, leagueName: 'WTA' },
{ slug: 'football', id: 5, leagueName: 'USA: NCAA' },
{ slug: 'soccer', id: 1, leagueName: 'NWSL Women' },
{ slug: 'soccer', id: 1, leagueName: 'France: Ligue 1' },
{ slug: 'soccer', id: 1, leagueName: 'Europe: Europa League' },
{ slug: 'soccer', id: 1, leagueName: 'Europe: Conference League' }
];




let sheets;
let serviceAccountEmail = null;

// Rate limiter for Google Sheets API (60 requests/minute = 1 request/second, using 1.5s for safety)
let lastSheetRequestTime = 0;
const MIN_TIME_BETWEEN_REQUESTS = 1500; // 1.5 seconds between requests

async function rateLimitedSheetRequest(requestFn, retries = 5) {
  for (let attempt = 1; attempt <= retries; attempt++) {
    try {
      // Wait if needed to respect rate limit
      const now = Date.now();
      const timeSinceLastRequest = now - lastSheetRequestTime;
      if (timeSinceLastRequest < MIN_TIME_BETWEEN_REQUESTS) {
        const waitTime = MIN_TIME_BETWEEN_REQUESTS - timeSinceLastRequest;
        await new Promise(resolve => setTimeout(resolve, waitTime));
      }
      
      lastSheetRequestTime = Date.now();
      const result = await requestFn();
      return result;
    } catch (error) {
      const isQuotaError = error.message && (
        error.message.includes('Quota exceeded') ||
        error.message.includes('quota') ||
        error.message.includes('rate limit') ||
        error.message.includes('429') ||
        (error.code === 429) ||
        (error.response && error.response.status === 429)
      );
      
      if (isQuotaError && attempt < retries) {
        // Exponential backoff: 2s, 4s, 8s, 16s, 32s
        const backoffTime = Math.min(2000 * Math.pow(2, attempt - 1), 32000);
        console.warn(`‚ö†Ô∏è  Google Sheets quota error (attempt ${attempt}/${retries}). Retrying in ${backoffTime/1000}s...`);
        await new Promise(resolve => setTimeout(resolve, backoffTime));
        continue;
      }
      
      // If not a quota error or out of retries, throw the error
      throw error;
    }
  }
}

async function authenticateGoogleSheets() {
if (sheets) return;
const googleAuth = new google.auth.GoogleAuth({
 scopes: ['https://www.googleapis.com/auth/spreadsheets'],
});
const authClient = await googleAuth.getClient();
// Log which service account is being used
const projectId = await googleAuth.getProjectId();
const credentials = await googleAuth.getCredentials();
console.log(`Google Sheets API authenticated. Project: ${projectId}`);
if (credentials.client_email) {
  serviceAccountEmail = credentials.client_email;
  console.log(`Using service account: ${serviceAccountEmail}`);
} else {
  console.log('Using application default credentials (service account determined by Cloud Run)');
}
sheets = google.sheets({ version: 'v4', auth: authClient });
}

async function clearGoogleSheet(spreadsheetId, sheetName) {
  try {
    console.log(`Clearing Google Sheet "${sheetName}"...`);
    await rateLimitedSheetRequest(() => 
      sheets.spreadsheets.values.clear({
        spreadsheetId: spreadsheetId,
        range: `${sheetName}!A:Z`
      })
    );
    console.log(`Successfully cleared Google Sheet "${sheetName}".`);
  } catch (err) {
    console.error(`Error clearing Google Sheet "${sheetName}":`, err.message);
    throw err;
  }
}

// Helper functions for manual games import
function parseDateForManualGames(dateStr) {
  if (!dateStr) return null;
  
  let date;
  
  // If it's a number (Excel serial date), convert it
  // Excel/Google Sheets date is days since 1899-12-30
  if (typeof dateStr === 'number') {
    // Excel epoch is December 30, 1899
    const excelEpoch = new Date('1899-12-30T00:00:00Z');
    const daysSinceEpoch = Math.floor(dateStr);
    date = new Date(excelEpoch.getTime() + daysSinceEpoch * 24 * 60 * 60 * 1000);
  } else {
    // Try to parse as a date string
    date = new Date(dateStr);
  }
  
  if (isNaN(date.getTime())) {
    console.warn(`Invalid date: ${dateStr}`);
    return null;
  }
  
  const year = date.getUTCFullYear();
  const month = String(date.getUTCMonth() + 1).padStart(2, '0');
  const day = String(date.getUTCDate()).padStart(2, '0');
  return `${year}-${month}-${day}`;
}

function parseTimeForManualGames(timeStr) {
  if (!timeStr) return '';
  
  // If it's already a string with time format, return it
  if (typeof timeStr === 'string' && timeStr.includes(':')) {
    return timeStr.trim();
  }
  
  let hours = 0;
  let minutes = 0;
  
  // If it's a number (Excel serial time), convert it
  // Excel/Google Sheets time is a fraction of a day (0.0 = midnight, 0.5 = noon)
  if (typeof timeStr === 'number') {
    const totalSeconds = Math.floor(timeStr * 86400); // 86400 seconds in a day
    hours = Math.floor(totalSeconds / 3600);
    minutes = Math.floor((totalSeconds % 3600) / 60);
  }
  // If it's a Date object, Google Sheets returns time-only values as Date objects
  // The Date object represents the time in UTC, but we need to extract it as EST
  // Google Sheets stores time-only values using Excel epoch (1899-12-30) as the date
  else if (timeStr instanceof Date) {
    // Check if this is a time-only value (date is 1899-12-30, Excel epoch)
    const isTimeOnly = timeStr.getUTCFullYear() === 1899 && 
                       timeStr.getUTCMonth() === 11 && 
                       timeStr.getUTCDate() === 30;
    
    if (isTimeOnly) {
      // This is a time-only value - extract UTC hours/minutes (these represent the raw time)
      hours = timeStr.getUTCHours();
      minutes = timeStr.getUTCMinutes();
    } else {
      // This is a full datetime - extract UTC hours/minutes
      hours = timeStr.getUTCHours();
      minutes = timeStr.getUTCMinutes();
    }
  } else {
    return String(timeStr).trim();
  }
  
  // Format as "H:MM AM/PM" - these hours/minutes represent EST time from Google Sheets
  const ampm = hours >= 12 ? 'PM' : 'AM';
  let displayHours = hours % 12;
  if (displayHours === 0) displayHours = 12;
  const displayMinutes = minutes.toString().padStart(2, '0');
  return `${displayHours}:${displayMinutes} ${ampm}`;
}

function createFirestoreTimestamp(dateStr, timeStr) {
  if (!dateStr) return null;
  
  // All times in sheets 1-4 are in Eastern U.S. time
  // Parse date and time as Eastern, then convert to UTC for Firestore
  let dateTime;
  
  if (dateStr.match(/^\d{4}-\d{2}-\d{2}$/)) {
    const [year, month, day] = dateStr.split('-').map(Number);
    
    if (timeStr) {
      // Parse time in Eastern timezone
      const timeMatch = timeStr.match(/(\d+):(\d+)\s*(AM|PM)?/i);
      if (timeMatch) {
        let hours = parseInt(timeMatch[1]);
        const minutes = parseInt(timeMatch[2]);
        const ampm = timeMatch[3]?.toUpperCase();
        
        // Handle AM/PM conversion
        if (ampm === 'PM' && hours !== 12) hours += 12;
        if (ampm === 'AM' && hours === 12) hours = 0;
        
        // Create DateTime in Eastern timezone, then convert to UTC
        dateTime = DateTime.fromObject({
          year,
          month,
          day,
          hour: hours,
          minute: minutes,
          second: 0
        }, { zone: 'America/New_York' });
      } else {
        // No valid time, use midnight Eastern
        dateTime = DateTime.fromObject({
          year,
          month,
          day,
          hour: 0,
          minute: 0,
          second: 0
        }, { zone: 'America/New_York' });
      }
    } else {
      // No time provided, use midnight Eastern
      dateTime = DateTime.fromObject({
        year,
        month,
        day,
        hour: 0,
        minute: 0,
        second: 0
      }, { zone: 'America/New_York' });
    }
  } else {
    // Fallback for other date formats
    const date = new Date(dateStr);
    if (isNaN(date.getTime())) {
      console.warn(`Invalid date for timestamp: ${dateStr}`);
      return null;
    }
    dateTime = DateTime.fromJSDate(date, { zone: 'America/New_York' });
    if (timeStr) {
      const timeMatch = timeStr.match(/(\d+):(\d+)\s*(AM|PM)?/i);
      if (timeMatch) {
        let hours = parseInt(timeMatch[1]);
        const minutes = parseInt(timeMatch[2]);
        const ampm = timeMatch[3]?.toUpperCase();
        if (ampm === 'PM' && hours !== 12) hours += 12;
        if (ampm === 'AM' && hours === 12) hours = 0;
        dateTime = dateTime.set({ hour: hours, minute: minutes });
      }
    }
  }
  
  if (!dateTime || !dateTime.isValid) {
    console.warn(`Invalid date/time for timestamp: ${dateStr} ${timeStr}`);
    return null;
  }
  
  // Convert to UTC and create Firestore timestamp
  const utcDate = dateTime.toUTC().toJSDate();
  return admin.firestore.Timestamp.fromDate(utcDate);
}

async function getManualSheetData(sheetName) {
  try {
    const response = await rateLimitedSheetRequest(() =>
      sheets.spreadsheets.values.get({
        spreadsheetId: SHEET_ID_4,
        range: `${sheetName}!A:Z`,
        valueRenderOption: 'UNFORMATTED_VALUE' // Get raw values (numbers) instead of formatted strings/Date objects
      })
    );
    return response.data.values || [];
  } catch (error) {
    console.error(`Error reading sheet ${sheetName}:`, error.message);
    return [];
  }
}

async function fetchManualGamesFromSheets(todayStr, tomorrowStr) {
  const allManualGames = [];
  
  console.log(`Looking for manual games with dates: today=${todayStr}, tomorrow=${tomorrowStr}`);
  
  // Exclude NCAAF, NCAAM, NCAAW from manual sheets since they're fetched from ESPN/NCAA APIs
  const LEAGUES_TO_EXCLUDE_FROM_MANUAL = ['NCAAF', 'NCAAM', 'NCAAW'];
  
  for (const [leagueName, config] of Object.entries(MANUAL_LEAGUE_CONFIGS)) {
    // Skip leagues that are fetched from APIs to avoid duplicates
    if (LEAGUES_TO_EXCLUDE_FROM_MANUAL.includes(leagueName)) {
      console.log(`Skipping ${leagueName} from manual sheets (fetched from API instead)`);
      continue;
    }
    try {
      // Rate limiting is now handled inside getManualSheetData via rateLimitedSheetRequest
      console.log(`Fetching manual games for ${leagueName} from sheet "${config.sheetName}"...`);
      const data = await getManualSheetData(config.sheetName);
      
      if (data.length === 0) {
        console.log(`No data found for ${leagueName} (sheet "${config.sheetName}" is empty or doesn't exist)`);
        continue;
      }
      
      console.log(`Found ${data.length} rows in ${leagueName} sheet`);
      const headers = data[0];
      console.log(`Headers found: ${headers.join(', ')}`);
      const dataRows = data.slice(1);
      
      // Find column indices for each field
      const fieldIndices = {};
      Object.entries(config.fields).forEach(([key, fieldName]) => {
        const index = headers.findIndex(header => 
          header && header.toLowerCase().includes(fieldName.toLowerCase())
        );
        if (index !== -1) {
          fieldIndices[key] = index;
          console.log(`  Found field "${fieldName}" at column index ${index}`);
        } else {
          console.warn(`  Field "${fieldName}" not found in ${leagueName} headers`);
        }
      });
      
      if (Object.keys(fieldIndices).length === 0) {
        console.warn(`No valid fields found for ${leagueName}, skipping...`);
        continue;
      }

      const featuredColumnIndex = headers.findIndex(header => header && header.trim().toLowerCase() === 'featured');
      if (featuredColumnIndex === -1) {
        console.log(`  ‚ÑπÔ∏è  No "Featured" column found for ${leagueName} (manual sheet)`);
      } else {
        console.log(`  ‚úì Found "Featured" column at index ${featuredColumnIndex}`);
      }
      
      let gameIdCounter = 1;
      let leagueGameCount = 0;
      let skippedDateCount = 0;
      let displayOrder = 0;
      
      // Process all leagues (including Boxing) - each row independently
        for (const row of dataRows) {
          // Check if row is empty (handle both strings and numbers from UNFORMATTED_VALUE)
          if (row.every(cell => cell === null || cell === undefined || cell === '' || (typeof cell === 'string' && cell.trim() === ''))) continue;
          
          const rawDate = row[fieldIndices.date];
          const dateStr = rawDate !== null && rawDate !== undefined && rawDate !== '' ? parseDateForManualGames(rawDate) : null;
          
          if (!dateStr) {
            console.warn(`  Skipping row with invalid date: ${rawDate}`);
            continue;
          }
          
          // Only include games for today or tomorrow
          if (dateStr !== todayStr && dateStr !== tomorrowStr) {
            skippedDateCount++;
            if (skippedDateCount <= 3) {
              console.log(`  Skipping game with date ${dateStr} (not today or tomorrow)`);
            }
            continue;
          }
          
          // Get time from row - if blank, allow it (will show as empty on site, no inheritance from previous row)
          let timeStr = '';
          const rawTime = row[fieldIndices.time];
          if (rawTime !== null && rawTime !== undefined && rawTime !== '') {
            timeStr = parseTimeForManualGames(rawTime);
            if (!timeStr) {
              console.warn(`  Skipping row with invalid time: ${rawTime}`);
              continue;
            }
          } else {
            // Empty time - allow it, will show as empty on site
            timeStr = '';
          }
          
          const channel = row[fieldIndices.channel] !== null && row[fieldIndices.channel] !== undefined && row[fieldIndices.channel] !== '' 
            ? String(row[fieldIndices.channel]).trim() 
            : '';
          
          // Only create timestamp if time is provided; if time is blank, use 11:59 PM so blank times sort at end of day
          const startTime = timeStr ? createFirestoreTimestamp(dateStr, timeStr) : createFirestoreTimestamp(dateStr, '11:59 PM');
          if (!startTime) continue;
          
          // Get team fields first (before creating gameData)
          // Support both 'away'/'home' and 'awayTeam'/'homeTeam' field names
          const awayIndex = fieldIndices.awayTeam !== undefined ? fieldIndices.awayTeam : (fieldIndices.away !== undefined ? fieldIndices.away : undefined);
          const homeIndex = fieldIndices.homeTeam !== undefined ? fieldIndices.homeTeam : (fieldIndices.home !== undefined ? fieldIndices.home : undefined);
          
          let awayTeam = awayIndex !== undefined && row[awayIndex] !== null && row[awayIndex] !== undefined && row[awayIndex] !== ''
            ? String(row[awayIndex]).trim() 
            : '';
          let homeTeam = homeIndex !== undefined && row[homeIndex] !== null && row[homeIndex] !== undefined && row[homeIndex] !== ''
            ? String(row[homeIndex]).trim() 
            : '';
          
          const leagueDisplayName = LEAGUE_DISPLAY_NAME_MAP[leagueName] || leagueName;
          const sport = LEAGUE_TO_SPORT_MAP[leagueName] || 'Other';
          
          const gameData = {
            'League': leagueDisplayName,
            'Sport': sport,
            'Start Time': startTime,
            'gameDate': dateStr,
            'Match Status': 'SCHEDULED',
            'Channel': channel,
            'channel': channel,
            'Last Updated': admin.firestore.FieldValue.serverTimestamp()
          };
          
          // Store the time string so frontend can display it as empty if blank
          if (!timeStr) {
            gameData['timeString'] = ''; // Empty time string for frontend to display as blank
          }
          
          gameData['Home Team'] = homeTeam;
          gameData['Away Team'] = awayTeam;
          gameData['Matchup'] = awayTeam && homeTeam ? `${awayTeam} vs ${homeTeam}` : (homeTeam || awayTeam);

          if (featuredColumnIndex !== -1) {
            const featuredValue = row[featuredColumnIndex];
            if (featuredValue !== null && featuredValue !== undefined && featuredValue !== '') {
              const featuredId = String(featuredValue).trim();
              if (featuredId) {
                gameData['Featured'] = featuredId;
              }
            }
          }
          
          // Generate deterministic Game ID based on league, teams, and date (NOT time - same game should have same ID)
          const normalizedHome = (homeTeam || '').toLowerCase().trim().replace(/[^a-z0-9]/g, '');
          const normalizedAway = (awayTeam || '').toLowerCase().trim().replace(/[^a-z0-9]/g, '');
          const normalizedLeague = leagueName.toLowerCase().trim().replace(/[^a-z0-9]/g, '');
          const dateStrClean = dateStr.replace(/-/g, '');
          const gameId = `imported-${normalizedLeague}-${normalizedAway}-${normalizedHome}-${dateStrClean}`;
          gameData['Game ID'] = gameId;
          
          // Add display order to preserve Google Sheet row order for manual games
          gameData['displayOrder'] = displayOrder++;
          
          allManualGames.push(gameData);
          leagueGameCount++;
          console.log(`  ‚úì Added game: ${gameData['Matchup'] || gameData['Home Team']} on ${dateStr} at ${timeStr}`);
        }
        
        if (skippedDateCount > 3) {
          console.log(`  ... and ${skippedDateCount - 3} more games skipped (wrong date)`);
        }
        console.log(`Found ${leagueGameCount} games for ${leagueName} (${skippedDateCount} skipped due to date)`);
    } catch (error) {
      console.error(`Error fetching manual games for ${leagueName}:`, error.message);
    }
  }
  
  return allManualGames;
}




async function fetchRapidApiData(url, headers) {
await new Promise(resolve => setTimeout(resolve, API_REQUEST_DELAY_MS));
const response = await fetch(url, { headers });
if (!response.ok) {
 const errorText = await response.text();
 throw new Error(`HTTP error! ${response.status}: ${errorText} @ ${url}`);
}
return await response.json();
}




// Helper function to compare two game objects (ignoring Last Updated timestamp)
function gamesAreEqual(game1, game2) {
 if (!game1 || !game2) return false;
 
 // Compare key fields that matter
 const fieldsToCompare = [
   'League', 'Sport', 'Home Team', 'Away Team', 'Match Status',
   'Home Score', 'Away Score', 'Channel', 'channel', 'gameDate',
   'Start Time', 'Matchup', 'Featured', 'Stage', 'GameTime',
   'displayClock', 'displayTime', 'period' // Include clock/time fields so live updates aren't skipped
 ];
 
 for (const field of fieldsToCompare) {
   const val1 = game1[field];
   const val2 = game2[field];
   
   // Handle Timestamp objects
   if (val1 && val1.seconds && val2 && val2.seconds) {
     if (val1.seconds !== val2.seconds) return false;
   } else if (val1 !== val2) {
     return false;
   }
 }
 
 return true;
}

// Helper function to fetch rankings from NCAA API
// Returns a map: { normalizedTeamName: rank }
async function fetchNCAARankings(leagueKey) {
  try {
    let apiUrl;
    if (leagueKey === 'NCAAM') {
      apiUrl = 'https://ncaa-api.henrygd.me/rankings/basketball-men/d1/associated-press';
    } else if (leagueKey === 'NCAAW') {
      apiUrl = 'https://ncaa-api.henrygd.me/rankings/basketball-women/d1/associated-press';
    } else if (leagueKey === 'NCAAF') {
      apiUrl = 'https://ncaa-api.henrygd.me/rankings/football/fbs/associated-press';
    } else {
      return {};
    }
    
    const response = await fetch(apiUrl, {
      headers: { 'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36' }
    });
    
    if (!response.ok) {
      console.warn(`[NCAA Rankings] Failed to fetch rankings for ${leagueKey}: HTTP ${response.status}`);
      return {};
    }
    
    const data = await response.json();
    const rankingsMap = {};
    
    if (data && data.data && Array.isArray(data.data)) {
      data.data.forEach(item => {
        const rank = item.RANKING || item.RANK;
        let teamName = item.TEAM || item.SCHOOL || item['SCHOOL (1ST VOTES)'] || '';
        // Remove first-place votes in parentheses (e.g., "Team Name (35)" -> "Team Name")
        if (teamName) {
          teamName = teamName.replace(/\s*\(\d+\)\s*$/, '').trim();
        }
        if (teamName && rank) {
          // Normalize team name for matching (lowercase, trim)
          const normalizedName = teamName.toLowerCase().trim();
          rankingsMap[normalizedName] = parseInt(rank) || null;
        }
      });
    }
    
    return rankingsMap;
  } catch (error) {
    console.error(`[NCAA Rankings] Error fetching rankings for ${leagueKey}:`, error.message);
    return {};
  }
}

// Helper function to normalize team name for ranking lookup
function normalizeTeamNameForRanking(teamName) {
  if (!teamName) return '';
  return teamName.toLowerCase().trim();
}

// Helper function to get ranking for a team
function getTeamRanking(teamName, rankingsMap) {
  if (!teamName || !rankingsMap) return null;
  const normalized = normalizeTeamNameForRanking(teamName);
  return rankingsMap[normalized] || null;
}

async function writeGamesToFirestore(games) {
const db = initializeFirebase();
const gamesRef = db.collection(`artifacts/flashlive-daily-scraper/public/data/sportsGames`);

// CRITICAL: Delete ALL today's games from ESPN/NCAA sources before writing
// NOTE: No cleanup needed - Game IDs are now stable (no time component)
// The merge: true option will update existing games instead of creating duplicates
// This is much more cost-efficient than deleting and rewriting everything

// Get existing games to compare
const existingSnapshot = await gamesRef.get();
const existingGamesMap = new Map();
existingSnapshot.forEach(doc => {
  const data = doc.data();
  const gameId = String(data['Game ID'] || doc.id);
  existingGamesMap.set(gameId, data);
});

const batch = db.batch();
let gameCount = 0;
let skippedCount = 0;
let updatedCount = 0;
let newCount = 0;

for (const game of games) {
 if (!game['Game ID']) {
   console.warn('Skipping Firestore write for game with missing or empty "Game ID":', JSON.stringify(game));
   continue;
 }
 
 const gameId = String(game['Game ID']);
 const docRef = gamesRef.doc(gameId);
 const existingGame = existingGamesMap.get(gameId);
 
 // For live games, always write even if they appear equal (to ensure Firestore listeners trigger)
 // Expand the heuristic to catch cases where the provider doesn't set Match Status but
 // provides a displayClock, Stage, or StageType indicating play has started.
 const rawStatus = String(game['Match Status'] || '').toUpperCase();
 const rawStageType = String(game.StageType || '').toUpperCase();
 const rawStage = String(game.Stage || '').toUpperCase();
 const displayClockVal = (game.displayClock || game.displayTime || game.GameTime || '') + '';
 const hasDisplayClock = displayClockVal && !['0', '0:00', '0.0', 'NULL', ''].includes(displayClockVal.toString().trim().toUpperCase());

 const isLive = (
   rawStatus.includes('IN PROGRESS') ||
   rawStatus.includes('LIVE') ||
   rawStageType.includes('LIVE') ||
   rawStageType.includes('IN PROGRESS') ||
   // Some feeds set Stage to FIRST_HALF/SECOND_HALF or similar
   /FIRST|SECOND|HALF|IN_PROGRESS|ONGOING|PLAY/.test(rawStage) ||
   // If there's a meaningful display clock, treat as live
   hasDisplayClock
 );
 
 // Check if game already exists and is identical
 if (existingGame && gamesAreEqual(existingGame, game) && !isLive) {
   skippedCount++;
   // Log skipped NFL games for debugging
   if (game.Sport === 'American Football' && (game.League?.includes('NFL') || game.League?.includes('NCAAF'))) {
     console.log(`‚è≠Ô∏è  Skipped unchanged NFL game: ${game['Away Team']} vs ${game['Home Team']} - GameTime: ${game.GameTime || 'null'}, displayClock: ${game.displayClock || 'null'}`);
   }
   continue; // Skip writing if game hasn't changed (unless it's live)
 }
 
  batch.set(docRef, game, { merge: true });
  
  // Invalidate today's games JSON cache so it refreshes on next request
  todayGamesCache = null;
  todayGamesCacheTimestamp = null;
  
  // ALSO write to root-level `sportsGames` collection for backwards compatibility
  try {
    const rootDocRef = db.collection('sportsGames').doc(gameId);
    batch.set(rootDocRef, game, { merge: true });
  } catch (err) {
    // If something goes wrong creating the root ref, warn but continue with primary write
    console.warn('Warning: failed to prepare root-level sportsGames write for', gameId, err && err.message);
  }
 gameCount++;
 
 if (existingGame) {
   updatedCount++;
   // Log what changed for NFL games
   if (game.Sport === 'American Football' && (game.League?.includes('NFL') || game.League?.includes('NCAAF'))) {
     const changes = [];
     if (existingGame['Home Score'] !== game['Home Score']) changes.push(`Home Score: ${existingGame['Home Score']} ‚Üí ${game['Home Score']}`);
     if (existingGame['Away Score'] !== game['Away Score']) changes.push(`Away Score: ${existingGame['Away Score']} ‚Üí ${game['Away Score']}`);
     if (existingGame['GameTime'] !== game['GameTime']) changes.push(`GameTime: ${existingGame['GameTime']} ‚Üí ${game['GameTime']}`);
     if (existingGame['displayClock'] !== game['displayClock']) changes.push(`displayClock: ${existingGame['displayClock']} ‚Üí ${game['displayClock']}`);
     if (existingGame['displayTime'] !== game['displayTime']) changes.push(`displayTime: ${existingGame['displayTime']} ‚Üí ${game['displayTime']}`);
     if (existingGame['Stage'] !== game['Stage']) changes.push(`Stage: ${existingGame['Stage']} ‚Üí ${game['Stage']}`);
     if (existingGame['Match Status'] !== game['Match Status']) changes.push(`Match Status: ${existingGame['Match Status']} ‚Üí ${game['Match Status']}`);
     if (changes.length > 0) {
       console.log(`üèà NFL Update: ${game['Away Team']} vs ${game['Home Team']} - ${changes.join(', ')}`);
     } else if (isLive) {
       console.log(`üèà NFL Live (forced write): ${game['Away Team']} vs ${game['Home Team']} - ${game['Match Status']} ${game['Stage']} ${game['GameTime'] || 'null'} displayClock: ${game['displayClock'] || 'null'}`);
     }
   }
 } else {
   newCount++;
 }
 
 // Debug logging for non-soccer games
 if (game.Sport === 'Basketball' || game.Sport === 'American Football' || game.Sport === 'Hockey') {
   console.log(`üìù Writing to Firestore: ${game['Away Team']} vs ${game['Home Team']} (${game.Sport} - ${game.League}) - Status: ${game['Match Status']}, Scores: ${game['Away Score']}-${game['Home Score']}`);
 }
}

try {
 if (gameCount > 0) {
   await batch.commit();
   console.log(`‚úÖ Firestore write: ${gameCount} games (${newCount} new, ${updatedCount} updated, ${skippedCount} unchanged skipped).`);
 } else {
   console.log(`‚úÖ Firestore write: All ${skippedCount} games unchanged, no writes needed.`);
 }
} catch (error) {
 console.error('--- Firestore Batch Commit Failed ---');
 console.error('Error during batch commit:', error);
 if (error.message) console.error('Error Message:', error.message);
 if (error.stack) console.error('Error Stack:', error.stack);
 if (error.code) console.error('Firestore Error Code:', error.code);
 if (error.details) console.error('Firestore Error Details:', error.details);
 throw error;
}
}




// Smart Firestore cleanup: Only delete games that are old (past yesterday) or not in the new import
async function smartUpdateFirestoreCollection(newGames) {
const db = initializeFirebase();
const gamesRef = db.collection(`artifacts/flashlive-daily-scraper/public/data/sportsGames`);

// Get current date range for games we're importing
const nowInMountain = DateTime.now().setZone('America/Denver');
const todayStr = nowInMountain.toISODate();
const tomorrowStr = nowInMountain.plus({ days: 1 }).toISODate();
const yesterdayStr = nowInMountain.minus({ days: 1 }).toISODate();

// Get existing games
const snapshot = await gamesRef.get();
const existingGames = new Map();
snapshot.forEach(doc => {
  const data = doc.data();
  const gameId = String(data['Game ID'] || doc.id);
  existingGames.set(gameId, { doc, data });
});

// Create a set of new game IDs for quick lookup
const newGameIds = new Set(newGames.map(g => String(g['Game ID'] || '')).filter(id => id));

// Find games to delete:
// 1. Games older than yesterday (definitely should be deleted)
// 2. Games not in the new import (were removed from sheets)
const deleteBatch = db.batch();
let deletedCount = 0;
let deletedOldCount = 0;
let deletedRemovedCount = 0;

for (const [gameId, { doc, data }] of existingGames.entries()) {
  const gameDate = data.gameDate || '';
  const isOld = gameDate && gameDate < yesterdayStr;
  const isRemoved = !newGameIds.has(gameId);
  
  if (isOld || isRemoved) {
    deleteBatch.delete(doc.ref);
    deletedCount++;
    if (isOld) deletedOldCount++;
    if (isRemoved) deletedRemovedCount++;
  }
}

if (deletedCount > 0) {
  await deleteBatch.commit();
  console.log(`üßπ Smart cleanup: Deleted ${deletedCount} games (${deletedOldCount} old, ${deletedRemovedCount} removed from sheets).`);
} else {
  console.log(`üßπ Smart cleanup: No games to delete.`);
}
}

// Keep the old function for backward compatibility, but make it use smart update
async function clearFirestoreCollection() {
// For now, we'll use smart update instead of clearing everything
// This will be called with newGames later, but for backward compatibility
// we'll just log that we're skipping the full clear
console.log('‚ö†Ô∏è clearFirestoreCollection called - using smart update instead of full clear');
}




function createNoopRes() {
return {
 status() { return this; },
 send() {},
 json() {}
};
}

// NEW: Import games from Google Sheets to Firestore
async function importGamesFromSheets() {
  const db = initializeFirebase();
  const allGames = [];
  
  // League configurations for all 4 sheets
  const LEAGUE_CONFIGS = {
    // From SHEET_ID
    // ESPN/NCAA API leagues (commented out to prevent duplicates):
    // 'NFL': { sheetName: 'NFL', sheetId: SHEET_ID, fields: { date: 'Date', time: 'Time', away: 'Away Team', home: 'Home Team', channel: 'Channel' }, isSoccer: false },
    // 'NBA': { sheetName: 'NBA', sheetId: SHEET_ID, fields: { date: 'Date', time: 'Time', away: 'Away Team', home: 'Home Team', channel: 'Channel' }, isSoccer: false },
    // 'MLB': { sheetName: 'MLB', sheetId: SHEET_ID, fields: { date: 'Date', time: 'Time', away: 'Away Team', home: 'Home Team', channel: 'Channel' }, isSoccer: false },
    // 'PremierLeague': { sheetName: 'PremierLeague', sheetId: SHEET_ID, fields: { date: 'Date', time: 'Time', home: 'Home Team', away: 'Away Team', channel: 'Channel' }, isSoccer: true },
    // 'MLS': { sheetName: 'MLS', sheetId: SHEET_ID, fields: { date: 'Date', time: 'Time', home: 'Home Team', away: 'Away Team', channel: 'Channel' }, isSoccer: true },
    // 'LaLiga': { sheetName: 'LaLiga', sheetId: SHEET_ID, fields: { date: 'Date', time: 'Time', home: 'Home Team', away: 'Away Team', channel: 'Channel' }, isSoccer: true },
    // 'Bundesliga': { sheetName: 'Bundesliga', sheetId: SHEET_ID, fields: { date: 'Date', time: 'Time', home: 'Home Team', away: 'Away Team', channel: 'Channel' }, isSoccer: true },
    // 'SerieA': { sheetName: 'SerieA', sheetId: SHEET_ID, fields: { date: 'Date', time: 'Time', home: 'Home Team', away: 'Away Team', channel: 'Channel' }, isSoccer: true },
    // 'Ligue1': { sheetName: 'Ligue1', sheetId: SHEET_ID, fields: { date: 'Date', time: 'Time', home: 'Home Team', away: 'Away Team', channel: 'Channel' }, isSoccer: true },
    // 'UEFAChampionsLeague': { sheetName: 'UEFAChampionsLeague', sheetId: SHEET_ID, fields: { date: 'Date', time: 'Time', home: 'Home Team', away: 'Away Team', channel: 'Channel' }, isSoccer: true },
    // 'UEFAEuropaLeague': { sheetName: 'UEFAEuropaLeague', sheetId: SHEET_ID, fields: { date: 'Date', time: 'Time', home: 'Home Team', away: 'Away Team', channel: 'Channel' }, isSoccer: true },
    // 'UEFAConferenceLeague': { sheetName: 'UEFAConferenceLeague', sheetId: SHEET_ID, fields: { date: 'Date', time: 'Time', home: 'Home Team', away: 'Away Team', channel: 'Channel' }, isSoccer: true },
    'CopaLibertadores': { sheetName: 'CopaLibertadores', sheetId: SHEET_ID, fields: { date: 'Date', time: 'Time', home: 'Home Team', away: 'Away Team', channel: 'Channel' }, isSoccer: true },
    'CopaSudamericana': { sheetName: 'CopaSudamericana', sheetId: SHEET_ID, fields: { date: 'Date', time: 'Time', home: 'Home Team', away: 'Away Team', channel: 'Channel' }, isSoccer: true },
    // 'LigaMX': { sheetName: 'LigaMX', sheetId: SHEET_ID, fields: { date: 'Date', time: 'Time', home: 'Home Team', away: 'Away Team', channel: 'Channel' }, isSoccer: true },
    // 'NWSL': { sheetName: 'NWSL', sheetId: SHEET_ID, fields: { date: 'Date', time: 'Time', home: 'Home Team', away: 'Away Team', channel: 'Channel' }, isSoccer: true },
    // 'NCAAF': { sheetName: 'NCAAF', sheetId: SHEET_ID, fields: { date: 'Date', time: 'Time', away: 'Away Team', home: 'Home Team', channel: 'Channel' }, isSoccer: false },
    // 'NHL': { sheetName: 'NHL', sheetId: SHEET_ID, fields: { date: 'Date', time: 'Time', away: 'Away Team', home: 'Home Team', channel: 'Channel' }, isSoccer: false },
    // 'WNBA': { sheetName: 'WNBA', sheetId: SHEET_ID, fields: { date: 'Date', time: 'Time', away: 'Away Team', home: 'Home Team', channel: 'Channel' }, isSoccer: false },
    'NASCARCupSeries': { sheetName: 'NASCARCupSeries', sheetId: SHEET_ID, fields: { date: 'Date', time: 'Time', race: 'Race', location: 'Location', channel: 'Channel' }, isSoccer: false },
    'Tennis': { sheetName: 'Tennis', sheetId: SHEET_ID, fields: { date: 'Date', tour: 'Tour', tournament: 'Tournament', channel: 'Channel' }, isSoccer: false },
    'TrackAndField': { sheetName: 'TrackAndField', sheetId: SHEET_ID, fields: { date: 'Date', meet: 'Meet', channel: 'Channel' }, isSoccer: false },
    // 'EFLChampionship': { sheetName: 'EFLChampionship', sheetId: SHEET_ID, fields: { date: 'Date', time: 'Time', home: 'Home Team', away: 'Away Team', channel: 'Channel' }, isSoccer: true },
    'ArgentinePrimeraDivision': { sheetName: 'ArgentinePrimeraDivision', sheetId: SHEET_ID, fields: { date: 'Date', time: 'Time', home: 'Home Team', away: 'Away Team', channel: 'Channel' }, isSoccer: true },
    // 'Brasileirao': { sheetName: 'Brasileirao', sheetId: SHEET_ID, fields: { date: 'Date', time: 'Time', home: 'Home Team', away: 'Away Team', channel: 'Channel' }, isSoccer: true },
    // From SHEET_ID_2
    // 'BelgianProLeague': { sheetName: 'BelgianProLeague', sheetId: SHEET_ID_2, fields: { date: 'Date', time: 'Time', home: 'Home Team', away: 'Away Team', channel: 'Channel' }, isSoccer: true },
    // 'SuperLig': { sheetName: 'SuperLig', sheetId: SHEET_ID_2, fields: { date: 'Date', time: 'Time', home: 'Home Team', away: 'Away Team', channel: 'Channel' }, isSoccer: true },
    'USLChampionship': { sheetName: 'USLChampionship', sheetId: SHEET_ID_2, fields: { date: 'Date', time: 'Time', home: 'Home Team', away: 'Away Team', channel: 'Channel' }, isSoccer: true },
    'CFL': { sheetName: 'CFL', sheetId: SHEET_ID_2, fields: { date: 'Date', time: 'Time', away: 'Away Team', home: 'Home Team', channel: 'Channel' }, isSoccer: false },
    // 'LigaPortugal': { sheetName: 'LigaPortugal', sheetId: SHEET_ID_2, fields: { date: 'Date', time: 'Time', away: 'Away Team', home: 'Home Team', channel: 'Channel' }, isSoccer: true },
    // 'Eredivisie': { sheetName: 'Eredivisie', sheetId: SHEET_ID_2, fields: { date: 'Date', time: 'Time', away: 'Away Team', home: 'Home Team', channel: 'Channel' }, isSoccer: true },
    // 'ScottishPremiership': { sheetName: 'ScottishPremiership', sheetId: SHEET_ID_2, fields: { date: 'Date', time: 'Time', away: 'Away Team', home: 'Home Team', channel: 'Channel' }, isSoccer: true },
    'EFLCup': { sheetName: 'EFLCup', sheetId: SHEET_ID_2, fields: { date: 'Date', time: 'Time', away: 'Away Team', home: 'Home Team', channel: 'Channel' }, isSoccer: true },
    // 'FACup': { sheetName: 'FACup', sheetId: SHEET_ID_2, fields: { date: 'Date', time: 'Time', away: 'Away Team', home: 'Home Team', channel: 'Channel' }, isSoccer: true },
    // 'DFBPokal': { sheetName: 'DFBPokal', sheetId: SHEET_ID_2, fields: { date: 'Date', time: 'Time', away: 'Away Team', home: 'Home Team', channel: 'Channel' }, isSoccer: true },
    // 'CopaDelRey': { sheetName: 'CopaDelRey', sheetId: SHEET_ID_2, fields: { date: 'Date', time: 'Time', away: 'Away Team', home: 'Home Team', channel: 'Channel' }, isSoccer: true },
    // 'SaudiProLeague': { sheetName: 'SaudiProLeague', sheetId: SHEET_ID_2, fields: { date: 'Date', time: 'Time', home: 'Home Team', away: 'Away Team', channel: 'Channel' }, isSoccer: true },
    'WomensSuperLeague': { sheetName: 'WomensSuperLeague', sheetId: SHEET_ID_2, fields: { date: 'Date', time: 'Time', away: 'Away Team', home: 'Home Team', channel: 'Channel' }, isSoccer: true },
    // From SHEET_ID_3
    // 'NCAAM': { sheetName: 'NCAAM', sheetId: SHEET_ID_3, fields: { date: 'Date', time: 'Time', away: 'Away Team', home: 'Home Team', channel: 'Channel' }, isSoccer: false },
    // 'NCAAW': { sheetName: 'NCAAW', sheetId: SHEET_ID_3, fields: { date: 'Date', time: 'Time', away: 'Away Team', home: 'Home Team', channel: 'Channel' }, isSoccer: false },
    // 'ATP': { sheetName: 'ATP', sheetId: SHEET_ID_3, fields: { date: 'Date', time: 'Time', tournament: 'Tournament', channel: 'Channel' }, isSoccer: false },
    // 'WTA': { sheetName: 'WTA', sheetId: SHEET_ID_3, fields: { date: 'Date', time: 'Time', tournament: 'Tournament', channel: 'Channel' }, isSoccer: false },
    // 'DPWorldTour': { sheetName: 'DPWorldTour', sheetId: SHEET_ID_3, fields: { date: 'Date', time: 'Time', away: 'Away Team', home: 'Home Team', channel: 'Channel' }, isSoccer: false },
    // 'PGATourChampions': { sheetName: 'PGATourChampions', sheetId: SHEET_ID_3, fields: { date: 'Date', time: 'Time', tournament: 'Tournament', channel: 'Channel' }, isSoccer: false },
    'WomensUCL': { sheetName: 'WomensUCL', sheetId: SHEET_ID_3, fields: { date: 'Date', time: 'Time', away: 'Away Team', home: 'Home Team', channel: 'Channel' }, isSoccer: true },
    'CAFQualifiers': { sheetName: 'CAFQualifiers', sheetId: SHEET_ID_3, fields: { date: 'Date', time: 'Time', away: 'Away Team', home: 'Home Team', channel: 'Channel' }, isSoccer: true },
    'AFCQualifiers': { sheetName: 'AFCQualifiers', sheetId: SHEET_ID_3, fields: { date: 'Date', time: 'Time', away: 'Away Team', home: 'Home Team', channel: 'Channel' }, isSoccer: true },
    'AFCAsianCupQualifiers': { sheetName: 'AFCAsianCupQualifiers', sheetId: SHEET_ID_3, fields: { date: 'Date', time: 'Time', away: 'Away Team', home: 'Home Team', channel: 'Channel' }, isSoccer: true },
    'UEFAEuropeanQualifiers': { sheetName: 'UEFAEuropeanQualifiers', sheetId: SHEET_ID_3, fields: { date: 'Date', time: 'Time', away: 'Away Team', home: 'Home Team', channel: 'Channel' }, isSoccer: true },
    'CONCACAFQualifiers': { sheetName: 'CONCACAFQualifiers', sheetId: SHEET_ID_3, fields: { date: 'Date', time: 'Time', away: 'Away Team', home: 'Home Team', channel: 'Channel' }, isSoccer: true },
    'WorldCupU17': { sheetName: 'FIFAU17WorldCup', sheetId: SHEET_ID_3, fields: { date: 'Date', time: 'Time', away: 'Away Team', home: 'Home Team', channel: 'Channel' }, isSoccer: true },
    // 'CoppaItalia': { sheetName: 'CoppaItalia', sheetId: SHEET_ID_3, fields: { date: 'Date', time: 'Time', away: 'Away Team', home: 'Home Team', channel: 'Channel' }, isSoccer: true },
    // 'CoupeDeFrance': { sheetName: 'CoupeDeFrance', sheetId: SHEET_ID_3, fields: { date: 'Date', time: 'Time', away: 'Away Team', home: 'Home Team', channel: 'Channel' }, isSoccer: true },
    'ScottishCup': { sheetName: 'ScottishCup', sheetId: SHEET_ID_3, fields: { date: 'Date', time: 'Time', away: 'Away Team', home: 'Home Team', channel: 'Channel' }, isSoccer: true },
    // From SHEET_ID_4 (treated same as other sheets)
    'MotoGP': { sheetName: 'MotoGP', sheetId: SHEET_ID_4, fields: { date: 'Date', time: 'Time', home: 'Home Team', away: 'Away Team', channel: 'Channel' }, isSoccer: false },
    // 'Boxing': { sheetName: 'Boxing', sheetId: SHEET_ID_4, fields: { date: 'Date', time: 'Time', home: 'Home Team', away: 'Away Team', channel: 'Channel' }, isSoccer: false },
    // 'UFC': { sheetName: 'UFC', sheetId: SHEET_ID_4, fields: { date: 'Date', time: 'Time', home: 'Home Team', away: 'Away Team', channel: 'Channel' }, isSoccer: false },
    // 'PGATour': { sheetName: 'PGATour', sheetId: SHEET_ID_4, fields: { date: 'Date', time: 'Time', home: 'Home Team', away: 'Away Team', channel: 'Channel' }, isSoccer: false },
    // 'LPGATour': { sheetName: 'LPGATour', sheetId: SHEET_ID_4, fields: { date: 'Date', time: 'Time', home: 'Home Team', away: 'Away Team', channel: 'Channel' }, isSoccer: false },
    // 'LIVGolf': { sheetName: 'LIVGolf', sheetId: SHEET_ID_4, fields: { date: 'Date', time: 'Time', home: 'Home Team', away: 'Away Team', channel: 'Channel' }, isSoccer: false },
    'USMNT': { sheetName: 'USMNT', sheetId: SHEET_ID_4, fields: { date: 'Date', time: 'Time', home: 'Home Team', away: 'Away Team', channel: 'Channel' }, isSoccer: true },
    // 'FormulaOne': { sheetName: 'FormulaOne', sheetId: SHEET_ID_4, fields: { date: 'Date', time: 'Time', home: 'Home Team', away: 'Away Team', channel: 'Channel' }, isSoccer: false }
  };
  
  const LEAGUE_TO_SPORT_MAP_FULL = {
    'NFL': 'American Football', 'NCAAF': 'American Football', 'CFL': 'American Football',
    'NBA': 'Basketball', 'NCAAM': 'Basketball', 'NCAAW': 'Basketball', 'WNBA': 'Basketball',
    'MLB': 'Baseball',
    'NHL': 'Hockey',
    'PremierLeague': 'Soccer', 'LaLiga': 'Soccer', 'Bundesliga': 'Soccer', 'SerieA': 'Soccer', 'Ligue1': 'Soccer',
    'MLS': 'Soccer', 'UEFAChampionsLeague': 'Soccer', 'UEFAEuropaLeague': 'Soccer', 'UEFAConferenceLeague': 'Soccer',
    'CopaLibertadores': 'Soccer', 'CopaSudamericana': 'Soccer', 'LigaMX': 'Soccer', 'NWSL': 'Soccer',
    'EFLChampionship': 'Soccer', 'BelgianProLeague': 'Soccer', 'SuperLig': 'Soccer', 'USLChampionship': 'Soccer',
    'LigaPortugal': 'Soccer', 'Eredivisie': 'Soccer', 'ScottishPremiership': 'Soccer', 'EFLCup': 'Soccer',
    'FACup': 'Soccer', 'DFBPokal': 'Soccer', 'CopaDelRey': 'Soccer', 'SaudiProLeague': 'Soccer',
    'WomensSuperLeague': 'Soccer', 'WomensUCL': 'Soccer', 'USMNT': 'Soccer', 'WorldCupU17': 'Soccer', 'CoppaItalia': 'Soccer', 'CoupeDeFrance': 'Soccer', 'ScottishCup': 'Soccer',
    'CAFQualifiers': 'Soccer', 'AFCQualifiers': 'Soccer', 'AFCAsianCupQualifiers': 'Soccer',
    'UEFAEuropeanQualifiers': 'Soccer', 'CONCACAFQualifiers': 'Soccer', 'ArgentinePrimeraDivision': 'Soccer', 'Brasileirao': 'Soccer',
    'MotoGP': 'Motorsport', 'PGATour': 'Golf', 'LPGATour': 'Golf', 'LIVGolf': 'Golf', 'FormulaOne': 'Motorsport',
    'DPWorldTour': 'Golf', 'PGATourChampions': 'Golf',
    'Boxing': 'Boxing', 'UFC': 'Boxing',
    'Tennis': 'Tennis', 'ATP': 'Tennis', 'WTA': 'Tennis',
    'NASCARCupSeries': 'Auto Racing',
    'TrackAndField': 'Track & Field'
  };
  
  const LEAGUE_DISPLAY_NAME_MAP_FULL = {
    'PremierLeague': 'England: Premier League', 'LaLiga': 'Spain: LaLiga', 'Bundesliga': 'Germany: Bundesliga',
    'SerieA': 'Italy: Serie A', 'Ligue1': 'France: Ligue 1', 'MLS': 'USA: MLS',
    'UEFAChampionsLeague': 'UEFA Champions League', 'UEFAEuropaLeague': 'Europa League',
    'UEFAConferenceLeague': 'Conference League', 'LigaMX': 'Mexico: Liga MX',
    'NWSL': 'USA: NWSL Women', 'NFL': 'USA: NFL', 'NCAAF': 'USA: NCAA',
    'NBA': 'USA: NBA', 'NCAAM': 'USA: NCAA', 'NCAAW': 'USA: NCAA Women', 'WNBA': 'USA: WNBA',
    'MLB': 'USA: MLB', 'NHL': 'USA: NHL', 'CFL': 'Canada: CFL',
    'EFLChampionship': 'England: Championship', 'BelgianProLeague': 'Belgium: Jupiler Pro League',
    'SuperLig': 'Turkey: Super Lig', 'USLChampionship': 'USA: USL Championship',
    'LigaPortugal': 'Portugal: Liga Portugal', 'Eredivisie': 'Netherlands: Eredivisie',
    'ScottishPremiership': 'Scotland: Premiership', 'EFLCup': 'England: EFL Cup',
    'FACup': 'England: FA Cup', 'DFBPokal': 'Germany: DFB Pokal', 'CopaDelRey': 'Spain: Copa del Rey', 'CoppaItalia': 'Italy: Coppa Italia', 'CoupeDeFrance': 'France: Coupe de France', 'ScottishCup': 'Scotland: Scottish Cup',
    'CopaLibertadores': 'South America: Copa Libertadores - Play Offs', 'CopaSudamericana': 'South America: Copa Sudamericana',
    'SaudiProLeague': 'Saudi Arabia: Saudi Professional League', 'WomensSuperLeague': 'England: WSL',
    'WomensUCL': 'Europe: Champions League Women - League phase',
    'WorldCupU17': 'World: World Cup U17', 'CAFQualifiers': 'Africa: World Cup - Qualification',
    'AFCQualifiers': 'Asia: World Cup - Qualification', 'AFCAsianCupQualifiers': 'Asia: Asian Cup - Qualification',
    'UEFAEuropeanQualifiers': 'Europe: World Cup - Qualification', 'CONCACAFQualifiers': 'North & Central America: World Cup - Qualification',
    'ArgentinePrimeraDivision': 'Argentina: Torneo Betano - Apertura', 'Brasileirao': 'Brazil: Serie A Betano',
    'MotoGP': 'MotoGP', 'PGATour': 'PGA Tour', 'LPGATour': 'LPGA Tour', 'LIVGolf': 'LIV Golf', 'FormulaOne': 'Formula 1',
    'DPWorldTour': 'DP World Tour', 'PGATourChampions': 'PGA Champions',
    'Boxing': 'Boxing', 'UFC': 'UFC',
    'Tennis': 'Tennis', 'ATP': 'ATP', 'WTA': 'WTA',
    'NASCARCupSeries': 'NASCAR Cup Series',
    'TrackAndField': 'Track & Field'
  };
  
  async function getSheetDataForImport(sheetName, sheetId) {
    try {
      const response = await rateLimitedSheetRequest(() =>
        sheets.spreadsheets.values.get({
          spreadsheetId: sheetId,
          range: `${sheetName}!A:Z`,
          valueRenderOption: 'UNFORMATTED_VALUE'
        })
      );
      return response.data.values || [];
    } catch (error) {
      console.error(`Error reading sheet ${sheetName} from ${sheetId}:`, error.message);
      if (error.message.includes('permission') || error.message.includes('does not have permission')) {
        console.error(`  ‚ö†Ô∏è  PERMISSION ERROR: The service account needs to be granted access to this spreadsheet.`);
        if (serviceAccountEmail) {
          console.error(`  üìß Service account email: ${serviceAccountEmail}`);
          console.error(`  üìù To fix: Share the spreadsheet with this email address:`);
          console.error(`     ${serviceAccountEmail}`);
        } else {
          console.error(`  üìß To fix: Share the spreadsheet with the service account email (check logs above for the email address)`);
        }
        console.error(`  üîó Spreadsheet URL: https://docs.google.com/spreadsheets/d/${sheetId}/edit`);
        console.error(`  üìã Steps:`);
        console.error(`     1. Open the spreadsheet URL above`);
        console.error(`     2. Click the "Share" button (top right)`);
        console.error(`     3. Paste the service account email: ${serviceAccountEmail || '[check logs above]'}`);
        console.error(`     4. Set permission to "Viewer" (read-only is enough)`);
        console.error(`     5. Uncheck "Notify people" (service accounts don't need notifications)`);
        console.error(`     6. Click "Share"`);
      }
      return [];
    }
  }
  
  function parseDateForImport(dateStr) {
    if (!dateStr) return null;
    let date;
    if (typeof dateStr === 'number') {
      const excelEpoch = new Date('1899-12-30T00:00:00Z');
      const daysSinceEpoch = Math.floor(dateStr);
      date = new Date(excelEpoch.getTime() + daysSinceEpoch * 24 * 60 * 60 * 1000);
    } else {
      date = new Date(dateStr);
    }
    if (isNaN(date.getTime())) return null;
    const year = date.getUTCFullYear();
    const month = String(date.getUTCMonth() + 1).padStart(2, '0');
    const day = String(date.getUTCDate()).padStart(2, '0');
    return `${year}-${month}-${day}`;
  }
  
  function parseTimeForImport(timeStr) {
    if (!timeStr) return '';
    if (typeof timeStr === 'string' && timeStr.includes(':')) {
      return timeStr.trim();
    }
    let hours = 0, minutes = 0;
    if (typeof timeStr === 'number') {
      const totalSeconds = Math.floor(timeStr * 86400);
      hours = Math.floor(totalSeconds / 3600);
      minutes = Math.floor((totalSeconds % 3600) / 60);
    } else if (timeStr instanceof Date) {
      // For Date objects from Google Sheets, extract hours/minutes (seconds are always 00)
      hours = timeStr.getUTCHours();
      minutes = timeStr.getUTCMinutes();
    } else {
      return String(timeStr).trim();
    }
    const ampm = hours >= 12 ? 'PM' : 'AM';
    let displayHours = hours % 12;
    if (displayHours === 0) displayHours = 12;
    return `${displayHours}:${String(minutes).padStart(2, '0')} ${ampm}`;
  }
  
  const nowInMountain = DateTime.now().setZone('America/Denver');
  const todayStr = nowInMountain.toISODate();
  const tomorrowStr = nowInMountain.plus({ days: 1 }).toISODate();
  
  console.log(`Importing games from Google Sheets for dates: ${todayStr} and ${tomorrowStr}`);
  
  // ESPN/NCAA API leagues are commented out in LEAGUE_CONFIGS above to prevent duplicates
  for (const [leagueName, config] of Object.entries(LEAGUE_CONFIGS)) {
    try {
      console.log(`\nImporting ${leagueName} from sheet "${config.sheetName}" (Sheet ID: ${config.sheetId})...`);
      
      // Rate limiting is now handled inside getSheetDataForImport via rateLimitedSheetRequest
      const data = await getSheetDataForImport(config.sheetName, config.sheetId);
      
      if (data.length === 0) {
        console.log(`  No data found for ${leagueName}`);
        continue;
      }
      
      const headers = data[0];
      const dataRows = data.slice(1);
      
      console.log(`  Headers found: ${headers.join(', ')}`);
      console.log(`  Total data rows: ${dataRows.length}`);
      
      // Find column indices for each field
      const fieldIndices = {};
      Object.entries(config.fields).forEach(([key, fieldName]) => {
        const index = headers.findIndex(header => 
          header && header.toLowerCase().includes(fieldName.toLowerCase())
        );
        if (index !== -1) {
          fieldIndices[key] = index;
          console.log(`  ‚úì Found field "${fieldName}" at column index ${index}`);
        } else {
          console.warn(`  ‚úó Field "${fieldName}" not found in headers for ${leagueName}`);
        }
      });
      
      // Validate required fields exist
      if (fieldIndices.date === undefined) {
        console.error(`  ‚úó CRITICAL: Date field not found for ${leagueName}. Cannot import games.`);
        continue;
      }
      
      // Get all column indices to preserve all fields from sheet
      const allFieldIndices = {};
      headers.forEach((header, index) => {
        if (header && header.trim()) {
          allFieldIndices[header.trim()] = index;
        }
      });

      const featuredColumnIndex = headers.findIndex(header => header && header.trim().toLowerCase() === 'featured');
      if (featuredColumnIndex === -1) {
        console.log(`  ‚ÑπÔ∏è  No "Featured" column found for ${leagueName}`);
      } else {
        console.log(`  ‚úì Found "Featured" column at index ${featuredColumnIndex}`);
      }
      
      let gameIdCounter = 1;
      let leagueGameCount = 0;
      let displayOrder = 0; // Preserve Google Sheets row order - increment for EVERY row
      let skippedEmptyRows = 0;
      let skippedNoDate = 0;
      let skippedDateFilter = 0;
      let skippedInvalidTime = 0;
      
      // Special handling for Boxing and UFC: collect all games first, then group by time
      const isBoxingOrUFC = leagueName === 'Boxing' || leagueName === 'UFC';
      const tempGames = [];
      
      for (let i = 0; i < dataRows.length; i++) {
        const row = dataRows[i];
        
        // Increment displayOrder for every row to preserve exact Google Sheets order
        const currentDisplayOrder = displayOrder++;
        
        if (row.every(cell => cell === null || cell === undefined || cell === '' || (typeof cell === 'string' && cell.trim() === ''))) {
          skippedEmptyRows++;
          continue;
        }
        
        const rawDate = row[fieldIndices.date];
        const dateStr = rawDate ? parseDateForImport(rawDate) : null;
        if (!dateStr) {
          skippedNoDate++;
          if (i < 5) { // Log first few skipped rows for debugging
            console.log(`  Row ${i + 2} skipped: Invalid date (raw: ${rawDate})`);
          }
          continue;
        }
        
        // Only include games for today or tomorrow
        if (dateStr !== todayStr && dateStr !== tomorrowStr) {
          skippedDateFilter++;
          if (i < 5) { // Log first few skipped rows for debugging
            console.log(`  Row ${i + 2} skipped: Date ${dateStr} not in range (today: ${todayStr}, tomorrow: ${tomorrowStr})`);
          }
          continue;
        }
        
        const rawTime = row[fieldIndices.time];
        const timeStr = rawTime ? parseTimeForImport(rawTime) : '';
        // Get channel from cell - if blank, leave it as empty string (don't propagate from previous rows)
        const channel = row[fieldIndices.channel] ? String(row[fieldIndices.channel]).trim() : '';
        
        const startTime = timeStr ? createFirestoreTimestamp(dateStr, timeStr) : createFirestoreTimestamp(dateStr, '11:59 PM');
        if (!startTime) {
          skippedInvalidTime++;
          if (i < 5) { // Log first few skipped rows for debugging
            console.log(`  Row ${i + 2} skipped: Invalid timestamp (date: ${dateStr}, time: ${timeStr})`);
          }
          continue;
        }
        
        const sport = LEAGUE_TO_SPORT_MAP_FULL[leagueName] || 'Other';
        const leagueDisplayName = LEAGUE_DISPLAY_NAME_MAP_FULL[leagueName] || leagueName;
        
        const gameData = {
          'Sport': sport,
          'League': leagueDisplayName,
          'Start Time': startTime,
          'gameDate': dateStr,
          'Match Status': 'SCHEDULED',
          'Last Updated': admin.firestore.FieldValue.serverTimestamp(),
          'originalRowIndex': i, // Preserve original row index for sorting
          'hasChannel': channel && channel.trim() !== '' // Track if this row has channel data
        };
        
        // Only add channel fields if channel has a value (don't write blank channels to Firestore)
        if (channel && channel.trim() !== '') {
          gameData['Channel'] = channel;
          gameData['channel'] = channel;
        }

        if (featuredColumnIndex !== -1) {
          const featuredValue = row[featuredColumnIndex];
          if (featuredValue !== null && featuredValue !== undefined && featuredValue !== '') {
            const featuredId = String(featuredValue).trim();
            if (featuredId) {
              gameData['Featured'] = featuredId;
            }
          }
        }
        
        // Handle all leagues with home/away structure
        if (fieldIndices.home !== undefined && fieldIndices.away !== undefined) {
          const homeTeam = row[fieldIndices.home] ? String(row[fieldIndices.home]).trim() : '';
          const awayTeam = row[fieldIndices.away] ? String(row[fieldIndices.away]).trim() : '';
          
          // For soccer leagues, home is first line, away is second line
          // For non-soccer leagues (Boxing, UFC, etc.), away is first column, home is second column
          if (config.isSoccer) {
            gameData['Home Team'] = homeTeam;
            gameData['Away Team'] = awayTeam;
          } else {
            gameData['Away Team'] = awayTeam;
            gameData['Home Team'] = homeTeam;
          }
          gameData['Matchup'] = awayTeam && homeTeam ? `${awayTeam} vs ${homeTeam}` : (homeTeam || awayTeam);
        }
        
        // Preserve all other fields from the sheet
        Object.entries(allFieldIndices).forEach(([fieldName, index]) => {
          if (row[index] !== null && row[index] !== undefined && row[index] !== '') {
            const fieldValue = String(row[index]).trim();
            if (fieldValue && !gameData.hasOwnProperty(fieldName)) {
              gameData[fieldName] = fieldValue;
            }
          }
        });
        
        // Generate deterministic Game ID based on league, teams, and date (NOT time - same game should have same ID)
        const homeTeamForId = gameData['Home Team'] || '';
        const awayTeamForId = gameData['Away Team'] || '';
        const normalizedHome = (homeTeamForId || '').toLowerCase().trim().replace(/[^a-z0-9]/g, '');
        const normalizedAway = (awayTeamForId || '').toLowerCase().trim().replace(/[^a-z0-9]/g, '');
        const normalizedLeague = leagueName.toLowerCase().trim().replace(/[^a-z0-9]/g, '');
        const dateStrClean = dateStr.replace(/-/g, '');
        const gameId = `imported-${normalizedLeague}-${normalizedAway}-${normalizedHome}-${dateStrClean}`;
        gameData['Game ID'] = gameId;
        gameData['displayOrder'] = currentDisplayOrder; // Use the displayOrder captured at the start of the loop
        
        if (isBoxingOrUFC) {
          tempGames.push(gameData);
        } else {
          allGames.push(gameData);
          leagueGameCount++;
        }
      }
      
      // Special processing for Boxing/UFC: group by time, order with channel row first
      if (isBoxingOrUFC && tempGames.length > 0) {
        // Group games by time (using Start Time timestamp for grouping)
        const gamesByTime = {};
        tempGames.forEach(game => {
          const timeKey = game['Start Time'].toMillis ? game['Start Time'].toMillis() : game['Start Time'].seconds;
          if (!gamesByTime[timeKey]) {
            gamesByTime[timeKey] = [];
          }
          gamesByTime[timeKey].push(game);
        });
        
        // Sort time groups chronologically
        const sortedTimeKeys = Object.keys(gamesByTime).sort((a, b) => parseInt(a) - parseInt(b));
        
        // Process each time group
        sortedTimeKeys.forEach(timeKey => {
          // Sort time group by displayOrder to preserve exact sheet order
          const timeGroup = gamesByTime[timeKey].sort((a, b) => {
            const orderA = a.displayOrder !== undefined ? a.displayOrder : 0;
            const orderB = b.displayOrder !== undefined ? b.displayOrder : 0;
            return orderA - orderB;
          });
          
          // Find the row with channel data (if any) - use original order
          const channelRowIndex = timeGroup.findIndex(game => game.hasChannel);
          
          if (channelRowIndex !== -1) {
            // Channel row exists - mark it as main item, others as sub-items
            const channelRow = timeGroup[channelRowIndex];
            channelRow['isSubItem'] = false; // Main item (white text, shows time)
            
            // Mark all other rows in this time group as sub-items
            timeGroup.forEach((game, idx) => {
              if (idx !== channelRowIndex) {
                game['isSubItem'] = true; // Sub-item (gray text, no time)
              }
            });
            
            // Order: channel row first, then others in original sheet order (already sorted above)
            const orderedGroup = [channelRow];
            timeGroup.forEach((game, idx) => {
              if (idx !== channelRowIndex) {
                orderedGroup.push(game);
              }
            });
            
            // Add to allGames in the correct order with sortOrder field
            orderedGroup.forEach((game, groupIdx) => {
              // Create a sortOrder that combines time (milliseconds) with position within time group
              // This ensures chronological order, with channel row first, then sheet order
              const timeMs = game['Start Time'].toMillis ? game['Start Time'].toMillis() : (game['Start Time'].seconds * 1000);
              // Use groupIdx * 1000 to preserve order within same time (channel row = 0, others = 1000, 2000, etc.)
              game['sortOrder'] = timeMs + (groupIdx * 1000);
              allGames.push(game);
              leagueGameCount++;
            });
          } else {
            // No channel row - all are main items (first one shows time, others don't)
            // Keep in original sheet order
            timeGroup.forEach((game, idx) => {
              game['isSubItem'] = idx === 0 ? false : true; // First is main, rest are sub-items
              // Create sortOrder for games without channel row
              const timeMs = game['Start Time'].toMillis ? game['Start Time'].toMillis() : (game['Start Time'].seconds * 1000);
              game['sortOrder'] = timeMs + (idx * 1000); // First = 0, others = 1000, 2000, etc.
              allGames.push(game);
              leagueGameCount++;
            });
          }
        });
      }
      
      console.log(`  ‚úì Imported ${leagueGameCount} games from ${leagueName}`);
      if (skippedEmptyRows > 0) console.log(`    - Skipped ${skippedEmptyRows} empty rows`);
      if (skippedNoDate > 0) console.log(`    - Skipped ${skippedNoDate} rows with invalid/missing dates`);
      if (skippedDateFilter > 0) console.log(`    - Skipped ${skippedDateFilter} rows outside date range (today/tomorrow only)`);
      if (skippedInvalidTime > 0) console.log(`    - Skipped ${skippedInvalidTime} rows with invalid timestamps`);
    } catch (error) {
      console.error(`  ‚úó Error importing ${leagueName}:`, error.message);
    }
  }
  
  console.log(`\nTotal games imported: ${allGames.length}`);
  return allGames;
}




// =================================================================
// ORIGINAL FUNCTIONS (RETAINED)
// =================================================================
const initialScrapeAndStartPollingHandler = async (req, res) => {
try {
 console.log('--- initialScrapeAndStartPollingHandler started. ---');
  
  // --- Step 1: Move yesterday's games to yesterdayScores ---
 console.log('Moving yesterday\'s games to yesterdayScores...');
 const db = initializeFirebase();
 const gamesRef = db.collection(`artifacts/flashlive-daily-scraper/public/data/sportsGames`);
 const yesterdayScoresRef = db.collection(`artifacts/flashlive-daily-scraper/public/data/yesterdayScores`);
 const snapshot = await gamesRef.get();
 let movedCount = 0;
  for (const doc of snapshot.docs) {
   const data = doc.data();
   try {
     await yesterdayScoresRef.doc(doc.id).set(data);
     movedCount++;
   } catch (err) {
     console.error(`Error moving game ${doc.id} to yesterdayScores:`, err);
   }
 }
 console.log(`‚úÖ Moved ${movedCount} games to yesterdayScores.`);
   // Smart cleanup will happen after we get the new games list




 // --- Step 2: Populate with New Day's Games from Google Sheets ---
 console.log('Importing new games from Google Sheets...');
 await authenticateGoogleSheets();

const nowInMountain = DateTime.now().setZone('America/Denver');
const todayStr = nowInMountain.toISODate();
const tomorrowStr = nowInMountain.plus({ days: 1 }).toISODate();

// TEMPORARILY DISABLED: FlashLive API fetching - using Google Sheets import instead
/*
const rapidApiHeaders = {
   'X-RapidAPI-Key': RAPIDAPI_KEY,
   'X-RapidAPI-Host': RAPIDAPI_HOST
 };
// For API calls, use UTC dates to match FlashLive API expectations
const nowUTC = DateTime.now().setZone('utc');
const todayUTC = nowUTC.toISODate();
const tomorrowUTC = nowUTC.plus({ days: 1 }).toISODate();
 const allGames = [];
  // Specific game IDs to always fetch (workaround for API timezone issues)
 const FORCE_FETCH_GAME_IDS = [
   // Add game IDs here that API might miss due to timezone issues
   // Example: 'tKKG0rZX' // Inter Miami vs Nashville
 ];




 for (const sport of sportsToFetch) {
   // Query both today and tomorrow to catch all games that start today in EST
   const datesToQuery = [todayUTC, tomorrowUTC];
   
   for (const dateStr of datesToQuery) {
     const url = `https://${RAPIDAPI_HOST}/v1/events/list?sport_slug=${sport.slug}&date=${dateStr}&locale=en_INT&sport_id=${sport.id}&timezone=-4&indent_days=0`;
     
     try {
       const data = await fetchRapidApiData(url, rapidApiHeaders);
       const tournaments = data.DATA || [];

       for (const tour of tournaments) {
         const events = tour.EVENTS || [];
         for (const event of events) {
           // Normalize Match Status like NCAA API does
           const stageTypeNorm = (event.STAGE_TYPE || '').toUpperCase();
           const stageNorm = (event.STAGE || '').toUpperCase();
           const homeScoreNum = Number(event.HOME_SCORE_CURRENT || 0);
           const awayScoreNum = Number(event.AWAY_SCORE_CURRENT || 0);
           const hasClock = event.GAME_TIME && event.GAME_TIME !== '0:00' && event.GAME_TIME !== '0.0';
           
           let matchStatus = 'SCHEDULED';
           if (stageTypeNorm === 'FINAL' || stageNorm === 'FINAL' || stageTypeNorm.includes('FINAL')) {
             matchStatus = 'FINAL';
           } else if (
             stageTypeNorm.includes('LIVE') ||
             stageTypeNorm.includes('IN_PROGRESS') ||
             stageTypeNorm.includes('IN PROGRESS') ||
             stageTypeNorm.includes('OVERTIME') ||
             stageTypeNorm.includes('OT') ||
             stageNorm.includes('2ND HALF') ||
             stageNorm.includes('2ND QUARTER') ||
             hasClock ||
             homeScoreNum > 0 ||
             awayScoreNum > 0
           ) {
             if (!stageTypeNorm.includes('FINAL') && !stageNorm.includes('FINAL')) {
               matchStatus = 'IN PROGRESS';
             }
           } else if (stageNorm.includes('HALF') || stageTypeNorm.includes('HALF')) {
             matchStatus = 'HALFTIME';
           }
           
          // Validate and normalize GameTime for American Football
          let gameTime = event.GAME_TIME || '';
          const leagueName = tour.NAME || '';
          const isAmericanFootball = sport.name === 'American Football' || 
                                     leagueName.includes('NFL') || 
                                     leagueName.includes('NCAAF');
          
          if (gameTime && isAmericanFootball) {
            // Check if GameTime is invalid (e.g., "20:00" for quarters which should be max 15:00)
            if (gameTime.includes(':')) {
              const [minutes, seconds] = gameTime.split(':').map(Number);
              // If minutes > 15, it's likely halftime or invalid - check Stage
              const stage = (event.STAGE || '').toUpperCase();
              if (minutes > 15 || (minutes === 15 && seconds > 0)) {
                if (stage.includes('HALF') || matchStatus.includes('HALF')) {
                  // It's halftime - don't set GameTime, let Stage handle it
                  gameTime = '';
                } else {
                  // Invalid time, clamp to 15:00 max
                  gameTime = '15:00';
                }
              }
            }
          }
          
          const game = {
            'Sport': sport.name,
            'Game ID': event.EVENT_ID,
            'League': tour.NAME,
            'Matchup': `${event.HOME_NAME} vs ${event.AWAY_NAME}`,
            'Start Time': admin.firestore.Timestamp.fromMillis(event.START_TIME * 1000),
            'Home Team': event.HOME_NAME,
            'Away Team': event.AWAY_NAME,
            'Home Score': event.HOME_SCORE_CURRENT || '',
            'Away Score': event.AWAY_SCORE_CURRENT || '',
            'Status': event.STAGE || '',
            'Current Lap': event.RACE_RESULTS_LAP_DISTANCE || '',
            'Match Status': matchStatus,
            'Stage': event.STAGE || '',
            'GameTime': gameTime,
            'StageStartTime': event.STAGE_START_TIME || '',
            'StartTime': event.START_TIME || '',
           'StageType': event.STAGE_TYPE || '',
           'Last Updated': new Date().toISOString(),
           'gameDate': DateTime.fromMillis(event.START_TIME * 1000).setZone('America/New_York').toISODate()
          };
          allGames.push(game);
         }
       }
     } catch (err) {
       console.error(`Error fetching ${sport.name} for ${dateStr}: ${err.message}`);
     }
   }
 }
  // TEMPORARILY DISABLED: Formula 1 deduplication - F1 is now handled via manual entry
  // Deduplicate Formula 1 races - keep only one entry per race
  /*
 const f1RaceMap = new Map();
 const nonF1Games = [];
  allGames.forEach(game => {
   if (game.Sport === 'Motorsport' && game.League && game.League.includes('Formula 1')) {
     // For F1, use Grand Prix name as unique key (not session type)
     const leagueParts = game.League.split(':');
     const eventName = leagueParts[1] ? leagueParts[1].trim() : '';
     const sessionParts = eventName.split(' - ');
     const grandPrixName = (sessionParts[0] || '').replace('Grand Prix', 'GP');
     const sessionType = (sessionParts[1] || '').trim();
     const raceKey = `${grandPrixName}|${sessionType || 'Session'}`; // Unique key per GP + session type
     if (!f1RaceMap.has(raceKey)) {
       // Extract event name and session type from league string
       // "Formula 1: Mexican Grand Prix - Race" -> grandPrixName: "Mexican Grand Prix", sessionType: "Race"
       const leagueParts = game.League.split(':');
       const eventName = leagueParts[1] ? leagueParts[1].trim() : '';
       const sessionParts = eventName.split(' - ');
       const grandPrixName = (sessionParts[0] || '').replace('Grand Prix', 'GP');
       const sessionType = sessionParts[1] || '';
      
       // Create a synthetic Game ID based on league + start time (to avoid driver-specific IDs)
       const sanitizedSessionType = sessionType ? sessionType.replace(/\s+/g, '_') : 'Session';
       const syntheticGameId = `F1_${game.StartTime}_${grandPrixName.replace(/\s+/g, '_')}_${sanitizedSessionType}`;
      
       game['Game ID'] = syntheticGameId;
       game.Matchup = `${grandPrixName}\n${sessionType}`;
       game['Home Team'] = sessionType;
       game['Away Team'] = grandPrixName;
       // Put live lap data in start time column (where LIVE appears)
       if (game.Score && game.Score.includes('Lap')) {
         game['Start Time'] = game.Score; // Move lap data to start time column
         game.Score = ''; // Clear the scores column
       }
       f1RaceMap.set(raceKey, game);
     }
   } else {
     nonF1Games.push(game);
   }
 });
  // Combine deduplicated F1 races with other games
 const deduplicatedGames = [...Array.from(f1RaceMap.values()), ...nonF1Games];
 console.log(`Deduplicated ${allGames.length} games to ${deduplicatedGames.length} (removed ${allGames.length - deduplicatedGames.length} duplicate F1 driver entries)`);
  // Replace allGames with deduplicated version
 allGames.length = 0;
 allGames.push(...deduplicatedGames);
  */
  /*
  // Fetch specific games by ID (workaround for API timezone issues)
 if (FORCE_FETCH_GAME_IDS.length > 0) {
   console.log(`Fetching ${FORCE_FETCH_GAME_IDS.length} specific game(s) by ID...`);
   for (const gameId of FORCE_FETCH_GAME_IDS) {
     try {
       const url = `https://${RAPIDAPI_HOST}/v1/event/detail?event_id=${gameId}&locale=en_INT`;
       const data = await fetchRapidApiData(url, rapidApiHeaders);
      
       if (data && data.EVENT) {
         const event = data.EVENT;
         // Normalize Match Status like NCAA API does
         const stageTypeNorm = (event.STAGE_TYPE || '').toUpperCase();
         const stageNorm = (event.STAGE || '').toUpperCase();
         const homeScoreNum = Number(event.HOME_SCORE_CURRENT || 0);
         const awayScoreNum = Number(event.AWAY_SCORE_CURRENT || 0);
         const hasClock = event.GAME_TIME && event.GAME_TIME !== '0:00' && event.GAME_TIME !== '0.0';
         
         let matchStatus = 'SCHEDULED';
         if (stageTypeNorm === 'FINAL' || stageNorm === 'FINAL' || stageTypeNorm.includes('FINAL')) {
           matchStatus = 'FINAL';
         } else if (
           stageTypeNorm.includes('LIVE') ||
           stageTypeNorm.includes('IN_PROGRESS') ||
           stageTypeNorm.includes('IN PROGRESS') ||
           stageTypeNorm.includes('OVERTIME') ||
           stageTypeNorm.includes('OT') ||
           stageNorm.includes('2ND HALF') ||
           stageNorm.includes('2ND QUARTER') ||
           hasClock ||
           homeScoreNum > 0 ||
           awayScoreNum > 0
         ) {
           if (!stageTypeNorm.includes('FINAL') && !stageNorm.includes('FINAL')) {
             matchStatus = 'IN PROGRESS';
           }
         } else if (stageNorm.includes('HALF') || stageTypeNorm.includes('HALF')) {
           matchStatus = 'HALFTIME';
         }
         
        // Validate and normalize GameTime for American Football
        let gameTime = event.GAME_TIME || '';
        const leagueName = event.TOURNAMENT_NAME || event.LEAGUE_NAME || '';
        const sportName = event.SPORT_NAME || '';
        const isAmericanFootball = sportName === 'American Football' || 
                                   leagueName.includes('NFL') || 
                                   leagueName.includes('NCAAF');
        
        if (gameTime && isAmericanFootball) {
          // Check if GameTime is invalid (e.g., "20:00" for quarters which should be max 15:00)
          if (gameTime.includes(':')) {
            const [minutes, seconds] = gameTime.split(':').map(Number);
            // If minutes > 15, it's likely halftime or invalid - check Stage
            const stage = (event.STAGE || '').toUpperCase();
            if (minutes > 15 || (minutes === 15 && seconds > 0)) {
              if (stage.includes('HALF') || matchStatus.includes('HALF')) {
                // It's halftime - don't set GameTime, let Stage handle it
                gameTime = '';
              } else {
                // Invalid time, clamp to 15:00 max
                gameTime = '15:00';
              }
            }
          }
        }
        
        const game = {
          'Sport': sportName,
          'Game ID': event.EVENT_ID,
          'League': leagueName || 'Unknown',
          'Matchup': `${event.HOME_NAME} vs ${event.AWAY_NAME}`,
          'Start Time': admin.firestore.Timestamp.fromMillis(event.START_TIME * 1000),
          'Home Team': event.HOME_NAME,
          'Away Team': event.AWAY_NAME,
          'Home Score': event.HOME_SCORE_CURRENT || '',
          'Away Score': event.AWAY_SCORE_CURRENT || '',
          'Status': event.STAGE || '',
          'Current Lap': event.RACE_RESULTS_LAP_DISTANCE || '',
          'Match Status': matchStatus,
          'Stage': event.STAGE || '',
          'GameTime': gameTime,
          'StageStartTime': event.STAGE_START_TIME || '',
          'StartTime': event.START_TIME || '',
          'StageType': event.STAGE_TYPE || '',
          'Last Updated': new Date().toISOString(),
          'gameDate': DateTime.fromMillis(event.START_TIME * 1000).setZone('America/Denver').toISODate()
        };
        
         // Only add if not already in allGames
         if (!allGames.find(g => g['Game ID'] === gameId)) {
           allGames.push(game);
           console.log(`  ‚úÖ Added game ${gameId}: ${event.HOME_NAME} vs ${event.AWAY_NAME}`);
         } else {
           console.log(`  ‚è≠Ô∏è  Game ${gameId} already fetched`);
         }
       }
     } catch (err) {
       console.error(`  ‚ùå Error fetching game ${gameId}: ${err.message}`);
     }
   }
 }
 console.log(`Fetched ${allGames.length} games from RapidAPI.`);
*/

// Import games from all 4 Google Sheets
const allGames = await importGamesFromSheets();

// Smart cleanup: Delete old games and games removed from sheets
console.log('Performing smart Firestore cleanup...');
await smartUpdateFirestoreCollection(allGames);

// Write all imported games directly to Firestore (only writes changed/new games)
console.log(`Writing ${allGames.length} games to Firestore...`);
await writeGamesToFirestore(allGames);
console.log(`Successfully completed Firestore write: ${allGames.length} games imported from Google Sheets.`);




 if (res) {
   res.status(200).send(`Imported ${allGames.length} games from Google Sheets to Firestore.`);
 }
} catch (err) {
 console.error('--- initialScrapeAndStartPollingHandler FAILED ---', err);
 if (res) res.status(500).send('Scrape failed.');
}
};








const pollLiveGamesHandler = async (req, res) => {
try {
 console.log('--- pollLiveGamesHandler started. ---');




 const db = initializeFirebase();
 const gamesRef = db.collection(`artifacts/flashlive-daily-scraper/public/data/sportsGames`);
const nowInMountain = DateTime.now().setZone('America/Denver');
const todayStr = nowInMountain.toISODate();
 console.log(`[Backend] Current Mountain Time Date (todayStr): ${todayStr}`);




 const snapshot = await gamesRef.get();
 const deleteBatch = db.batch();
 let deleteCount = 0;




snapshot.forEach(doc => {
  const data = doc.data();
  const matchStatus = (data['Match Status'] || '').toUpperCase();
  const isLive = matchStatus.includes('IN PROGRESS') || matchStatus.includes('LIVE') || matchStatus === 'LIVE';
   // Only delete games that are from a different date AND not live
  if (data.gameDate !== todayStr && !isLive) {
    deleteBatch.delete(doc.ref);
    deleteCount++;
  }
});




 if (deleteCount > 0) {
   await deleteBatch.commit();
   console.log(`üßπ Deleted ${deleteCount} old games from Firestore.`);
 } else {
   console.log('‚úÖ No old games to delete.');
 }




 const rapidApiHeaders = {
   'X-RapidAPI-Key': RAPIDAPI_KEY,
   'X-RapidAPI-Host': RAPIDAPI_HOST
 };




 const allGames = [];
 const tomorrowStr = nowInMountain.plus({ days: 1 }).toISODate();
  // For API calls, use UTC dates to match FlashLive API expectations
 const nowUTC = DateTime.now().setZone('utc');
 const todayUTC = nowUTC.toISODate();
 const tomorrowUTC = nowUTC.plus({ days: 1 }).toISODate();
  for (const sport of sportsToFetch) {
   // Query both today and tomorrow to catch all games that start today in EST
   const datesToQuery = [todayUTC, tomorrowUTC];
  
   for (const dateStr of datesToQuery) {
     const url = `https://${RAPIDAPI_HOST}/v1/events/list?sport_slug=${sport.slug}&date=${dateStr}&locale=en_INT&sport_id=${sport.id}&timezone=-4&indent_days=0`;
     try {
       const data = await fetchRapidApiData(url, rapidApiHeaders);
       const tournaments = data.DATA || [];
       for (const tour of tournaments) {
         for (const event of tour.EVENTS || []) {
           // Normalize Match Status like NCAA API does
           const stageTypeNorm = (event.STAGE_TYPE || '').toUpperCase();
           const stageNorm = (event.STAGE || '').toUpperCase();
           const homeScoreNum = Number(event.HOME_SCORE_CURRENT || 0);
           const awayScoreNum = Number(event.AWAY_SCORE_CURRENT || 0);
           const hasClock = event.GAME_TIME && event.GAME_TIME !== '0:00' && event.GAME_TIME !== '0.0';
           
           let matchStatus = 'SCHEDULED';
           if (stageTypeNorm === 'FINAL' || stageNorm === 'FINAL' || stageTypeNorm.includes('FINAL')) {
             matchStatus = 'FINAL';
           } else if (
             stageTypeNorm.includes('LIVE') ||
             stageTypeNorm.includes('IN_PROGRESS') ||
             stageTypeNorm.includes('IN PROGRESS') ||
             stageTypeNorm.includes('OVERTIME') ||
             stageTypeNorm.includes('OT') ||
             stageNorm.includes('2ND HALF') ||
             stageNorm.includes('2ND QUARTER') ||
             hasClock ||
             homeScoreNum > 0 ||
             awayScoreNum > 0
           ) {
             if (!stageTypeNorm.includes('FINAL') && !stageNorm.includes('FINAL')) {
               matchStatus = 'IN PROGRESS';
             }
           } else if (stageNorm.includes('HALF') || stageTypeNorm.includes('HALF')) {
             matchStatus = 'HALFTIME';
           }
           
          allGames.push({
            'Sport': sport.name,
            'Game ID': event.EVENT_ID,
            'League': tour.NAME,
            'Matchup': `${event.HOME_NAME || ''} vs ${event.AWAY_NAME || ''}`,
            'Start Time': admin.firestore.Timestamp.fromMillis(event.START_TIME * 1000),
            'Home Team': event.HOME_NAME || '',
            'Away Team': event.AWAY_NAME || '',
            'Home Score': event.HOME_SCORE_CURRENT || '',
            'Away Score': event.AWAY_SCORE_CURRENT || '',
            'Status': event.STAGE || '',
            'Match Status': matchStatus,
            'Current Lap': event.RACE_RESULTS_LAP_DISTANCE || '',
            'Stage': event.STAGE || '',
            'GameTime': event.GAME_TIME || '',
           'StageStartTime': event.STAGE_START_TIME || '',
           'StartTime': event.START_TIME || '',
           'StageType': event.STAGE_TYPE || '',
           'Last Updated': new Date().toISOString(),
           'gameDate': DateTime.fromMillis(event.START_TIME * 1000).setZone('America/New_York').toISODate()
         });
        }
      }
    } catch (err) {
      console.error(`Error fetching ${sport.name} for ${dateStr}: ${err.message}`);
    }
  }
}
console.log(`Fetched ${allGames.length} games from RapidAPI.`);

 // TEMPORARILY DISABLED: Formula 1 deduplication - F1 is now handled via manual entry
 // Deduplicate Formula 1 races - keep only one entry per race
 /*
 const f1RaceMapPoll = new Map();
 const nonF1GamesPoll = [];
  allGames.forEach(game => {
   if (game.Sport === 'Motorsport' && game.League && game.League.includes('Formula 1')) {
     // For F1, use Grand Prix name as unique key (not session type)
     const leagueParts = game.League.split(':');
     const eventName = leagueParts[1] ? leagueParts[1].trim() : '';
     const sessionParts = eventName.split(' - ');
     const grandPrixName = (sessionParts[0] || '').replace('Grand Prix', 'GP');
     const sessionType = (sessionParts[1] || '').trim();
     const raceKey = `${grandPrixName}|${sessionType || 'Session'}`; // Unique key per GP + session type
     if (!f1RaceMapPoll.has(raceKey)) {
       // Extract event name and session type from league string
       // "Formula 1: Mexican Grand Prix - Race" -> grandPrixName: "Mexican Grand Prix", sessionType: "Race"
       const leagueParts = game.League.split(':');
       const eventName = leagueParts[1] ? leagueParts[1].trim() : '';
       const sessionParts = eventName.split(' - ');
       const grandPrixName = (sessionParts[0] || '').replace('Grand Prix', 'GP');
       const sessionType = sessionParts[1] || '';
      
       // Create a synthetic Game ID based on league + start time (to avoid driver-specific IDs)
       const sanitizedSessionType = sessionType ? sessionType.replace(/\s+/g, '_') : 'Session';
       const syntheticGameId = `F1_${game.StartTime}_${grandPrixName.replace(/\s+/g, '_')}_${sanitizedSessionType}`;
      
       game['Game ID'] = syntheticGameId;
       game.Matchup = `${grandPrixName}\n${sessionType}`;
       game['Home Team'] = sessionType;
       game['Away Team'] = grandPrixName;
       // Put live lap data in start time column (where LIVE appears)
       if (game.Score && game.Score.includes('Lap')) {
         game['Start Time'] = game.Score; // Move lap data to start time column
         game.Score = ''; // Clear the scores column
       }
       f1RaceMapPoll.set(raceKey, game);
     }
   } else {
     nonF1GamesPoll.push(game);
   }
 });
  // Combine deduplicated F1 races with other games
 const deduplicatedGamesPoll = [...Array.from(f1RaceMapPoll.values()), ...nonF1GamesPoll];
 console.log(`Deduplicated ${allGames.length} games to ${deduplicatedGamesPoll.length} (removed ${allGames.length - deduplicatedGamesPoll.length} duplicate F1 driver entries)`);
  // Replace allGames with deduplicated version
 allGames.length = 0;
 allGames.push(...deduplicatedGamesPoll);
 */




 // Debug: Log all unique leagues being fetched
 const uniqueLeagues = [...new Set(allGames.map(g => g.League))];
 console.log('All leagues being fetched:', uniqueLeagues);

// Debug: Log leagues by sport to see what FlashLive API returns
const leaguesBySport = {};
allGames.forEach(g => {
  if (!leaguesBySport[g.Sport]) leaguesBySport[g.Sport] = new Set();
  leaguesBySport[g.Sport].add(g.League);
});
Object.keys(leaguesBySport).forEach(sport => {
  console.log(`${sport} leagues from FlashLive:`, Array.from(leaguesBySport[sport]));
});

const gamesForFirestore = allGames.filter(g => {
  const allowedLeaguesForSport = ALLOWED_LEAGUE_KEYWORDS[g.Sport] || [];
 
  // TEMPORARILY DISABLED: Formula 1 is now handled via manual entry
  // Special handling for Formula 1 - check if league name includes "Formula 1"
  // const isF1 = g.Sport === 'Motorsport' && g.League && g.League.includes('Formula 1');
  const isF1 = false; // Disabled - F1 now manual
  
  // Special handling for Tennis leagues containing "ATP"
  const isATPTennis = g.Sport === 'Tennis' && g.League && g.League.includes('ATP');
  
  // Special handling for "USA: NCAA" - it can be Basketball, American Football, or Hockey
  // BUT: Exclude NCAAM/NCAAW Basketball from FlashLive polling since FlashLive doesn't provide live updates
  // These will be handled by NCAA API polling within pollLiveGamesHandler (which preserves Game IDs and matches by team names)
  const isNCAA = g.League === 'USA: NCAA' || g.League === 'USA: NCAA Women';
  const isNCAAAllowed = isNCAA && (
    (g.Sport === 'American Football' && allowedLeaguesForSport.includes(g.League)) ||
    (g.Sport === 'Hockey' && allowedLeaguesForSport.includes(g.League))
    // Exclude Basketball - handled by NCAA API polling within pollLiveGamesHandler
  );
  
  // Special handling for qualification leagues - use prefix matching
  const isQualificationLeague = g.Sport === 'Soccer' && g.League && (
    g.League.startsWith('Africa: World Cup - Qualification') ||
    g.League.startsWith('Asia: World Cup - Qualification') ||
    g.League.startsWith('Asia: Asian Cup - Qualification') ||
    g.League.startsWith('Europe: World Cup - Qualification') ||
    g.League.startsWith('North & Central America: World Cup - Qualification')
  );
  
  const isAllowedLeague = isF1 || isATPTennis || isNCAAAllowed || isQualificationLeague || allowedLeaguesForSport.includes(g.League);
  
  // For F1, only Home Team is required (Away Team is empty). For others, both are required.
  const hasValidTeams = isF1 ? g['Home Team'] : (g['Home Team'] && g['Away Team']);
  const hasStartTime = g['Start Time'];
  const hasGameId = g['Game ID'];
  // Filter out games with "U" followed by numbers (e.g., U20, U23, U19) for World: Friendly International
 const isUTeamGame = g.League === 'World: Friendly International' &&
   (/\bU\d+\b/.test(g['Home Team']) || /\bU\d+\b/.test(g['Away Team']));
  // ---------- TIME FILTER (for live polling, include live games and games within ~24 hours) ----------
 // For pollLiveGames: Include games that are:
 // 1. Currently live (IN PROGRESS) - regardless of date
 // 2. Scheduled for today or tomorrow
 // 3. Started within the last 24 hours (in case they're still updating)
 let isWithinLocalWindow = true;
 const isLive = (g['Match Status'] || '').toUpperCase().includes('IN PROGRESS') || 
                (g['Match Status'] || '').toUpperCase().includes('LIVE') ||
                (g['StageType'] || '').toUpperCase().includes('LIVE');
 
 if (g['Start Time'] && g['Start Time'].toDate) {
   try {
     const startTimeUTC = g['Start Time'].toDate().toISOString();
     const gameUTC = DateTime.fromISO(startTimeUTC, { zone: 'utc' });
     const nowUTC = DateTime.now().setZone('utc');
     
     // If game is live, always include it (regardless of date)
     if (isLive) {
       isWithinLocalWindow = true;
     } else {
       // For non-live games, check if they're within the last 24 hours or next 24 hours
       const hoursDiff = gameUTC.diff(nowUTC, 'hours').hours;
       // Include games that started within last 24 hours or are scheduled within next 24 hours
       isWithinLocalWindow = hoursDiff >= -24 && hoursDiff <= 24;
     }
   } catch (error) {
     console.log('Error parsing start time for game:', g['Game ID'], error);
     // If there's an error parsing time, but game is live, include it
     isWithinLocalWindow = isLive;
   }
 }
  
  const passesFilter = isAllowedLeague && hasValidTeams && hasStartTime && hasGameId && !isUTeamGame && isWithinLocalWindow;
  
  // Debug logging for non-soccer games
  if (!passesFilter && (g.Sport === 'Basketball' || g.Sport === 'American Football' || g.Sport === 'Hockey')) {
    console.log(`‚ö†Ô∏è Filtered out: Sport=${g.Sport}, League="${g.League}", isAllowedLeague=${isAllowedLeague}, hasValidTeams=${hasValidTeams}, hasStartTime=${!!hasStartTime}, hasGameId=${!!hasGameId}, isUTeamGame=${isUTeamGame}, isWithinLocalWindow=${isWithinLocalWindow}`);
  }
  
  // Debug logging for games that pass the filter
  if (passesFilter && (g.Sport === 'Basketball' || g.Sport === 'American Football' || g.Sport === 'Hockey')) {
    console.log(`‚úÖ Passing filter: ${g['Away Team']} vs ${g['Home Team']} (${g.Sport} - ${g.League}) - Status: ${g['Match Status']}`);
  }
  
  return passesFilter;
});
console.log(`Filtered ${gamesForFirestore.length} games for Firestore using exact matching.`);




 if (gamesForFirestore.length > 0) {
   await writeGamesToFirestore(gamesForFirestore);
   console.log(`‚úÖ Successfully updated ${gamesForFirestore.length} games in Firestore.`);
 } else {
   console.log('‚ö†Ô∏è No valid games to update.');
 }

 let totalGamesUpdated = gamesForFirestore.length;
 
 // Poll NCAA API directly for NCAAM/NCAAW live scores (not FlashLive API)
console.log('--- Starting NCAA API polling for NCAAM/NCAAW ---');
const ENABLE_NCAA_API = false;

if (ENABLE_NCAA_API) {
  try {
    const todayNCAA = nowInMountain.toFormat('yyyy/MM/dd');
    const ncaaGames = [];

    const FLASH_LIVE_TO_NCAA_API_MAP = {
      'NCAAM': {
        'North Carolina A&T': 'North Carolina A&T',
        'N. Carolina A&T': 'North Carolina A&T'
      },
      'NCAAW': {
        'Albany Great Danes': 'Albany (NY)',
        'Arkansas Razorbacks': 'Arkansas',
        'Boise State': 'Boise St.',
        'Boston': 'Boston U.',
        'Cincinnati Bearcats': 'Cincinnati',
        'Colorado State': 'Colorado St.',
        'Dallas Univ.': 'Dallas',
        'Delaware State': 'Delaware St.',
        'Dickinson Red Devils': 'Dickinson',
        'East Texas A&M': 'East Tex. A&M',
        'East. Washington': 'Eastern Wash.',
        'Florida Atlantic': 'Florida Atlantic',
        'Frostburg State Bobcats': 'Frostburg St.',
        'Houston Cougars': 'Houston',
        'Houston Christian': 'Houston Christian',
        'Illinois Fighting Illini': 'Illinois',
        'Iowa State': 'Iowa St.',
        'James Madison': 'James Madison',
        'Kennesaw State': 'Kennesaw St.',
        'Lipscomb Bisons': 'Lipscomb',
        'Louisville': 'Louisville',
        'Loyola Marymount': 'Loyola Marymount',
        'LSU Tigers': 'LSU',
        'MD-E. Shore': 'Md.-East. Shore',
        'Md.-East. Shore': 'Md.-East. Shore',
        'Mercyhurst Lakers': 'Mercyhurst',
        'Merrimack Warriors': 'Merrimack',
        'Michigan Wolverines': 'Michigan',
        'Michigan State': 'Michigan St.',
        'Middle Tenn. St.': 'Middle Tenn.',
        'Miss. Valley St. ': 'Mississippi Val.',
        'NC State': 'North Carolina St.',
        'Nebraska': 'Nebraska',
        'New Haven Chargers': 'New Haven',
        'North Alabama': 'North Ala.',
        'North Carolina A&T': 'North Carolina A&T',
        'N. Carolina A&T': 'North Carolina A&T',
        'North Dakota St': 'North Dakota St.',
        'Northern Colorado': 'Northern Colo.',
        'Northern New Mexico': 'Northern New Mexico',
        'Northwest Indian': 'Northwest Indian',
        'Notre Dame': 'Notre Dame',
        'Ottawa Spirit': 'Ottawa Spirit',
        'Pacific Lutheran': 'Pacific Lutheran',
        'Prairie View A&M': 'Prairie View',
        'Providence Friars': 'Providence',
        'Purdue': 'Purdue',
        'Queens Royals': 'Queens (NC)',
        'Regent University': 'Regent University',
        'Richmond Spiders': 'Richmond',
        'RIT Tigers': 'Rochester Inst.',
        "Saint Josephs Hawks": "Saint Joseph's",
        "Saint Marys Gaels": "Saint-Mary's (CA)",
        'SE Missouri State': 'Southeast Mo. St.',
        'Sewanee Tigers': 'Sewanee',
        'SMU Mustangs': 'SMU',
        'South Dakota Coyotes': 'South Dakota',
        'Southern Illinois': 'Southern Ill.',
        'Southern Indiana': 'Southern Ind.',
        'Southern Univ.': 'Southern U.',
        'Southern Virginia': 'Southern Virginia',
        "St. Peters": "Saint Peter's",
        'Tennessee Volunteers': 'Tennessee',
        'Texas A&M SA Jaguars': 'Texas A&M SA Jaguars',
        'Troy ': 'Troy',
        'Tulane': 'Tulane',
        'Tulsa': 'Tulsa',
        'UTSA Roadrunners': 'Texas at San Antonio',
        'USC Trojans': 'Southern California',
        'Virginia Cavaliers': 'Virginia',
        'Washington & Lee': 'Wash. & Lee',
        'Western Illinois': 'Western Ill.',
        'Westminster Blue Jays': 'Westminster (MO)',
        'Westminster UT': 'Westminster (UT)'
      }
    };

    function mapFlashLiveToNCAA(flashLiveName, league) {
      if (!flashLiveName) return '';
      let normalized = flashLiveName.endsWith(' W') ? flashLiveName.slice(0, -2) : flashLiveName;
      normalized = normalized.replace(/^\d+\s+/, '').trim();
      const leagueKey = league === 'USA: NCAA' ? 'NCAAM' : 'NCAAW';
      const leagueMap = FLASH_LIVE_TO_NCAA_API_MAP[leagueKey];
      if (leagueMap && leagueMap[normalized]) {
        return leagueMap[normalized];
      }
      return normalized;
    }

    function normalizeTeamNameForNCAA(name) {
      if (!name) return '';
      let normalized = name.endsWith(' W') ? name.slice(0, -2) : name;
      normalized = normalized.replace(/^\d+\s+/, '');
      return normalized
        .toLowerCase()
        .normalize('NFD')
        .replace(/[\u0300-\u036f]/g, '')
        .replace(/[^a-z0-9\s]/g, ' ')
        .replace(/\s+/g, ' ')
        .trim();
    }

    try {
      const ncaamUrl = `https://ncaa-api.henrygd.me/scoreboard/basketball-men/d1/${todayNCAA}`;
      console.log(`Fetching NCAAM games from NCAA API: ${ncaamUrl}`);
      const ncaamResponse = await fetch(ncaamUrl, {
        headers: {
          'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36'
        }
      });
      if (!ncaamResponse.ok) {
        throw new Error(`HTTP error! status: ${ncaamResponse.status}`);
      }
      const ncaamData = await ncaamResponse.json();

      if (ncaamData.games && Array.isArray(ncaamData.games)) {
        for (const gameItem of ncaamData.games) {
          const game = gameItem.game;
          if (!game) continue;

          const awayTeam = game.away;
          const homeTeam = game.home;
          if (!awayTeam || !homeTeam) continue;

          const awayScore = awayTeam.score || '';
          const homeScore = homeTeam.score || '';
          const finalMessage = game.finalMessage || '';
          const gameState = game.gameState || '';
          const contestClock = game.contestClock || '';
          const currentPeriod = game.currentPeriod || '';
          const startTimeEpochSeconds = game.startTimeEpoch ? Number(game.startTimeEpoch) : null;
          const startTimeMillis = Number.isFinite(startTimeEpochSeconds) ? startTimeEpochSeconds * 1000 : null;
          const startTimeDisplay = game.startTime || game.start || '';
          const startDate = game.startDate || '';

          const finalMessageNorm = (finalMessage || '').toUpperCase();
          const gameStateNorm = (gameState || '').toUpperCase();
          const currentPeriodNorm = (currentPeriod || '').toUpperCase();
          const hasClock = contestClock && contestClock !== '0:00';
          const homeScoreNum = Number(homeScore);
          const awayScoreNum = Number(awayScore);

          let matchStatus = 'SCHEDULED';
          if (finalMessageNorm === 'FINAL' || gameStateNorm === 'FINAL' || currentPeriodNorm === 'FINAL') {
            matchStatus = 'FINAL';
          } else if (
            finalMessageNorm.includes('LIVE') ||
            ['LIVE', 'IN_PROGRESS', 'IN PROGRESS', 'OVERTIME', 'OT', '2ND HALF', '2ND QUARTER'].some(state => gameStateNorm.includes(state)) ||
            hasClock ||
            homeScoreNum > 0 ||
            awayScoreNum > 0
          ) {
            if (!finalMessageNorm.includes('FINAL') && !gameStateNorm.includes('FINAL')) {
              matchStatus = 'IN PROGRESS';
            }
          } else if (currentPeriodNorm.includes('HALF')) {
            matchStatus = 'HALFTIME';
          }

          const stageType = matchStatus === 'IN PROGRESS' ? 'LIVE' : matchStatus;
          const stageValue = currentPeriod || finalMessage || matchStatus;
          const statusDisplay = matchStatus === 'IN PROGRESS'
            ? (currentPeriod || finalMessage || 'IN PROGRESS')
            : matchStatus;
          const startDateLuxon = startDate
            ? DateTime.fromFormat(startDate, 'MM-dd-yyyy', { zone: 'America/Denver' })
            : null;
          const startDateIso = startDateLuxon && startDateLuxon.isValid ? startDateLuxon.toISODate() : null;
          const gameDateIso = startTimeMillis
            ? DateTime.fromMillis(startTimeMillis).setZone('America/New_York').toISODate()
            : (startDateIso || todayStr);

          const awayTeamName = awayTeam.names.short || awayTeam.names.full || awayTeam.names.seo || '';
          const homeTeamName = homeTeam.names.short || homeTeam.names.full || homeTeam.names.seo || '';

          if (awayTeamName && homeTeamName) {
            ncaaGames.push({
              league: 'USA: NCAA',
              sport: 'Basketball',
              homeTeam: homeTeamName,
              awayTeam: awayTeamName,
              homeScore: homeScore.toString(),
              awayScore: awayScore.toString(),
              matchStatus,
              status: statusDisplay,
              stage: stageValue,
              stageType,
              gameTime: contestClock || '',
              currentPeriod,
              ncaaGameId: game.gameID,
              startTimeMillis,
              startTimeDisplay,
              gameDateIso
            });
          }
        }
      }

      console.log(`Fetched ${ncaaGames.filter(g => g.league === 'USA: NCAA').length} NCAAM games from NCAA API.`);
    } catch (err) {
      console.error(`Error fetching NCAAM games from NCAA API: ${err.message}`);
    }

    await new Promise(resolve => setTimeout(resolve, 250));

    try {
      const ncaawUrl = `https://ncaa-api.henrygd.me/scoreboard/basketball-women/d1/${todayNCAA}`;
      console.log(`Fetching NCAAW games from NCAA API: ${ncaawUrl}`);
      const ncaawResponse = await fetch(ncaawUrl, {
        headers: {
          'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36'
        }
      });
      if (!ncaawResponse.ok) {
        throw new Error(`HTTP error! status: ${ncaawResponse.status}`);
      }
      const ncaawData = await ncaawResponse.json();

      if (ncaawData.games && Array.isArray(ncaawData.games)) {
        for (const gameItem of ncaawData.games) {
          const game = gameItem.game;
          if (!game) continue;

          const awayTeam = game.away;
          const homeTeam = game.home;
          if (!awayTeam || !homeTeam) continue;

          const awayScore = awayTeam.score || '';
          const homeScore = homeTeam.score || '';
          const finalMessage = game.finalMessage || '';
          const gameState = game.gameState || '';
          const contestClock = game.contestClock || '';
          const currentPeriod = game.currentPeriod || '';
          const startTimeEpochSeconds = game.startTimeEpoch ? Number(game.startTimeEpoch) : null;
          const startTimeMillis = Number.isFinite(startTimeEpochSeconds) ? startTimeEpochSeconds * 1000 : null;
          const startTimeDisplay = game.startTime || game.start || '';
          const startDate = game.startDate || '';

          const finalMessageNorm = (finalMessage || '').toUpperCase();
          const gameStateNorm = (gameState || '').toUpperCase();
          const currentPeriodNorm = (currentPeriod || '').toUpperCase();
          const hasClock = contestClock && contestClock !== '0:00';
          const homeScoreNum = Number(homeScore);
          const awayScoreNum = Number(awayScore);

          let matchStatus = 'SCHEDULED';
          if (finalMessageNorm === 'FINAL' || gameStateNorm === 'FINAL' || currentPeriodNorm === 'FINAL') {
            matchStatus = 'FINAL';
          } else if (
            finalMessageNorm.includes('LIVE') ||
            ['LIVE', 'IN_PROGRESS', 'IN PROGRESS', 'OVERTIME', 'OT', '2ND HALF', '2ND QUARTER'].some(state => gameStateNorm.includes(state)) ||
            hasClock ||
            homeScoreNum > 0 ||
            awayScoreNum > 0
          ) {
            if (!finalMessageNorm.includes('FINAL') && !gameStateNorm.includes('FINAL')) {
              matchStatus = 'IN PROGRESS';
            }
          } else if (currentPeriodNorm.includes('HALF')) {
            matchStatus = 'HALFTIME';
          }

          const stageType = matchStatus === 'IN PROGRESS' ? 'LIVE' : matchStatus;
          const stageValue = currentPeriod || finalMessage || matchStatus;
          const statusDisplay = matchStatus === 'IN PROGRESS'
            ? (currentPeriod || finalMessage || 'IN PROGRESS')
            : matchStatus;
          const startDateLuxon = startDate
            ? DateTime.fromFormat(startDate, 'MM-dd-yyyy', { zone: 'America/Denver' })
            : null;
          const startDateIso = startDateLuxon && startDateLuxon.isValid ? startDateLuxon.toISODate() : null;
          const gameDateIso = startTimeMillis
            ? DateTime.fromMillis(startTimeMillis).setZone('America/New_York').toISODate()
            : (startDateIso || todayStr);

          const awayTeamName = awayTeam.names.short || awayTeam.names.full || awayTeam.names.seo || '';
          const homeTeamName = homeTeam.names.short || homeTeam.names.full || homeTeam.names.seo || '';

          if (awayTeamName && homeTeamName) {
            ncaaGames.push({
              league: 'USA: NCAA Women',
              sport: 'Basketball',
              homeTeam: homeTeamName,
              awayTeam: awayTeamName,
              homeScore: homeScore.toString(),
              awayScore: awayScore.toString(),
              matchStatus,
              status: statusDisplay,
              stage: stageValue,
              stageType,
              gameTime: contestClock || '',
              currentPeriod,
              ncaaGameId: game.gameID,
              startTimeMillis,
              startTimeDisplay,
              gameDateIso
            });
          }
        }
      }

      console.log(`Fetched ${ncaaGames.filter(g => g.league === 'USA: NCAA Women').length} NCAAW games from NCAA API.`);
    } catch (err) {
      console.error(`Error fetching NCAAW games from NCAA API: ${err.message}`);
    }

    console.log(`üìä Total NCAA API games fetched: ${ncaaGames.length} (NCAAM: ${ncaaGames.filter(g => g.league === 'USA: NCAA' && g.sport === 'Basketball').length}, NCAAW: ${ncaaGames.filter(g => g.league === 'USA: NCAA Women').length})`);

    const matchedNcaaGameIds = new Set();
    const ncaaGamesToUpdate = [];
    const snapshot = await gamesRef.where('gameDate', '==', todayStr).get();

    for (const doc of snapshot.docs) {
      const firestoreGame = doc.data();
      const gameLeague = firestoreGame.League || '';
      const gameSport = firestoreGame.Sport || '';

      if (gameSport !== 'Basketball') continue;
      if (gameLeague !== 'USA: NCAA' && gameLeague !== 'USA: NCAA Women') continue;

      const mappedFlashLiveHome = mapFlashLiveToNCAA(firestoreGame['Home Team'], gameLeague);
      const mappedFlashLiveAway = mapFlashLiveToNCAA(firestoreGame['Away Team'], gameLeague);

      const ncaaGame = await (async () => {
        const leagueKey = gameLeague === 'USA: NCAA' ? 'NCAAM' : 'NCAAW';
        
        for (const ng of ncaaGames) {
          if (gameLeague === 'USA: NCAA' && ng.league !== 'USA: NCAA') continue;
          if (gameLeague === 'USA: NCAA Women' && ng.league !== 'USA: NCAA Women') continue;

          const ncaaHome = ng.homeTeam;
          const ncaaAway = ng.awayTeam;

          // Try exact match first
          const homeMatchExact = mappedFlashLiveHome === ncaaHome;
          const awayMatchExact = mappedFlashLiveAway === ncaaAway;
          if (homeMatchExact && awayMatchExact) return ng;

          // Try normalized match
          const homeMatchNormalized = normalizeTeamNameForNCAA(mappedFlashLiveHome) === normalizeTeamNameForNCAA(ncaaHome);
          const awayMatchNormalized = normalizeTeamNameForNCAA(mappedFlashLiveAway) === normalizeTeamNameForNCAA(ncaaAway);
          if (homeMatchNormalized && awayMatchNormalized) return ng;
        }
        
        return null;
      })();

      if (!ncaaGame) continue;

      matchedNcaaGameIds.add(ncaaGame.ncaaGameId);

      const updatedGame = {
        ...firestoreGame,
        'Home Score': ncaaGame.homeScore,
        'Away Score': ncaaGame.awayScore,
        'Match Status': ncaaGame.matchStatus,
        'Status': ncaaGame.status,
        'Stage': ncaaGame.stage,
        'StageType': ncaaGame.stageType,
        'GameTime': ncaaGame.gameTime,
        'Current Period': ncaaGame.currentPeriod || '',
        'Last Updated': new Date().toISOString()
      };

      if (ncaaGame.startTimeMillis) {
        updatedGame['Start Time'] = admin.firestore.Timestamp.fromMillis(ncaaGame.startTimeMillis);
        updatedGame['gameDate'] = DateTime.fromMillis(ncaaGame.startTimeMillis).setZone('America/New_York').toISODate();
      } else if (ncaaGame.gameDateIso) {
        updatedGame['gameDate'] = ncaaGame.gameDateIso;
      }

      ncaaGamesToUpdate.push({ docId: doc.id, game: updatedGame });
    }

    if (ncaaGamesToUpdate.length > 0) {
      const batch = db.batch();
      for (const { docId, game } of ncaaGamesToUpdate) {
        batch.set(gamesRef.doc(docId), game, { merge: true });
      }
      await batch.commit();
      totalGamesUpdated += ncaaGamesToUpdate.length;
      console.log(`‚úÖ Successfully updated ${ncaaGamesToUpdate.length} NCAA games via NCAA API fallback.`);
    } else {
      console.log('‚ö†Ô∏è No existing NCAA game documents matched for update.');
    }

    const unmatchedNcaaGames = ncaaGames.filter(ng => !matchedNcaaGameIds.has(ng.ncaaGameId));
    if (unmatchedNcaaGames.length > 0) {
      const newDocs = unmatchedNcaaGames
        .filter(ng => ng.ncaaGameId)
        .map(ng => {
          const gameId = `NCAA-${ng.ncaaGameId}`;
          const startTimeTimestamp = ng.startTimeMillis
            ? admin.firestore.Timestamp.fromMillis(ng.startTimeMillis)
            : admin.firestore.Timestamp.now();
          const gameDateValue = ng.startTimeMillis
            ? DateTime.fromMillis(ng.startTimeMillis).setZone('America/New_York').toISODate()
            : (ng.gameDateIso || todayStr);

          return {
            'Sport': ng.sport,
            'Game ID': gameId,
            'League': ng.league,
            'Matchup': `${ng.awayTeam} vs ${ng.homeTeam}`,
            'Start Time': startTimeTimestamp,
            'Home Team': ng.homeTeam,
            'Away Team': ng.awayTeam,
            'Home Score': ng.homeScore,
            'Away Score': ng.awayScore,
            'Status': ng.status,
            'Match Status': ng.matchStatus,
            'Stage': ng.stage,
            'GameTime': ng.gameTime || '',
            'StageType': ng.stageType,
            'Current Period': ng.currentPeriod || '',
            'Last Updated': new Date().toISOString(),
            'gameDate': gameDateValue
          };
        });

      if (newDocs.length > 0) {
        await writeGamesToFirestore(newDocs);
        totalGamesUpdated += newDocs.length;
        console.log(`‚úÖ Inserted ${newDocs.length} NCAA games directly (no FlashLive counterpart).`);
      } else {
        console.log('‚ö†Ô∏è NCAA API returned games without IDs; skipping insert.');
      }
    } else {
      console.log('‚úÖ All NCAA API games matched existing Firestore entries.');
    }
  } catch (ncaaErr) {
    console.error('--- NCAA API polling FAILED ---', ncaaErr);
  }
} else {
  console.log('Skipping NCAA API polling for NCAAM/NCAAW (disabled).');
}


 if (res) res.status(200).send(`Polling complete. Updated ${totalGamesUpdated} games.`);
} catch (err) {
 console.error('--- pollLiveGamesHandler FAILED ---', err);
 if (res) res.status(500).send('Polling failed.');
}
};






const refreshAllHandler = async (req, res) => {
  // Return immediately to avoid Cloud Scheduler timeout
  // Tasks will continue running in background
  res.status(202).send('refreshAll started: importing featured games, running stats scrapers, running standings scrapers. (Games are handled by pollESPNLiveData)');
  
  // Run tasks asynchronously (don't await - let them run in background)
  (async () => {
    try {
      console.log('--- /refreshAll triggered ---');
      // NOTE: Games are now handled by pollESPNLiveData endpoint
      // This function only handles featured games, stats, and standings
      
      // Import featured games
      console.log('--- Importing featured games ---');
      const { importFeaturedGames } = await import('./import-featured-from-sheets.cjs');
      await importFeaturedGames();
      
      // Run stats scrapers
      console.log('--- Running stats scrapers ---');
      const { runAllStatsScrapers } = await import('./run-all-stats-scrapers.js');
      await runAllStatsScrapers();
      
      // Run standings scrapers
      console.log('--- Running standings scrapers ---');
      const { runScrapers } = require('./scrape-all-standings.cjs');
      await runScrapers();
      
      console.log('‚úÖ refreshAll complete: imported featured games, ran stats scrapers, ran standings scrapers.');
    } catch (err) {
      console.error('--- /refreshAll FAILED ---', err);
    }
  })();
};




// =================================================================
// NEW FUNCTIONALITY ADDED HERE
// =================================================================
const FUTURE_GAMES_SHEET_NAME = "Future Games";




/**
* Checks if a sheet with a specific title exists and creates it if it doesn't.
* Returns the title of the sheet that was found or created.
* @param {string} spreadsheetId The ID of the Google Spreadsheet.
* @param {string} sheetName The title of the sheet to find or create.
* @returns {string} The title of the found or created sheet.
*/
async function createOrGetSheet(spreadsheetId, sheetName) {
try {
 // Check if the sheet already exists
 const response = await rateLimitedSheetRequest(() =>
   sheets.spreadsheets.get({
     spreadsheetId,
     fields: 'sheets.properties.title'
   })
 );
 const sheetsList = response.data.sheets;
 const existingSheet = sheetsList.find(s => s.properties.title === sheetName);




 if (existingSheet) {
   console.log(`Sheet "${sheetName}" already exists. Using existing tab.`);
   return sheetName;
 }




 // If the sheet doesn't exist, create it
 console.log(`Sheet "${sheetName}" not found. Creating a new tab...`);
 const request = {
   spreadsheetId,
   resource: {
     requests: [{
       addSheet: {
         properties: {
           title: sheetName
         }
       }
     }]
   }
 };
 await rateLimitedSheetRequest(() => sheets.spreadsheets.batchUpdate(request));
 console.log(`Successfully created new sheet with title "${sheetName}".`);
 return sheetName;
} catch (err) {
 console.error(`Error in createOrGetSheet: ${err.message}`);
 throw err;
}
}




async function fetchUpcomingGamesHandler(req, res) {
try {
 console.log('--- fetchUpcomingGamesHandler started for the next 7 days. ---');




 await authenticateGoogleSheets();
 await createOrGetSheet(SPREADSHEET_ID, FUTURE_GAMES_SHEET_NAME);




 const rapidApiHeaders = {
   'X-RapidAPI-Key': RAPIDAPI_KEY,
   'X-RapidAPI-Host': RAPIDAPI_HOST
 };




const allGames = [];
const nowInUTC = DateTime.now().setZone('utc');




 // Loop for the next 7 days (including today)
 for (let i = 0; i < 7; i++) {
   const dateToFetch = nowInMountain.plus({ days: i }).toISODate();
   console.log(`Fetching games for date: ${dateToFetch}`);




   for (const league of leaguesToFetch) {
     const url = `https://${RAPIDAPI_HOST}/v1/events/list?sport_slug=${league.slug}&date=${dateToFetch}&locale=en_INT&sport_id=${league.id}&timezone=-4&indent_days=0`;




     try {
       const data = await fetchRapidApiData(url, rapidApiHeaders);
       const tournaments = data.DATA || [];




       for (const tour of tournaments) {
         // Check if the tournament name matches the desired league.
         // Some leagues (like Europa League) might not match exactly, so check for inclusion instead.
         if (tour.NAME.includes(league.leagueName) || (league.leagueName.includes(tour.NAME))) {
           const events = tour.EVENTS || [];
           for (const event of events) {
             // Normalize Match Status like NCAA API does
             const stageTypeNorm = (event.STAGE_TYPE || '').toUpperCase();
             const stageNorm = (event.STAGE || '').toUpperCase();
             const homeScoreNum = Number(event.HOME_SCORE_CURRENT || 0);
             const awayScoreNum = Number(event.AWAY_SCORE_CURRENT || 0);
             const hasClock = event.GAME_TIME && event.GAME_TIME !== '0:00' && event.GAME_TIME !== '0.0';
             
             let matchStatus = 'SCHEDULED';
             if (stageTypeNorm === 'FINAL' || stageNorm === 'FINAL' || stageTypeNorm.includes('FINAL')) {
               matchStatus = 'FINAL';
             } else if (
               stageTypeNorm.includes('LIVE') ||
               stageTypeNorm.includes('IN_PROGRESS') ||
               stageTypeNorm.includes('IN PROGRESS') ||
               stageTypeNorm.includes('OVERTIME') ||
               stageTypeNorm.includes('OT') ||
               stageNorm.includes('2ND HALF') ||
               stageNorm.includes('2ND QUARTER') ||
               hasClock ||
               homeScoreNum > 0 ||
               awayScoreNum > 0
             ) {
               if (!stageTypeNorm.includes('FINAL') && !stageNorm.includes('FINAL')) {
                 matchStatus = 'IN PROGRESS';
               }
             } else if (stageNorm.includes('HALF') || stageTypeNorm.includes('HALF')) {
               matchStatus = 'HALFTIME';
             }
             
             const game = {
               'Date': dateToFetch,
               'Sport': tour.SPORT_NAME || league.slug,
               'Game ID': event.EVENT_ID,
               'League': tour.NAME,
               'Matchup': `${event.HOME_NAME} vs ${event.AWAY_NAME}`,
               'Start Time': event.START_TIME ? new Date(event.START_TIME * 1000).toISOString() : '',
               'Home Team': event.HOME_NAME,
               'Away Team': event.AWAY_NAME,
               'Home Score': event.HOME_SCORE_CURRENT || '',
               'Away Score': event.AWAY_SCORE_CURRENT || '',
               'Status': event.STAGE || '',
               'Match Status': matchStatus,
               'Last Updated': new Date().toISOString()
             };
             allGames.push(game);
           }
         }
       }
     } catch (err) {
       console.error(`Error fetching ${league.leagueName} for ${dateToFetch}: ${err.message}`);
     }
   }
 }




 console.log(`Fetched a total of ${allGames.length} games for the upcoming week.`);




 const sheetRows = allGames.map(g => [
   g.Date, g.Sport, g['Game ID'], g.League, g.Matchup,
   g['Start Time'], g['Home Team'], g['Away Team'],
   g['Home Score'], g['Away Score'], g.Status,
   g['Match Status'], g['Last Updated']
 ]);




 const sheetHeader = [
   'Date', 'Sport', 'Game ID', 'League', 'Matchup',
   'Start Time', 'Home Team', 'Away Team',
   'Home Score', 'Away Score', 'Status',
   'Match Status', 'Last Updated'
 ];




console.log(`Clearing old data from Google Sheets "${FUTURE_GAMES_SHEET_NAME}" tab...`);
await clearGoogleSheet(SPREADSHEET_ID, FUTURE_GAMES_SHEET_NAME);

console.log(`Attempting to write to Google Sheets on the "${FUTURE_GAMES_SHEET_NAME}" tab...`);
await rateLimitedSheetRequest(() =>
  sheets.spreadsheets.values.update({
    spreadsheetId: SPREADSHEET_ID,
    range: `${FUTURE_GAMES_SHEET_NAME}!A1`,
    valueInputOption: 'RAW',
    requestBody: {
      values: [sheetHeader, ...sheetRows]
    }
  })
);
console.log(`Successfully wrote ${sheetRows.length} rows to Google Sheet.`);




 if (res) {
   res.status(200).send(`Wrote ${sheetRows.length} rows to Google Sheet for the upcoming week.`);
 }
} catch (err) {
 console.error('--- fetchUpcomingGamesHandler FAILED ---', err);
 if (res) res.status(500).send('Weekly scrape and write failed.');
}
}




// =================================================================
// EXPRESS APP
// =================================================================
const app = express();

// CORS middleware for Perspectives admin UI
app.use((req, res, next) => {
  res.header('Access-Control-Allow-Origin', '*');
  res.header('Access-Control-Allow-Methods', 'GET, POST, PUT, DELETE, OPTIONS');
  res.header('Access-Control-Allow-Headers', 'Content-Type, Authorization');
  if (req.method === 'OPTIONS') {
    return res.sendStatus(200);
  }
  next();
});

app.use(express.json());




app.post('/initialScrapeAndStartPolling', initialScrapeAndStartPollingHandler);
// TEMPORARILY DISABLED: Polling endpoints commented out to reduce API usage
// app.get('/pollLiveGames', pollLiveGamesHandler);
// app.post('/pollLiveGames', pollLiveGamesHandler);
app.post('/refreshAll', refreshAllHandler);

// ESPN Live Data Polling Handler
// Writes to sportsGames collection (ESPN/NCAA API games + Google Sheets games for other leagues)
// Works like initialScrapeAndStartPolling: cleans yesterday's games, populates today's, then polls for updates
const pollESPNLiveDataHandler = async (req, res) => {
  const executionId = `poll-${Date.now()}`;
  const userAgent = req.headers?.['user-agent'] || 'unknown';
  const isScheduler = userAgent.includes('Google-Cloud-Scheduler');
  
  try {
    console.log(`\n${'='.repeat(70)}`);
    console.log(`üöÄ [${executionId}] /pollESPNLiveData started`);
    console.log(`‚è∞ Time: ${new Date().toISOString()}`);
    console.log(`üì° Source: ${isScheduler ? 'Cloud Scheduler' : 'Manual'}`);
    console.log(`üîó Path: ${req.url || req.path || '/'}`);
    console.log(`üåê User-Agent: ${userAgent}`);
    console.log('='.repeat(70));
    
    const db = initializeFirebase();
    // Write to sportsGames collection (contains ESPN/NCAA API games + Google Sheets games for other leagues)
    const gamesRef = db.collection(`artifacts/flashlive-daily-scraper/public/data/sportsGames`);
    // Get today's date in Mountain Time (CST)
    // Only fetch games for today (not next 7 days) to reduce API calls and costs
    const nowInMountain = DateTime.now().setZone('America/Denver');
    const todayStr = nowInMountain.toISODate();
    const yesterdayStr = nowInMountain.minus({ days: 1 }).toISODate();
    const twoDaysAgoStr = nowInMountain.minus({ days: 2 }).toISODate();
    
    // Generate array with only today's date (not next 7 days)
    const datesToFetch = [{
      isoDate: todayStr,
      espnDate: nowInMountain.toFormat('yyyyMMdd') // YYYYMMDD format for ESPN API
    }];
    
    // Calculate the date range we want to keep: yesterday + today (2 days total)
    const datesToKeep = [yesterdayStr, todayStr];
    
    console.log(`[ESPN Live Data] Fetching games for today only (${todayStr}) - Mountain Time`);
    console.log(`[ESPN Live Data] Keeping games for: ${datesToKeep.join(', ')} (yesterday's FINAL + today)`);
    
    // Step 1: Clean up yesterday's games (like initialScrapeAndStartPolling does)
    // Check if we have any games for today - if not, this is the morning run and we should clean yesterday
    const todayGamesSnapshot = await gamesRef.where('gameDate', '==', todayStr).limit(1).get();
    const isMorningRun = todayGamesSnapshot.empty;
    
    if (isMorningRun) {
      console.log('[ESPN Live Data] Morning run detected - cleaning up games older than 2 days ago...');
      
      // Get all games from sportsGames to clean up
      const allGamesSnapshot = await gamesRef.get();
      let yesterdayGamesKept = 0;
      let oldGamesDeleted = 0;
      
      let deleteBatch = db.batch();
      let batchCount = 0;
      const BATCH_SIZE = 500;
      
      for (const doc of allGamesSnapshot.docs) {
        const data = doc.data();
        const gameDate = data.gameDate;
        
        // Keep: yesterday's games (all should be FINAL by morning, kept for SCORES tab)
        if (gameDate === yesterdayStr) {
          yesterdayGamesKept++;
          continue; // Keep this game
        }
        
        // Delete: games from 2 days ago and older (not in our keep range)
        if (gameDate && gameDate < yesterdayStr) {
          deleteBatch.delete(doc.ref);
          batchCount++;
          oldGamesDeleted++;
          
          if (batchCount >= BATCH_SIZE) {
            await deleteBatch.commit();
            batchCount = 0;
            deleteBatch = db.batch();
          }
        }
      }
      
      // Commit remaining deletes
      if (batchCount > 0) {
        await deleteBatch.commit();
      }
      
      console.log(`‚úÖ Cleanup complete: Kept ${yesterdayGamesKept} yesterday's games, deleted ${oldGamesDeleted} games from 2+ days ago`);
    } else {
      console.log('[ESPN Live Data] Polling run - updating existing games (no cleanup needed)');
    }

    // For polling runs, we'll optimize to only fetch leagues/dates that have live games
    // Morning runs always fetch all games (to discover when games start)
    
    // Mapping from ESPN league names to display names (matching LEAGUE_DISPLAY_NAME_MAP_FULL from importGamesFromSheets)
    const ESPN_LEAGUE_DISPLAY_NAME_MAP = {
      'NFL': 'USA: NFL',
      'NCAAF': 'USA: NCAA',
      'NBA': 'USA: NBA',
      'WNBA': 'USA: WNBA',
      'MLB': 'USA: MLB',
      'NHL': 'USA: NHL',
      'MLS': 'USA: MLS',
      'NWSL': 'USA: NWSL Women',
      'Premier League': 'England: Premier League',
      'La Liga': 'Spain: LaLiga',
      'Bundesliga': 'Germany: Bundesliga',
      'Serie A': 'Italy: Serie A',
      'Ligue 1': 'France: Ligue 1',
      'Eredivisie': 'Netherlands: Eredivisie',
      'Liga Portugal': 'Portugal: Liga Portugal',
      'Belgian Pro League': 'Belgium: Jupiler Pro League',
      'Scottish Premiership': 'Scotland: Premiership',
      'Brasileirao': 'Brazil: Serie A Betano',
      'EFL Championship': 'England: Championship',
      'EFL League One': 'England: League One',
      'EFL League Two': 'England: League Two',
      'National League': 'England: National League',
      'LaLiga 2': 'Spain: LaLiga 2',
      '2. Bundesliga': 'Germany: 2. Bundesliga',
      'Serie B': 'Italy: Serie B',
      'Ligue 2': 'Ligue 2',
      'UEFA Champions League': 'UEFA Champions League',
      'AFC Champions League': 'Asia: AFC Elite',
      'UEFA Europa League': 'Europa League',
      'UEFA Conference League': 'Conference League',
      'UEFA Nations League': 'UEFA Nations League',
      'CAF Nations League': 'CAF Nations League',
      'FA Cup': 'England: FA Cup',
      'Carabao Cup': 'England: EFL Cup',
      'Copa del Rey': 'Spain: Copa del Rey',
      'Coppa Italia': 'Italy: Coppa Italia',
      'Italian Super Cup': 'Italian Super Cup',
      'DFB-Pokal': 'Germany: DFB Pokal',
      'Coupe de France': 'France: Coupe de France',
      'Trofeo de Campeones': 'Trofeo de Campeones',
      'Saudi Pro League': 'Saudi Arabia: Saudi Professional League',
      'Liga MX': 'Mexico: Liga MX',
      'Japanese J.League': 'Japan: J.League',
      'Chinese Super League': 'China: Super League',
      'Australian A-League Men': 'Australia: A-League Men',
      'Turkish Super Lig': 'Turkey: Super Lig',
      'Greek Super League': 'Greece: Super League',
      'Russian Premier League': 'Russia: Premier League',
      'Gambrinus Liga': 'Czech Republic: Gambrinus Liga',
      'Austrian Bundesliga': 'Austria: Bundesliga',
      'Swiss Super League': 'Switzerland: Super League',
      'Danish Superliga': 'Denmark: Superliga',
      'Swedish Allsvenskan': 'Sweden: Allsvenskan',
      'Norwegian Eliteserien': 'Norway: Eliteserien',
      'Finnish Veikkausliga': 'Finland: Veikkausliga',
      'ATP': 'ATP',
      'WTA': 'WTA',
      'PGA Tour': 'PGA Tour',
      'LPGA Tour': 'LPGA Tour',
      'PGA Champions': 'PGA Champions',
      'LIV Golf': 'LIV Golf',
      'DP World Tour': 'DP World Tour',
      'Korn Ferry': 'Korn Ferry',
      'Formula 1': 'Formula 1',
      'NASCAR Truck Series': 'NASCAR Truck Series',
      'UFC': 'UFC',
      'Bellator': 'Bellator',
      'Boxing': 'Boxing',
      'NCAA Women\'s Volleyball': 'NCAA Women\'s Volleyball',
      'NCAAM': 'USA: NCAA', // From NCAA API
      'NCAAW': 'USA: NCAA Women' // From NCAA API
    };
    
    // Step 2: Fetch and populate today's games
    // ESPN API leagues configuration - ALL available leagues (excluding NCAAM and NCAAW)
    const ESPN_LEAGUES = [
      // American Football
      { sport: 'football', league: 'nfl', leagueName: 'NFL' },
      { sport: 'football', league: 'college-football', leagueName: 'NCAAF' },
      
      // Basketball
      { sport: 'basketball', league: 'nba', leagueName: 'NBA' },
      { sport: 'basketball', league: 'wnba', leagueName: 'WNBA' },
      // Note: mens-college-basketball and womens-college-basketball removed - using NCAA API instead
      
      // Baseball
      { sport: 'baseball', league: 'mlb', leagueName: 'MLB' },
      
      // Hockey
      { sport: 'hockey', league: 'nhl', leagueName: 'NHL' },
      
      // Soccer - Major Leagues
      { sport: 'soccer', league: 'usa.1', leagueName: 'MLS' },
      { sport: 'soccer', league: 'usa.nwsl', leagueName: 'NWSL' },
      { sport: 'soccer', league: 'eng.1', leagueName: 'Premier League' },
      { sport: 'soccer', league: 'esp.1', leagueName: 'La Liga' },
      { sport: 'soccer', league: 'ger.1', leagueName: 'Bundesliga' },
      { sport: 'soccer', league: 'ita.1', leagueName: 'Serie A' },
      { sport: 'soccer', league: 'fra.1', leagueName: 'Ligue 1' },
      // { sport: 'soccer', league: 'mex.1', leagueName: 'Liga MX' }, // Out of season
      { sport: 'soccer', league: 'ned.1', leagueName: 'Eredivisie' },
      { sport: 'soccer', league: 'por.1', leagueName: 'Liga Portugal' },
      { sport: 'soccer', league: 'bel.1', leagueName: 'Belgian Pro League' },
      { sport: 'soccer', league: 'sco.1', leagueName: 'Scottish Premiership' },
      { sport: 'soccer', league: 'arg.1', leagueName: 'Argentine Primera' },
      { sport: 'soccer', league: 'bra.1', leagueName: 'Brasileirao' },
      { sport: 'soccer', league: 'eng.2', leagueName: 'EFL Championship' },
      { sport: 'soccer', league: 'eng.3', leagueName: 'EFL League One' },
      { sport: 'soccer', league: 'eng.4', leagueName: 'EFL League Two' },
      { sport: 'soccer', league: 'eng.5', leagueName: 'National League' },
      { sport: 'soccer', league: 'esp.2', leagueName: 'LaLiga 2' },
      { sport: 'soccer', league: 'ger.2', leagueName: '2. Bundesliga' },
      { sport: 'soccer', league: 'ita.2', leagueName: 'Serie B' },
      { sport: 'soccer', league: 'fra.2', leagueName: 'Ligue 2' },
      // { sport: 'soccer', league: 'mex.2', leagueName: 'Liga MX Expansi√≥n' }, // Out of season
      
      // Soccer - Additional Leagues
      { sport: 'soccer', league: 'ksa.1', leagueName: 'Saudi Pro League' },
      { sport: 'soccer', league: 'mex.1', leagueName: 'Liga MX' },
      { sport: 'soccer', league: 'jpn.1', leagueName: 'Japanese J.League' },
      { sport: 'soccer', league: 'chn.1', leagueName: 'Chinese Super League' },
      { sport: 'soccer', league: 'aus.1', leagueName: 'Australian A-League Men' },
      { sport: 'soccer', league: 'tur.1', leagueName: 'Turkish Super Lig' },
      { sport: 'soccer', league: 'gre.1', leagueName: 'Greek Super League' },
      { sport: 'soccer', league: 'rus.1', leagueName: 'Russian Premier League' },
      { sport: 'soccer', league: 'cze.1', leagueName: 'Gambrinus Liga' },
      { sport: 'soccer', league: 'aut.1', leagueName: 'Austrian Bundesliga' },
      { sport: 'soccer', league: 'sui.1', leagueName: 'Swiss Super League' },
      { sport: 'soccer', league: 'den.1', leagueName: 'Danish Superliga' },
      { sport: 'soccer', league: 'swe.1', leagueName: 'Swedish Allsvenskan' },
      { sport: 'soccer', league: 'nor.1', leagueName: 'Norwegian Eliteserien' },
      { sport: 'soccer', league: 'fin.1', leagueName: 'Finnish Veikkausliga' },
      
      // Soccer - UEFA Competitions
      { sport: 'soccer', league: 'uefa.champions', leagueName: 'UEFA Champions League' },
      { sport: 'soccer', league: 'uefa.europa', leagueName: 'UEFA Europa League' },
      { sport: 'soccer', league: 'uefa.europa.conf', leagueName: 'UEFA Conference League' },
      { sport: 'soccer', league: 'uefa.nations', leagueName: 'UEFA Nations League' },
      { sport: 'soccer', league: 'uefa.euroq', leagueName: 'UEFA Euro Qualifiers' },
      { sport: 'soccer', league: 'uefa.wchampions', leagueName: 'UEFA Women\'s Champions League' },
      
      // Soccer - CAF Competitions
      { sport: 'soccer', league: 'caf.nations', leagueName: 'CAF Nations League' },
      { sport: 'soccer', league: 'caf.nations_qual', leagueName: 'CAF Nations League Qualifiers' },
      
      // Soccer - CONMEBOL Competitions
      { sport: 'soccer', league: 'conmebol.libertadores', leagueName: 'Copa Libertadores' },
      
      // Soccer - AFC Competitions
      { sport: 'soccer', league: 'afc.asian.cup', leagueName: 'AFC Asian Cup' },
      { sport: 'soccer', league: 'afc.champions', leagueName: 'AFC Champions League' },
      { sport: 'soccer', league: 'afc.cupq', leagueName: 'AFC Cup Qualifiers' },
      
      // Soccer - CONCACAF Competitions
      { sport: 'soccer', league: 'concacaf.nations.league', leagueName: 'CONCACAF Nations League' },
      { sport: 'soccer', league: 'fifa.worldq.concacaf', leagueName: 'FIFA World Cup Qualifiers - CONCACAF' },
      
      // Soccer - Women's Leagues
      { sport: 'soccer', league: 'eng.w.1', leagueName: 'Women\'s Super League' },
      
      // Soccer - National Teams
      { sport: 'soccer', league: 'usa', leagueName: 'USMNT' },
      { sport: 'soccer', league: 'usa.w', leagueName: 'USWNT' },
      
      // Soccer - Other Competitions
      // { sport: 'soccer', league: 'fifa.world', leagueName: 'FIFA World Cup' }, // Out of season
      // { sport: 'soccer', league: 'concacaf.gold', leagueName: 'Gold Cup' }, // Out of season
      // { sport: 'soccer', league: 'usa.open', leagueName: 'U.S. Open Cup' }, // Out of season
      { sport: 'soccer', league: 'eng.fa', leagueName: 'FA Cup' },
      { sport: 'soccer', league: 'eng.league_cup', leagueName: 'Carabao Cup' },
      { sport: 'soccer', league: 'esp.copa_del_rey', leagueName: 'Copa del Rey' },
      { sport: 'soccer', league: 'ita.coppa_italia', leagueName: 'Coppa Italia' },
      { sport: 'soccer', league: 'ita.super_cup', leagueName: 'Italian Super Cup' },
      { sport: 'soccer', league: 'ger.dfb_pokal', leagueName: 'DFB-Pokal' },
      { sport: 'soccer', league: 'fra.coupe_de_france', leagueName: 'Coupe de France' },
      { sport: 'soccer', league: 'arg.trofeo_de_la_campeones', leagueName: 'Trofeo de Campeones' },
      
      // Tennis
      { sport: 'tennis', league: 'atp', leagueName: 'ATP' },
      { sport: 'tennis', league: 'wta', leagueName: 'WTA' },
      
      // Golf
      { sport: 'golf', league: 'pga', leagueName: 'PGA Tour' },
      { sport: 'golf', league: 'lpga', leagueName: 'LPGA Tour' },
      { sport: 'golf', league: 'champions-tour', leagueName: 'PGA Champions' },
      { sport: 'golf', league: 'liv', leagueName: 'LIV Golf' },
      { sport: 'golf', league: 'eur', leagueName: 'DP World Tour' },
      { sport: 'golf', league: 'ntw', leagueName: 'Korn Ferry' },
      
      // Racing
      { sport: 'racing', league: 'f1', leagueName: 'Formula 1' },
      { sport: 'racing', league: 'nascar-cup', leagueName: 'NASCAR Cup Series' },
      { sport: 'racing', league: 'nascar-xfinity', leagueName: 'NASCAR Xfinity Series' },
      { sport: 'racing', league: 'nascar-truck', leagueName: 'NASCAR Truck Series' },
      { sport: 'racing', league: 'indycar', leagueName: 'IndyCar' },
      
      // MMA
      { sport: 'mma', league: 'ufc', leagueName: 'UFC' },
      { sport: 'mma', league: 'bellator', leagueName: 'Bellator' },
      
      // Boxing
      { sport: 'boxing', league: 'boxing', leagueName: 'Boxing' },
      
      // Volleyball
      { sport: 'volleyball', league: 'womens-college-volleyball', leagueName: 'NCAA Women\'s Volleyball' }
    ];
    
    const allGames = [];
    let totalFetched = 0;
    // Track unique games to prevent duplicates (key: league|homeTeam|awayTeam|date)
    const uniqueGames = new Set();
    
    // Helper function to create unique game key
    const getGameKey = (league, homeTeam, awayTeam, date) => {
      return `${league}|${(homeTeam || '').toLowerCase().trim()}|${(awayTeam || '').toLowerCase().trim()}|${date}`;
    };
    
    // Generate deterministic Game ID from game data (for fallback when API doesn't provide stable ID)
    // NOTE: Time is NOT included in Game ID - same game should have same ID regardless of when it's fetched
    const generateDeterministicGameId = (source, league, homeTeam, awayTeam, date) => {
      const normalizedHome = (homeTeam || '').toLowerCase().trim().replace(/[^a-z0-9]/g, '');
      const normalizedAway = (awayTeam || '').toLowerCase().trim().replace(/[^a-z0-9]/g, '');
      const normalizedLeague = (league || '').toLowerCase().trim().replace(/[^a-z0-9]/g, '');
      const dateStr = date.replace(/-/g, '');
      return `${source}-${normalizedLeague}-${normalizedAway}-${normalizedHome}-${dateStr}`;
    };
    
    // Rate limiter for ESPN API (conservative: 2 requests per second = 120/minute)
    let lastESPNRequestTime = 0;
    const MIN_TIME_BETWEEN_ESPN_REQUESTS = 500; // 500ms = 2 requests/second
    
    // Determine which leagues/dates to fetch based on run type:
    // - Morning run: fetch all 7 days for all leagues (to populate upcoming games)
    // - Polling run: only fetch leagues/dates that have live games in Firestore
    let leaguesAndDatesToFetch = [];
    
    if (isMorningRun) {
      // Morning run: fetch only today for all leagues (changed from 7 days to reduce costs)
      leaguesAndDatesToFetch = datesToFetch.map(dateInfo => ({
        ...dateInfo,
        leagues: ESPN_LEAGUES // All leagues for today only
      }));
    } else {
      // Polling run: fetch ALL leagues for today (to discover games that became live)
      // We can't just fetch leagues with existing live games, because games might become live
      // in any league. So we fetch all leagues for today, then filter to only update live games.
      console.log('[ESPN Live Data] Polling run - fetching all leagues for today to discover live games...');
      
      // Check if there are any games for today (if not, nothing to update)
      const todayGamesCheck = await gamesRef.where('gameDate', '==', todayStr).limit(1).get();
      if (todayGamesCheck.empty) {
        console.log('[ESPN Live Data] No games for today; skipping fetch.');
        if (res) {
          return res.status(200).json({ success: true, message: 'No games for today; skipped fetch.' });
        }
        return;
      }
      
      // For polling: fetch ALL leagues for today only (yesterday's scores are already saved)
      // This ensures we discover games that became live in ANY league
      leaguesAndDatesToFetch = [
        {
          isoDate: todayStr,
          espnDate: datesToFetch[0].espnDate,
          leagues: ESPN_LEAGUES // All leagues for today only
        }
      ];
      
      console.log(`[ESPN Live Data] Polling run - will fetch all leagues for today (${todayStr}) only (yesterday's scores already saved)`);
    }
    
    // Fetch rankings once for all NCAA games (NCAAM, NCAAW, NCAAF)
    const ncaamRankings = await fetchNCAARankings('NCAAM');
    const ncaawRankings = await fetchNCAARankings('NCAAW');
    const ncaafRankings = await fetchNCAARankings('NCAAF');
    
    // Fetch from ESPN API for the determined leagues/dates
    for (const dateInfo of leaguesAndDatesToFetch) {
      const { isoDate, espnDate, leagues } = dateInfo;
      console.log(`[ESPN Live Data] Fetching games for ${isoDate} (${espnDate})...`);
      
      // Use the leagues we determined (all leagues for morning run, or only leagues with live games for polling)
      const leaguesToFetch = leagues || ESPN_LEAGUES;
      
      for (const { sport, league, leagueName } of leaguesToFetch) {
        try {
          // Rate limiting: wait if needed
          const now = Date.now();
          const timeSinceLastRequest = now - lastESPNRequestTime;
          if (timeSinceLastRequest < MIN_TIME_BETWEEN_ESPN_REQUESTS) {
            const waitTime = MIN_TIME_BETWEEN_ESPN_REQUESTS - timeSinceLastRequest;
            await new Promise(resolve => setTimeout(resolve, waitTime));
          }
          lastESPNRequestTime = Date.now();
          
          const url = `https://site.api.espn.com/apis/site/v2/sports/${sport}/${league}/scoreboard?dates=${espnDate}`;
          console.log(`[ESPN] Fetching ${leagueName} for ${isoDate}...`);
          
          let response;
          let retries = 3;
          let backoffTime = 1000; // Start with 1 second
          
          while (retries > 0) {
            response = await fetch(url, {
              headers: {
                'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36'
              }
            });
            
            // If rate limited (429) or server error (5xx), retry with exponential backoff
            if (response.status === 429 || (response.status >= 500 && response.status < 600)) {
              retries--;
              if (retries > 0) {
                console.warn(`[ESPN] ${leagueName} (${isoDate}): HTTP ${response.status} - retrying in ${backoffTime/1000}s (${retries} retries left)...`);
                await new Promise(resolve => setTimeout(resolve, backoffTime));
                backoffTime *= 2; // Exponential backoff: 1s, 2s, 4s
                continue;
              }
            }
            break; // Success or non-retryable error
          }
          
          if (!response.ok) {
            console.warn(`[ESPN] ${leagueName} (${isoDate}): HTTP ${response.status} - skipping`);
            continue;
          }
          
          const data = await response.json();
          const events = data.events || [];
          
          for (const event of events) {
            // Tennis tournaments use groupings structure, other sports use direct competitions
            let competitions = [];
            if (sport === 'tennis' && event.groupings && event.groupings.length > 0) {
              // For tennis tournaments, competitions are nested in groupings
              for (const grouping of event.groupings) {
                if (grouping.competitions && Array.isArray(grouping.competitions)) {
                  competitions.push(...grouping.competitions);
                }
              }
            } else {
              // For other sports, use direct competitions array
              competitions = event.competitions || [];
            }
            
            // Get team names from first competition to check for duplicates at event level
            // This prevents processing the same game multiple times across different competitions
            if (competitions.length === 0) continue;
            
            const firstCompetition = competitions[0];
            const firstCompetitors = firstCompetition.competitors || [];
            const firstAwayTeam = firstCompetitors.find(c => c.homeAway === 'away');
            const firstHomeTeam = firstCompetitors.find(c => c.homeAway === 'home');
            
            if (!firstAwayTeam || !firstHomeTeam) continue;
            
            // For tennis, use athlete.displayName; for other sports, use team.displayName
            const firstHomeTeamName = sport === 'tennis' 
              ? (firstHomeTeam.athlete?.displayName || firstHomeTeam.athlete?.shortName || firstHomeTeam.athlete?.fullName || firstHomeTeam.team?.displayName || '')
              : (firstHomeTeam.team?.displayName || '');
            const firstAwayTeamName = sport === 'tennis'
              ? (firstAwayTeam.athlete?.displayName || firstAwayTeam.athlete?.shortName || firstAwayTeam.athlete?.fullName || firstAwayTeam.team?.displayName || '')
              : (firstAwayTeam.team?.displayName || '');
            
            // Get the game's actual start date by converting the start time from UTC to Eastern Time
            // ESPN dates are ISO-8601 UTC timestamps (e.g., "2025-12-27T01:00Z")
            // We must parse as UTC, convert to Eastern, then extract the date
            if (!firstCompetition.date) continue; // Skip if no date
            const gameDateForStorage = DateTime
              .fromISO(firstCompetition.date, { zone: 'utc' })
              .setZone('America/New_York')
              .toISODate();
            
            // Convert the date we're fetching (Mountain Time) to Eastern Time for comparison
            // This ensures we only include games that match the date we're fetching
            const isoDateMountain = DateTime.fromISO(isoDate, { zone: 'America/Denver' });
            const isoDateEastern = isoDateMountain.setZone('America/New_York').toISODate();
            
            // Only include games that match the date we're fetching (after conversion to Eastern Time)
            // This prevents games from other dates from being stored with the wrong date
            // ESPN API returns games from multiple dates, so we MUST filter here
            if (gameDateForStorage !== isoDateEastern) {
              console.log(`[ESPN] FILTERED OUT: ${leagueName} - ${firstAwayTeamName} vs ${firstHomeTeamName} - gameDate (ET): ${gameDateForStorage}, fetching for: ${isoDateEastern}, ESPN UTC: ${firstCompetition.date}`);
              continue; // Skip games that don't match the date we're fetching
            }
            
            // Log games that pass the filter for debugging
            console.log(`[ESPN] INCLUDING: ${leagueName} - ${firstAwayTeamName} vs ${firstHomeTeamName} - gameDate (ET): ${gameDateForStorage}, ESPN UTC: ${firstCompetition.date}`);
          
          // Check for duplicates at EVENT level (before processing competitions)
          const eventGameKey = getGameKey(leagueName, firstHomeTeamName, firstAwayTeamName, gameDateForStorage);
          if (uniqueGames.has(eventGameKey)) {
            console.log(`[ESPN] Skipping duplicate event: ${leagueName} - ${firstAwayTeamName} vs ${firstHomeTeamName} on ${gameDateForStorage}`);
            continue; // Skip entire event if we've already seen this game
          }
          uniqueGames.add(eventGameKey);
          
          // Collect all channels from all competitions for this event
          const allChannels = new Set();
          let primaryCompetition = null;
          let primaryStatus = null;
          let primaryDisplayTime = '';
          
          // Process each competition to collect channels and find primary competition data
          for (const competition of competitions) {
            if (!competition) continue;
            
            const competitors = competition.competitors || [];
            const awayTeam = competitors.find(c => c.homeAway === 'away');
            const homeTeam = competitors.find(c => c.homeAway === 'home');
            
            if (!awayTeam || !homeTeam) continue;
          
            const status = competition.status || {};
            const gameDate = competition.date ? new Date(competition.date) : new Date();
            
            // Get broadcast info and add to channels set
            const broadcasts = competition.broadcasts?.[0]?.names || [];
            if (broadcasts.length > 0) {
              broadcasts.forEach(broadcastName => {
                if (broadcastName && broadcastName.trim()) {
                  allChannels.add(broadcastName.trim());
                }
              });
            }
            
            // Use first competition as primary, or prefer one that's in progress
            if (!primaryCompetition || (status.type?.state === 'in' && primaryStatus?.type?.state !== 'in')) {
              primaryCompetition = competition;
              primaryStatus = status;
              
              // Calculate display time for primary competition
              const gameDateUTC = DateTime.fromJSDate(gameDate, { zone: 'utc' });
              const gameDateMountain = gameDateUTC.setZone('America/Denver');
              
              // Map ESPN status to your format
              let matchStatus = 'SCHEDULED';
              if (status.type?.state === 'in') matchStatus = 'IN PROGRESS';
              else if (status.type?.state === 'post') matchStatus = 'FINAL';
              
              const period = status.period || '';
              // ESPN API: For NFL/NCAAF, status.clock is seconds remaining in quarter (number)
              // status.displayClock might be wrong (shows 15:00 at quarter start)
              // Use status.clock (seconds) and convert to MM:SS format
              let displayClock = status.displayClock || '';
              
              // For NFL/NCAAF, prefer status.clock (seconds) over displayClock
              if (sport === 'football' && (leagueName === 'NFL' || leagueName === 'NCAAF')) {
                if (status.clock !== undefined && status.clock !== null) {
                  const clockSeconds = typeof status.clock === 'number' ? status.clock : parseInt(status.clock);
                  if (!isNaN(clockSeconds) && clockSeconds >= 0) {
                    const minutes = Math.floor(clockSeconds / 60);
                    const seconds = clockSeconds % 60;
                    displayClock = `${minutes}:${String(seconds).padStart(2, '0')}`;
                  }
                }
              }
              
              if (matchStatus === 'IN PROGRESS' && (period || displayClock)) {
                const periodNum = period ? parseInt(period) : null;
                const isZeroClock = (displayClock === '0.0' || displayClock === '0:00' || displayClock === '0' || displayClock === '');
                
                // Handle soccer time display (minutes with apostrophe, e.g., "76'")
                if (sport === 'soccer') {
                  let minutes = null;
                  
                  // ESPN API for soccer: displayClock shows TOTAL minutes elapsed in the game
                  // NOT minutes in current half - ESPN already calculates total time
                  // Period 1: 0-45+ minutes (total game time)
                  // Period 2: 45-90+ minutes (total game time)
                  
                  if (displayClock && displayClock.includes(':')) {
                    const [mins, secs] = displayClock.split(':').map(Number);
                    if (!isNaN(mins)) minutes = mins;
                  } else if (displayClock && !isNaN(parseInt(displayClock))) {
                    minutes = parseInt(displayClock);
                  }
                  
                  if (minutes === null && status.clock !== undefined && status.clock !== null) {
                    const clockValue = status.clock;
                    if (typeof clockValue === 'string' && clockValue.includes(':')) {
                      const [mins] = clockValue.split(':').map(Number);
                      if (!isNaN(mins)) minutes = mins;
                    } else if (typeof clockValue === 'number') {
                      // ESPN clock is total seconds - convert to minutes
                      minutes = Math.floor(clockValue / 60);
                    }
                  }
                  
                  let stoppageTime = null;
                  // Check for stoppage time in displayClock (e.g., "45+3", "90+5")
                  if (displayClock && (displayClock.includes('+') || displayClock.includes("'"))) {
                    const stoppageMatch = displayClock.match(/(\d+)[\'+]?\+(\d+)/);
                    if (stoppageMatch) {
                      minutes = parseInt(stoppageMatch[1]);
                      stoppageTime = parseInt(stoppageMatch[2]);
                    }
                  }
                  
                  if (stoppageTime === null && status.addedTime !== undefined && status.addedTime !== null) {
                    stoppageTime = parseInt(status.addedTime) || 0;
                  }
                  
                  if (minutes !== null) {
                    // ESPN displayClock is ALREADY total game time - don't add 45 for period 2
                    // Use minutes as-is
                    
                    if (stoppageTime !== null && stoppageTime > 0) {
                      primaryDisplayTime = `${minutes}'+${stoppageTime}`;
                    } else {
                      primaryDisplayTime = `${minutes}'`;
                    }
                  } else if (periodNum === 1 && isZeroClock) {
                    primaryDisplayTime = 'Half';
                  } else {
                    primaryDisplayTime = displayClock || period || '';
                  }
                } else {
                  // Non-soccer sports
                  const isFootballHalftime = (sport === 'football' && (leagueName === 'NFL' || leagueName === 'NCAAF') && periodNum === 2 && isZeroClock);
                  const isBasketballHalftime = (sport === 'basketball' && (leagueName === 'NBA' || leagueName === 'WNBA') && periodNum === 2 && isZeroClock);
                  const isNHLFirstIntermission = (sport === 'hockey' && leagueName === 'NHL' && periodNum === 1 && isZeroClock);
                  const isNHLSecondIntermission = (sport === 'hockey' && leagueName === 'NHL' && periodNum === 2 && isZeroClock);
                  
                  if (isFootballHalftime || isBasketballHalftime) {
                    primaryDisplayTime = 'Half';
                  } else if (isNHLFirstIntermission) {
                    primaryDisplayTime = '1st Int.';
                  } else if (isNHLSecondIntermission) {
                    primaryDisplayTime = '2nd Int.';
                  } else {
                    let periodStr = '';
                    if (period) {
                      const periodNum = parseInt(period);
                      if (!isNaN(periodNum)) {
                        if (periodNum === 1) periodStr = '1st';
                        else if (periodNum === 2) periodStr = '2nd';
                        else if (periodNum === 3) periodStr = '3rd';
                        else if (periodNum === 4) periodStr = '4th';
                        else if (periodNum > 4) periodStr = `${periodNum}th`;
                        else periodStr = period;
                      } else {
                        periodStr = period;
                      }
                    }
                    
                    if (periodStr && displayClock) {
                      primaryDisplayTime = `${periodStr} ${displayClock}`;
                    } else if (periodStr) {
                      primaryDisplayTime = periodStr;
                    } else if (displayClock) {
                      primaryDisplayTime = displayClock;
                    }
                  }
                }
              }
              
              // If not in progress, format start time for display
              if (!primaryDisplayTime) {
                primaryDisplayTime = gameDateMountain.toFormat('h:mm a');
              }
            }
          }
          
          // Now create ONE game entry using primary competition data
          if (!primaryCompetition) continue;
          
          const primaryCompetitors = primaryCompetition.competitors || [];
          const primaryAwayTeam = primaryCompetitors.find(c => c.homeAway === 'away');
          const primaryHomeTeam = primaryCompetitors.find(c => c.homeAway === 'home');
          
          if (!primaryAwayTeam || !primaryHomeTeam) continue;
          
          const primaryGameDate = primaryCompetition.date ? new Date(primaryCompetition.date) : new Date();
          const primaryGameDateUTC = DateTime.fromJSDate(primaryGameDate, { zone: 'utc' });
          const primaryGameDateMountain = primaryGameDateUTC.setZone('America/Denver');
          
          // Map ESPN status to your format
          let matchStatus = 'SCHEDULED';
          if (primaryStatus?.type?.state === 'in') matchStatus = 'IN PROGRESS';
          else if (primaryStatus?.type?.state === 'post') matchStatus = 'FINAL';
          
          // Combine all channels (use first one, or comma-separate if multiple)
          const channel = allChannels.size > 0 ? Array.from(allChannels)[0] : '';
          
          // Map sport to display name
          let sportDisplayName = 'Other';
          if (sport === 'football') {
            sportDisplayName = 'American Football';
          } else if (sport === 'basketball') {
            sportDisplayName = 'Basketball';
          } else if (sport === 'baseball') {
            sportDisplayName = 'Baseball';
          } else if (sport === 'hockey') {
            sportDisplayName = 'Hockey';
          } else if (sport === 'soccer') {
            sportDisplayName = 'Soccer';
          } else if (sport === 'tennis') {
            sportDisplayName = 'Tennis';
          } else if (sport === 'golf') {
            sportDisplayName = 'Golf';
          } else if (sport === 'racing') {
            sportDisplayName = 'Auto Racing';
          } else if (sport === 'mma') {
            sportDisplayName = 'MMA';
          } else if (sport === 'boxing') {
            sportDisplayName = 'Boxing';
          }
          
          // Use the displayTime we calculated for the primary competition
          const displayTime = primaryDisplayTime;
          const period = primaryStatus?.period || '';
          // Recalculate displayClock for NFL/NCAAF using status.clock (seconds) if available
          let displayClock = primaryStatus?.displayClock || '';
          
          // For NFL/NCAAF, prefer status.clock (seconds) over displayClock
          // ESPN's displayClock shows "15:00" at quarter start, but status.clock has actual seconds remaining
          if (sport === 'football' && (leagueName === 'NFL' || leagueName === 'NCAAF')) {
            if (primaryStatus?.clock !== undefined && primaryStatus?.clock !== null) {
              const clockSeconds = typeof primaryStatus.clock === 'number' ? primaryStatus.clock : parseInt(primaryStatus.clock);
              if (!isNaN(clockSeconds) && clockSeconds >= 0) {
                const minutes = Math.floor(clockSeconds / 60);
                const seconds = clockSeconds % 60;
                displayClock = `${minutes}:${String(seconds).padStart(2, '0')}`;
              }
            }
          }
          
          // Map ESPN league name to display name (matching what importGamesFromSheets uses)
          const leagueDisplayName = ESPN_LEAGUE_DISPLAY_NAME_MAP[leagueName] || leagueName;
          
          // Extract GameTime from displayClock for NFL/NCAAF (frontend fallback needs this)
          // displayClock format: "8:05" (MM:SS) for NFL
          let gameTime = '';
          if (matchStatus === 'IN PROGRESS' && displayClock && (leagueName === 'NFL' || leagueName === 'NCAAF')) {
            // displayClock is MM:SS format - use as-is for GameTime
            gameTime = displayClock;
          }
          
          // Get rankings for NCAAF teams
          let homeTeamRanking = null;
          let awayTeamRanking = null;
          if (leagueName === 'NCAAF') {
            homeTeamRanking = getTeamRanking(firstHomeTeamName, ncaafRankings);
            awayTeamRanking = getTeamRanking(firstAwayTeamName, ncaafRankings);
          }
          
          const gameData = {
            'League': leagueDisplayName, // Use display name for consistency with importGamesFromSheets
            'Sport': sportDisplayName,
            'Home Team': firstHomeTeamName,
            'Away Team': firstAwayTeamName,
            'Home Score': primaryHomeTeam.score || '',
            'Away Score': primaryAwayTeam.score || '',
            'Match Status': matchStatus,
            'Channel': channel,
            'channel': channel,
            'Start Time': admin.firestore.Timestamp.fromDate(primaryGameDate), // UTC timestamp from ESPN
            'gameDate': gameDateForStorage, // Use the date we're fetching (ensures all games for a date have the same gameDate)
            'Matchup': `${firstAwayTeamName} vs ${firstHomeTeamName}`,
            'Game ID': event.id 
              ? `espn-${league}-${event.id}`
              : generateDeterministicGameId('espn', leagueName, firstHomeTeamName, firstAwayTeamName, gameDateForStorage),
              // Canonical key used to match games across different writers (league|home|away|date)
              'canonicalGameKey': getGameKey(leagueDisplayName, firstHomeTeamName, firstAwayTeamName, gameDateForStorage),
            'Last Updated': admin.firestore.FieldValue.serverTimestamp(),
            'source': 'ESPN_LIVE', // Flag to identify ESPN live data
            'period': period,
            'displayClock': displayClock,
            'displayTime': displayTime, // Formatted time: period/clock when in progress, start time otherwise
            'GameTime': gameTime || null, // Set GameTime for NFL/NCAAF so frontend fallback works correctly
            'Stage': period ? `${period}${period === '1' ? 'ST' : period === '2' ? 'ND' : period === '3' ? 'RD' : 'TH'}_QUARTER` : '',
            'Home Team Ranking': homeTeamRanking,
            'Away Team Ranking': awayTeamRanking
          };
          
          // Debug logging for NFL games to see what ESPN is returning
          if (sport === 'football' && (leagueName === 'NFL' || leagueName === 'NCAAF')) {
            const gameId = event.id ? `espn-${league}-${event.id}` : 'unknown';
            console.log(`[ESPN NFL DEBUG] Game ID: ${gameId} | ${firstAwayTeamName} vs ${firstHomeTeamName}:`);
            console.log(`  Raw ESPN status object:`, JSON.stringify({
              displayClock: primaryStatus?.displayClock,
              clock: primaryStatus?.clock,
              period: primaryStatus?.period,
              type: primaryStatus?.type
            }, null, 2));
            console.log(`  Calculated displayClock: "${displayClock}"`);
            console.log(`  Calculated GameTime: "${gameTime || 'null'}"`);
            console.log(`  displayTime: "${displayTime}"`);
            console.log(`  period: ${period}`);
            console.log(`  matchStatus: ${matchStatus}`);
            console.log(`  Game will be written with GameTime: "${gameTime || 'null'}"`);
          }
          
            // Add the game (duplicate check already done at event level)
            allGames.push(gameData);
          }
          
          console.log(`[ESPN] ${leagueName} (${isoDate}): Found ${events.length} games`);
          
          // Small delay to avoid rate limiting
          await new Promise(resolve => setTimeout(resolve, 200));
          
        } catch (err) {
          console.error(`[ESPN] Error fetching ${leagueName} for ${isoDate}:`, err.message);
        }
      }
    }
    
    // Fetch NCAA API data for NCAAM and NCAAW
    // For NCAA API, we still check today + yesterday during polling (to catch games that became live)
    // Morning run checks all 7 days
    const datesForNCAA = isMorningRun 
      ? datesToFetch 
      : [
          { isoDate: yesterdayStr, espnDate: DateTime.fromISO(yesterdayStr).toFormat('yyyyMMdd') },
          datesToFetch[0] // Today
        ];
    
    console.log(`[NCAA API] Fetching NCAAM and NCAAW games for ${isMorningRun ? 'next 7 days' : 'today + yesterday'}...`);
    
    // Rankings already fetched above, reuse them
    // Fetch NCAAM for each date
    for (const dateInfo of datesForNCAA) {
      const { isoDate } = dateInfo;
      const ncaaDate = DateTime.fromISO(isoDate).toFormat('yyyy/MM/dd');
      console.log(`[NCAA API] Fetching NCAAM for ${isoDate}...`);
      
      try {
        const ncaamUrl = `https://ncaa-api.henrygd.me/scoreboard/basketball-men/d1/${ncaaDate}`;
        const ncaamResponse = await fetch(ncaamUrl, {
          headers: { 'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36' }
        });
        if (ncaamResponse.ok) {
          const ncaamData = await ncaamResponse.json();
          if (ncaamData.games && Array.isArray(ncaamData.games)) {
            for (const gameItem of ncaamData.games) {
              const game = gameItem.game;
              if (!game) continue;
              
              const awayTeam = game.away;
              const homeTeam = game.home;
              if (!awayTeam || !homeTeam) continue;
              
              const awayTeamName = awayTeam.names?.short || awayTeam.names?.full || awayTeam.names?.seo || '';
              const homeTeamName = homeTeam.names?.short || homeTeam.names?.full || homeTeam.names?.seo || '';
              if (!awayTeamName || !homeTeamName) continue;
              
              const awayScore = awayTeam.score || '';
              const homeScore = homeTeam.score || '';
              const gameState = (game.gameState || '').toUpperCase();
              const finalMessage = (game.finalMessage || '').toUpperCase();
              const currentPeriod = game.currentPeriod || '';
              const startTimeEpochSeconds = game.startTimeEpoch ? Number(game.startTimeEpoch) : null;
              const startTimeMillis = Number.isFinite(startTimeEpochSeconds) ? startTimeEpochSeconds * 1000 : null;
              
              // Get the game's actual start date by converting the start time from UTC to Eastern Time
              // NCAA API provides epoch seconds (UTC). Convert to Eastern Time, then extract the date
              if (!startTimeMillis) continue; // Skip if no start time
              const gameDateForStorage = DateTime
                .fromMillis(startTimeMillis, { zone: 'utc' })
                .setZone('America/New_York')
                .toISODate();
              
              // Convert the date we're fetching (Mountain Time) to Eastern Time for comparison
              // This ensures we only include games that match the date we're fetching
              const isoDateMountain = DateTime.fromISO(isoDate, { zone: 'America/Denver' });
              const isoDateEastern = isoDateMountain.setZone('America/New_York').toISODate();
              
              // Only include games that match the date we're fetching (after conversion to Eastern Time)
              // This prevents games from other dates from being stored with the wrong date
              if (gameDateForStorage !== isoDateEastern) {
                continue; // Skip games that don't match the date we're fetching
              }
              
              let matchStatus = 'SCHEDULED';
              if (finalMessage === 'FINAL' || gameState === 'FINAL') {
                matchStatus = 'FINAL';
              } else if (gameState.includes('LIVE') || gameState.includes('IN_PROGRESS') || homeScore > 0 || awayScore > 0) {
                if (!finalMessage.includes('FINAL') && !gameState.includes('FINAL')) {
                  matchStatus = 'IN PROGRESS';
                }
              }
            
            // Format display time: show period/clock when in progress, start time otherwise
            const contestClock = game.contestClock || '';
            let displayTime = '';
            
            // For NCAAM: halftime is at "1st 0.0", and "2nd 0.0" means finished (F)
            const periodNum = currentPeriod ? (parseInt(currentPeriod) || (currentPeriod.includes('1') ? 1 : (currentPeriod.includes('2') ? 2 : null))) : null;
            const isZeroClock = (contestClock === '0.0' || contestClock === '0:00' || contestClock === '0' || contestClock === '');
            
            // Check if NCAAM game is finished (2nd period with 0.0 clock)
            if (periodNum === 2 && isZeroClock) {
              matchStatus = 'FINAL';
              displayTime = 'F';
            } else if (matchStatus === 'IN PROGRESS' && (currentPeriod || contestClock)) {
              // Check for halftime (1st period with 0.0 or 0:00 clock) for NCAAM
              const isHalftime = (periodNum === 1 && isZeroClock);
              
              if (isHalftime) {
                displayTime = 'Half';
              } else {
                // currentPeriod might already be formatted (e.g., "2nd") or just a number
                let periodStr = currentPeriod || '';
                
                // If period is just a number, format it (e.g., "2" -> "2nd")
                if (periodStr && /^\d+$/.test(periodStr)) {
                  const periodNum = parseInt(periodStr);
                  if (periodNum === 1) periodStr = '1st';
                  else if (periodNum === 2) periodStr = '2nd';
                  else if (periodNum === 3) periodStr = '3rd';
                  else if (periodNum === 4) periodStr = '4th';
                  else if (periodNum > 4) periodStr = `${periodNum}th`;
                }
                
                // Combine period and clock (e.g., "2nd 8:03")
                if (periodStr && contestClock) {
                  displayTime = `${periodStr} ${contestClock}`;
                } else if (periodStr) {
                  displayTime = periodStr;
                } else if (contestClock) {
                  displayTime = contestClock;
                }
              }
            }
            
            // If not in progress and not final, format start time for display
            if (!displayTime && matchStatus !== 'FINAL' && startTimeMillis) {
              const startTimeMountain = DateTime.fromMillis(startTimeMillis).setZone('America/Denver');
              displayTime = startTimeMountain.toFormat('h:mm a');
            } else if (!displayTime && matchStatus === 'FINAL') {
              displayTime = 'F';
            } else if (!displayTime) {
              displayTime = '';
            }
            
            // Map NCAA league name to display name (matching what importGamesFromSheets uses)
            const leagueDisplayName = ESPN_LEAGUE_DISPLAY_NAME_MAP['NCAAM'] || 'USA: NCAA';
            
            // Get rankings for teams
            const homeTeamRanking = getTeamRanking(homeTeamName, ncaamRankings);
            const awayTeamRanking = getTeamRanking(awayTeamName, ncaamRankings);
            
            const gameData = {
              'League': leagueDisplayName, // Use display name for consistency with importGamesFromSheets
              'Sport': 'Basketball',
              'Home Team': homeTeamName,
              'Away Team': awayTeamName,
              'Home Score': homeScore.toString(),
              'Away Score': awayScore.toString(),
              'Match Status': matchStatus,
              'Channel': '', // Will be filled from Google Sheets
              'channel': '',
              'Start Time': startTimeMillis ? admin.firestore.Timestamp.fromMillis(startTimeMillis) : admin.firestore.Timestamp.now(),
              'gameDate': gameDateForStorage,
              'Matchup': `${awayTeamName} vs ${homeTeamName}`,
              'Game ID': game.id 
                ? `ncaa-ncaam-${game.id}`
                : generateDeterministicGameId('ncaa-ncaam', 'NCAAM', homeTeamName, awayTeamName, gameDateForStorage),
              'Last Updated': admin.firestore.FieldValue.serverTimestamp(),
              'source': 'NCAA_LIVE',
              'period': currentPeriod || '',
              'displayClock': contestClock,
              'Current Period': currentPeriod,
              'displayTime': displayTime, // Formatted time: period/clock when in progress, start time otherwise
              'Home Team Ranking': homeTeamRanking,
              'Away Team Ranking': awayTeamRanking
            };
            
            // Check for duplicates before adding
            const gameKey = getGameKey('NCAAM', homeTeamName, awayTeamName, gameDateForStorage);
            if (!uniqueGames.has(gameKey)) {
              uniqueGames.add(gameKey);
              allGames.push(gameData);
            } else {
              console.log(`[NCAA API] Skipping duplicate NCAAM game: ${awayTeamName} vs ${homeTeamName} on ${gameDateForStorage}`);
            }
          }
            console.log(`[NCAA API] NCAAM (${isoDate}): Found ${ncaamData.games.length} games`);
          }
        }
      } catch (err) {
        console.error(`[NCAA API] Error fetching NCAAM for ${isoDate}:`, err.message);
      }
    }
    
    // Fetch NCAAW for each date
    for (const dateInfo of datesForNCAA) {
      const { isoDate } = dateInfo;
      const ncaaDate = DateTime.fromISO(isoDate).toFormat('yyyy/MM/dd');
      console.log(`[NCAA API] Fetching NCAAW for ${isoDate}...`);
      
      try {
        const ncaawUrl = `https://ncaa-api.henrygd.me/scoreboard/basketball-women/d1/${ncaaDate}`;
        const ncaawResponse = await fetch(ncaawUrl, {
          headers: { 'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36' }
        });
        if (ncaawResponse.ok) {
          const ncaawData = await ncaawResponse.json();
          if (ncaawData.games && Array.isArray(ncaawData.games)) {
            for (const gameItem of ncaawData.games) {
              const game = gameItem.game;
              if (!game) continue;
              
              const awayTeam = game.away;
              const homeTeam = game.home;
              if (!awayTeam || !homeTeam) continue;
              
              const awayTeamName = awayTeam.names?.short || awayTeam.names?.full || awayTeam.names?.seo || '';
              const homeTeamName = homeTeam.names?.short || homeTeam.names?.full || homeTeam.names?.seo || '';
              if (!awayTeamName || !homeTeamName) continue;
              
              const awayScore = awayTeam.score || '';
              const homeScore = homeTeam.score || '';
              const gameState = (game.gameState || '').toUpperCase();
              const finalMessage = (game.finalMessage || '').toUpperCase();
              const currentPeriod = game.currentPeriod || '';
              const startTimeEpochSeconds = game.startTimeEpoch ? Number(game.startTimeEpoch) : null;
              const startTimeMillis = Number.isFinite(startTimeEpochSeconds) ? startTimeEpochSeconds * 1000 : null;
              
              // Get the game's actual start date by converting the start time from UTC to Eastern Time
              // NCAA API provides epoch seconds (UTC). Convert to Eastern Time, then extract the date
              if (!startTimeMillis) continue; // Skip if no start time
              const gameDateForStorage = DateTime
                .fromMillis(startTimeMillis, { zone: 'utc' })
                .setZone('America/New_York')
                .toISODate();
              
              // Convert the date we're fetching (Mountain Time) to Eastern Time for comparison
              // This ensures we only include games that match the date we're fetching
              const isoDateMountain = DateTime.fromISO(isoDate, { zone: 'America/Denver' });
              const isoDateEastern = isoDateMountain.setZone('America/New_York').toISODate();
              
              // Only include games that match the date we're fetching (after conversion to Eastern Time)
              // This prevents games from other dates from being stored with the wrong date
              if (gameDateForStorage !== isoDateEastern) {
                continue; // Skip games that don't match the date we're fetching
              }
              
              let matchStatus = 'SCHEDULED';
              if (finalMessage === 'FINAL' || gameState === 'FINAL') {
                matchStatus = 'FINAL';
              } else if (gameState.includes('LIVE') || gameState.includes('IN_PROGRESS') || homeScore > 0 || awayScore > 0) {
                if (!finalMessage.includes('FINAL') && !gameState.includes('FINAL')) {
                  matchStatus = 'IN PROGRESS';
                }
              }
            
            // Format display time: show period/clock when in progress, start time otherwise
            const contestClock = game.contestClock || '';
            let displayTime = '';
            
            if (matchStatus === 'IN PROGRESS' && (currentPeriod || contestClock)) {
              // Check for halftime (2nd period with 0.0 or 0:00 clock)
              const periodNum = currentPeriod ? (parseInt(currentPeriod) || (currentPeriod.includes('2') ? 2 : null)) : null;
              const isHalftime = (periodNum === 2 && 
                                  (contestClock === '0.0' || contestClock === '0:00' || contestClock === '0' || contestClock === ''));
              
              if (isHalftime) {
                displayTime = 'Half';
              } else {
                // currentPeriod might already be formatted (e.g., "2nd") or just a number
                let periodStr = currentPeriod || '';
                
                // If period is just a number, format it (e.g., "2" -> "2nd")
                if (periodStr && /^\d+$/.test(periodStr)) {
                  const periodNum = parseInt(periodStr);
                  if (periodNum === 1) periodStr = '1st';
                  else if (periodNum === 2) periodStr = '2nd';
                  else if (periodNum === 3) periodStr = '3rd';
                  else if (periodNum === 4) periodStr = '4th';
                  else if (periodNum > 4) periodStr = `${periodNum}th`;
                }
                
                // Combine period and clock (e.g., "2nd 8:03")
                if (periodStr && contestClock) {
                  displayTime = `${periodStr} ${contestClock}`;
                } else if (periodStr) {
                  displayTime = periodStr;
                } else if (contestClock) {
                  displayTime = contestClock;
                }
              }
            }
            
            // If not in progress, format start time for display
            if (!displayTime && startTimeMillis) {
              const startTimeMountain = DateTime.fromMillis(startTimeMillis).setZone('America/Denver');
              displayTime = startTimeMountain.toFormat('h:mm a');
            } else if (!displayTime) {
              displayTime = '';
            }
            
            // Map NCAA league name to display name (matching what importGamesFromSheets uses)
            const leagueDisplayName = ESPN_LEAGUE_DISPLAY_NAME_MAP['NCAAW'] || 'USA: NCAA Women';
            
            // Get rankings for teams
            const homeTeamRanking = getTeamRanking(homeTeamName, ncaawRankings);
            const awayTeamRanking = getTeamRanking(awayTeamName, ncaawRankings);
            
            const gameData = {
              'League': leagueDisplayName, // Use display name for consistency with importGamesFromSheets
              'Sport': 'Basketball',
              'Home Team': homeTeamName,
              'Away Team': awayTeamName,
              'Home Score': homeScore.toString(),
              'Away Score': awayScore.toString(),
              'Match Status': matchStatus,
              'Channel': '', // Will be filled from Google Sheets
              'channel': '',
              'Start Time': startTimeMillis ? admin.firestore.Timestamp.fromMillis(startTimeMillis) : admin.firestore.Timestamp.now(),
              'gameDate': gameDateForStorage,
              'Matchup': `${awayTeamName} vs ${homeTeamName}`,
              'Game ID': game.id 
                ? `ncaa-ncaaw-${game.id}`
                : generateDeterministicGameId('ncaa-ncaaw', 'NCAAW', homeTeamName, awayTeamName, gameDateForStorage),
              'Last Updated': admin.firestore.FieldValue.serverTimestamp(),
              'source': 'NCAA_LIVE',
              'period': currentPeriod || '',
              'displayClock': contestClock,
              'Current Period': currentPeriod,
              'displayTime': displayTime, // Formatted time: period/clock when in progress, start time otherwise
              'Home Team Ranking': homeTeamRanking,
              'Away Team Ranking': awayTeamRanking
            };
            
              // Check for duplicates before adding
              const gameKey = getGameKey('NCAAW', homeTeamName, awayTeamName, gameDateForStorage);
              if (!uniqueGames.has(gameKey)) {
                uniqueGames.add(gameKey);
                allGames.push(gameData);
              } else {
                console.log(`[NCAA API] Skipping duplicate NCAAW game: ${awayTeamName} vs ${homeTeamName} on ${gameDateForStorage}`);
              }
            }
            console.log(`[NCAA API] NCAAW (${isoDate}): Found ${ncaawData.games.length} games`);
          }
        }
      } catch (err) {
        console.error(`[NCAA API] Error fetching NCAAW for ${isoDate}:`, err.message);
      }
    }
    
    console.log(`[ESPN Live Data] Total games fetched: ${allGames.length}`);
    
    // Fetch channel data from Google Sheets and override ESPN/NCAA channel data
    console.log('[Channel Lookup] Fetching channel data from Google Sheets...');
    await authenticateGoogleSheets();
    
    // League to sheet mapping (from importGamesFromSheets)
    const LEAGUE_SHEET_MAP = {
      'NFL': { sheetId: SHEET_ID, sheetName: 'NFL' },
      'NBA': { sheetId: SHEET_ID, sheetName: 'NBA' },
      'MLB': { sheetId: SHEET_ID, sheetName: 'MLB' },
      'Premier League': { sheetId: SHEET_ID, sheetName: 'PremierLeague' },
      'MLS': { sheetId: SHEET_ID, sheetName: 'MLS' },
      'La Liga': { sheetId: SHEET_ID, sheetName: 'LaLiga' },
      'Bundesliga': { sheetId: SHEET_ID, sheetName: 'Bundesliga' },
      'Serie A': { sheetId: SHEET_ID, sheetName: 'SerieA' },
      'Ligue 1': { sheetId: SHEET_ID, sheetName: 'Ligue1' },
      'UEFA Champions League': { sheetId: SHEET_ID, sheetName: 'UEFAChampionsLeague' },
      'UEFA Europa League': { sheetId: SHEET_ID, sheetName: 'UEFAEuropaLeague' },
      'UEFA Conference League': { sheetId: SHEET_ID, sheetName: 'UEFAConferenceLeague' },
      'NCAAF': { sheetId: SHEET_ID, sheetName: 'NCAAF' },
      'NHL': { sheetId: SHEET_ID, sheetName: 'NHL' },
      'WNBA': { sheetId: SHEET_ID, sheetName: 'WNBA' },
      'NCAAM': { sheetId: SHEET_ID_3, sheetName: 'NCAAM' },
      'NCAAW': { sheetId: SHEET_ID_3, sheetName: 'NCAAW' }
    };
    
    // Normalize team name for matching
    function normalizeTeamName(name) {
      if (!name) return '';
      return name
        .toLowerCase()
        .normalize('NFD')
        .replace(/[\u0300-\u036f]/g, '')
        .replace(/[^\w\s]/g, '')
        .replace(/\s+/g, ' ')
        .trim();
    }
    
    // Build channel map from Google Sheets
    const channelMap = new Map(); // Key: "league|normalizedHome|normalizedAway|date", Value: channel
    
    // Exclude NCAAF, NCAAM, NCAAW from channel lookup since they're fetched from ESPN/NCAA APIs
    const LEAGUES_TO_EXCLUDE_FROM_CHANNEL_LOOKUP = ['NCAAF', 'NCAAM', 'NCAAW'];
    
    for (const [leagueName, sheetInfo] of Object.entries(LEAGUE_SHEET_MAP)) {
      // Skip leagues that are fetched from APIs to avoid duplicates
      if (LEAGUES_TO_EXCLUDE_FROM_CHANNEL_LOOKUP.includes(leagueName)) {
        continue;
      }
      try {
        // Rate limiting is now handled via rateLimitedSheetRequest
        const range = `${sheetInfo.sheetName}!A:Z`;
        const response = await rateLimitedSheetRequest(() =>
          sheets.spreadsheets.values.get({
            spreadsheetId: sheetInfo.sheetId,
            range: range
          })
        );
        
        const rows = response.data.values || [];
        if (rows.length < 2) continue; // Need at least header + 1 row
        
        // Find column indices
        const headerRow = rows[0];
        const dateCol = headerRow.findIndex(col => col && col.toString().toLowerCase().includes('date'));
        const timeCol = headerRow.findIndex(col => col && col.toString().toLowerCase().includes('time'));
        const homeCol = headerRow.findIndex(col => col && col.toString().toLowerCase().includes('home') && col.toString().toLowerCase().includes('team'));
        const awayCol = headerRow.findIndex(col => col && col.toString().toLowerCase().includes('away') && col.toString().toLowerCase().includes('team'));
        const channelCol = headerRow.findIndex(col => col && col.toString().toLowerCase().includes('channel'));
        
        if (dateCol === -1 || homeCol === -1 || awayCol === -1 || channelCol === -1) continue;
        
        // Process rows
        for (let i = 1; i < rows.length; i++) {
          const row = rows[i];
          if (!row || row.length === 0) continue;
          
          const dateStr = row[dateCol] ? String(row[dateCol]).trim() : '';
          const homeTeam = row[homeCol] ? String(row[homeCol]).trim() : '';
          const awayTeam = row[awayCol] ? String(row[awayCol]).trim() : '';
          const channel = row[channelCol] ? String(row[channelCol]).trim() : '';
          
          if (!dateStr || !homeTeam || !awayTeam || !channel) continue;
          
          // Parse date - handle various formats
          let parsedDate = null;
          if (dateStr.includes('/')) {
            // Format: MM/DD/YYYY or M/D/YYYY
            const parts = dateStr.split('/');
            if (parts.length === 3) {
              const month = parseInt(parts[0], 10);
              const day = parseInt(parts[1], 10);
              const year = parseInt(parts[2], 10);
              if (month && day && year) {
                parsedDate = DateTime.fromObject({ year, month, day }, { zone: 'America/Denver' });
              }
            }
          } else if (dateStr.match(/^\d{4}-\d{2}-\d{2}$/)) {
            // Format: YYYY-MM-DD
            parsedDate = DateTime.fromISO(dateStr, { zone: 'America/Denver' });
          }
          
          if (!parsedDate || !parsedDate.isValid) continue;
          const rowDateStr = parsedDate.toISODate();
          
          // Only process rows matching today's date
          if (rowDateStr !== todayStr) continue;
          
          const normalizedHome = normalizeTeamName(homeTeam);
          const normalizedAway = normalizeTeamName(awayTeam);
          
          // Create keys for both possible orders (home/away and away/home)
          const key1 = `${leagueName}|${normalizedHome}|${normalizedAway}|${rowDateStr}`;
          const key2 = `${leagueName}|${normalizedAway}|${normalizedHome}|${rowDateStr}`;
          channelMap.set(key1, channel);
          channelMap.set(key2, channel);
        }
        
        console.log(`[Channel Lookup] Processed ${sheetInfo.sheetName} sheet`);
      } catch (err) {
        console.error(`[Channel Lookup] Error processing ${leagueName}:`, err.message);
      }
    }
    
    console.log(`[Channel Lookup] Built channel map with ${channelMap.size} entries`);
    
    // Override channel data in games with Google Sheets data
    let channelOverrideCount = 0;
    for (const game of allGames) {
      const league = game.League || '';
      const homeTeam = game['Home Team'] || '';
      const awayTeam = game['Away Team'] || '';
      const normalizedHome = normalizeTeamName(homeTeam);
      const normalizedAway = normalizeTeamName(awayTeam);
      
      // Try to find channel in map
      const key = `${league}|${normalizedHome}|${normalizedAway}|${todayStr}`;
      const sheetChannel = channelMap.get(key);
      
      if (sheetChannel) {
        game.Channel = sheetChannel;
        game.channel = sheetChannel;
        channelOverrideCount++;
      }
      // If not found, keep ESPN/NCAA channel data (already set above)
    }
    
    console.log(`[Channel Lookup] Overrode ${channelOverrideCount} games with Google Sheets channel data`);
    
    // Step 3: On morning run, also import Google Sheets games (excluding ESPN/NCAA leagues) to sportsGames
    if (isMorningRun) {
      console.log('[ESPN Live Data] Morning run - importing Google Sheets games (excluding ESPN/NCAA leagues)...');
      const manualGames = await fetchManualGamesFromSheets(todayStr, tomorrowStr);
      // Add manual games to allGames (they're already filtered to exclude ESPN/NCAA leagues)
      allGames.push(...manualGames);
      console.log(`[ESPN Live Data] Added ${manualGames.length} manual games from Google Sheets to sportsGames`);
    }
    
    // Log total games fetched
    console.log(`[ESPN Live Data] Total games fetched: ${allGames.length} (ESPN/NCAA: ${allGames.length - (isMorningRun ? (allGames.filter(g => g.source === 'MANUAL').length) : 0)}, Manual: ${isMorningRun ? allGames.filter(g => g.source === 'MANUAL').length : 0})`);
    
    if (allGames.length === 0) {
      console.warn(`[ESPN Live Data] ‚ö†Ô∏è WARNING: No games fetched! Collection will not be created.`);
      if (res) {
        return res.status(200).json({
          success: true,
          message: 'No games found for today',
          gamesFetched: 0,
          gamesWritten: 0
        });
      }
      return;
    }
    
    // Step 4: Filter games based on run type
    // Get existing games to check their status (only for today during polling)
    const existingGamesSnapshot = await gamesRef.where('gameDate', '==', todayStr).get();
    const existingGamesMap = new Map();
    existingGamesSnapshot.forEach(doc => {
      const data = doc.data();
      const gameId = data['Game ID'] || doc.id;
      existingGamesMap.set(gameId, data);
    });
    
    // Filter games based on run type:
    // - Morning run: include all games (scheduled + in progress + final) for all 7 days
    // - Polling run: include games that are IN PROGRESS or FINAL (to update scores and finalize games)
    //   Also include scheduled games for today that might have just started (to discover new live games)
    const gamesToUpdate = isMorningRun 
      ? allGames // Morning run: include all games for all 7 days
      : allGames.filter(game => {
          const matchStatus = (game['Match Status'] || '').toUpperCase();
          const gameDate = game.gameDate || todayStr;
          
          // Always include FINAL games (to update final scores and ensure they're marked final)
          const isFinal = matchStatus.includes('FINAL') || matchStatus.includes('FINISHED');
          if (isFinal && (gameDate === todayStr || gameDate === yesterdayStr)) {
            return true;
          }
          
          // Include games that are IN PROGRESS
          const isLive = matchStatus.includes('IN PROGRESS') || 
                         matchStatus.includes('LIVE') ||
                         (game.StageType || '').toUpperCase().includes('LIVE') ||
                         (game.Stage || '').toUpperCase().includes('LIVE');
          
          if (isLive) return true;
          
          // Include games that appear to be live (has active clock, scores, etc.)
          const hasClock = game.displayClock || game.displayTime || game.GameTime;
          const hasActiveClock = hasClock && !['0', '0:00', '0.0', 'NULL', ''].includes(String(hasClock).trim().toUpperCase());
          const hasScores = (game['Home Score'] && parseInt(game['Home Score']) > 0) || 
                           (game['Away Score'] && parseInt(game['Away Score']) > 0);
          
          // Include if appears to be live (has clock/scores but not FINAL) for today or yesterday
          if ((hasActiveClock || hasScores) && !isFinal && (gameDate === todayStr || gameDate === yesterdayStr)) {
            return true;
          }
          
          // Skip scheduled games and other non-live games during polling
          return false;
        });
    
    console.log(`[ESPN Live Data] ${isMorningRun ? 'Morning run' : 'Polling run'}: ${gamesToUpdate.length} games to update (${allGames.length - gamesToUpdate.length} finished games skipped)`);
    
    if (gamesToUpdate.length === 0) {
      console.warn(`[ESPN Live Data] ‚ö†Ô∏è WARNING: No games to update! Collection will not be created.`);
      if (res) {
        return res.status(200).json({
          success: true,
          message: 'No games to update',
          gamesFetched: allGames.length,
          gamesWritten: 0
        });
      }
      return;
    }
    
    // Incremental write logic: only write additions, changes, and deletions
    // Get existing games for the dates we're actually fetching (varies by run type)
    const datesToCheckForDeletions = leaguesAndDatesToFetch.map(d => d.isoDate);
    console.log(`[ESPN Live Data] Checking for deletions in dates: ${datesToCheckForDeletions.join(', ')}`);
    
    const existingGamesForDates = new Map();
    for (const dateStr of datesToCheckForDeletions) {
      const dateSnapshot = await gamesRef.where('gameDate', '==', dateStr).get();
      dateSnapshot.forEach(doc => {
        const data = doc.data();
        const gameId = data['Game ID'] || doc.id;
        existingGamesForDates.set(gameId, { docId: doc.id, data: data });
      });
    }
    
    console.log(`[ESPN Live Data] Found ${existingGamesForDates.size} existing games in database for dates being fetched`);
    
    // Create a map of fetched games by Game ID and a canonical map by canonicalGameKey
    const fetchedGamesMap = new Map();
    const fetchedCanonicalMap = new Map();
    for (const game of gamesToUpdate) {
      if (game['Game ID']) {
        fetchedGamesMap.set(String(game['Game ID']), game);
      }
      const canonical = game['canonicalGameKey'] || '';
      if (canonical) {
        fetchedCanonicalMap.set(canonical, String(game['Game ID'] || ''));
      }
    }
    
    // Determine what to write/delete
    const gamesToWrite = [];
    const gamesToDelete = [];
    
    // Build a canonical lookup for existing games (canonicalKey -> {docId, gameId})
    const existingCanonicalMap = new Map();
    for (const [gameId, existing] of existingGamesForDates.entries()) {
      const canonical = existing.data && existing.data.canonicalGameKey ? existing.data.canonicalGameKey : '';
      if (canonical) existingCanonicalMap.set(canonical, { docId: existing.docId, gameId });
    }

    // Find games to write (new or changed) ‚Äî try exact Game ID first, then canonical key
    for (const game of gamesToUpdate) {
      if (!game['Game ID']) {
        console.warn(`[ESPN Live Data] Skipping game without Game ID:`, game['Matchup'] || 'Unknown');
        continue;
      }

      const gameId = String(game['Game ID']);
      let existing = existingGamesForDates.get(gameId);

      // If we don't have an exact Game ID match, try canonical key match
      if (!existing) {
        const canonical = game['canonicalGameKey'] || '';
        if (canonical && existingCanonicalMap.has(canonical)) {
          const match = existingCanonicalMap.get(canonical);
          existing = existingGamesForDates.get(match.gameId);
          // Ensure the fetched game will update the same Game ID/document
          if (match && match.gameId) {
            game['Game ID'] = match.gameId;
          }
          gamesToWrite.push({ game, reason: 'mergedByCanonical' });
          continue;
        }
      }

      if (!existing) {
        // New game - write it
        gamesToWrite.push({ game, reason: 'new' });
        continue;
      }

      // Existing game - check if changed
      const existingData = existing.data;
      const existingGameDate = existingData['gameDate'];
      const newGameDate = game['gameDate'];
        // Always use the earlier gameDate (preserve existing if earlier, or use new if earlier)
        // This prevents games from being moved to later dates when they appear on multiple scoreboards
        // and corrects games that were stored with dates that are too late
        if (existingGameDate && newGameDate) {
          game['gameDate'] = existingGameDate < newGameDate ? existingGameDate : newGameDate;
        }
        
        // Detect live status using multiple heuristics (status, StageType, Stage, displayClock)
        const fetchedRawStatus = String(game['Match Status'] || '').toUpperCase();
        const fetchedRawStageType = String(game.StageType || '').toUpperCase();
        const fetchedRawStage = String(game.Stage || '').toUpperCase();
        const fetchedDisplayClock = (game.displayClock || game.displayTime || game.GameTime || '') + '';
        const hasFetchedDisplayClock = fetchedDisplayClock && !['0', '0:00', '0.0', 'NULL', ''].includes(fetchedDisplayClock.toString().trim().toUpperCase());

        const isFetchedLive = (
          fetchedRawStatus.includes('IN PROGRESS') ||
          fetchedRawStatus.includes('LIVE') ||
          fetchedRawStageType.includes('LIVE') ||
          fetchedRawStageType.includes('IN PROGRESS') ||
          /FIRST|SECOND|HALF|IN_PROGRESS|ONGOING|PLAY/.test(fetchedRawStage) ||
          hasFetchedDisplayClock
        );

        // Consider these fields when deciding whether a game changed
        const changedFields = (
          existingData['Home Score'] !== game['Home Score'] ||
          existingData['Away Score'] !== game['Away Score'] ||
          existingData['Match Status'] !== game['Match Status'] ||
          existingData['Channel'] !== game['Channel'] ||
          existingData['displayClock'] !== game['displayClock'] ||
          existingData['displayTime'] !== game['displayTime'] ||
          existingData['GameTime'] !== game['GameTime'] ||
          existingData['period'] !== game['period'] ||
          existingData['Stage'] !== game['Stage'] ||
          existingData['Start Time']?.toMillis() !== game['Start Time']?.toMillis() ||
          existingData['gameDate'] !== game['gameDate']
        );

        // If the fetched game is live, force an update so listeners get a heartbeat even if data appears identical
        if (changedFields || isFetchedLive) {
          const reason = isFetchedLive && !changedFields ? 'live' : (changedFields ? 'changed' : 'changed');
          gamesToWrite.push({ game, reason });
        }
        // If unchanged, skip it (no write needed)
      }
    
    // Find games to delete (exist in DB but not in fetched data)
    for (const [gameId, existing] of existingGamesForDates.entries()) {
      const canonical = existing.data && existing.data.canonicalGameKey ? existing.data.canonicalGameKey : '';
      // If fetchedGamesMap doesn't have this gameId and canonical isn't present in fetchedCanonicalMap, consider delete
      const presentById = fetchedGamesMap.has(gameId);
      const presentByCanonical = canonical && fetchedCanonicalMap.has(canonical);

      if (!presentById && !presentByCanonical) {
        // During polling runs, preserve FINAL and SCHEDULED games (don't delete them even if not fetched)
        if (!isMorningRun) {
          const existingStatus = (existing.data['Match Status'] || '').toUpperCase();
          const isExistingFinal = existingStatus.includes('FINAL') || existingStatus.includes('FINISHED') || existingStatus.includes('GAME OVER');
          const isExistingScheduled = !isExistingFinal && !existingStatus.includes('IN PROGRESS') && !existingStatus.includes('LIVE');

          if (isExistingFinal || isExistingScheduled) {
            continue; // Skip deletion of FINAL and SCHEDULED games during polling runs
          }
        }

        // Game exists in DB but not in fetched data - delete it
        gamesToDelete.push({ docId: existing.docId, gameId, gameDate: existing.data.gameDate });
      }
    }
    
    const skipCount = existingGamesForDates.size - gamesToWrite.length - gamesToDelete.length; // Unchanged games
    console.log(`[ESPN Live Data] Incremental update: ${gamesToWrite.length} to write (${gamesToWrite.filter(g => g.reason === 'new').length} new, ${gamesToWrite.filter(g => g.reason === 'changed').length} changed), ${gamesToDelete.length} to delete, ${skipCount} unchanged`);
    
    // Write additions and changes
    let writeCount = 0;
    let deleteCount = 0;
    const BATCH_SIZE = 500;
    // DRY_RUN disabled intentionally during debugging/deployment: force real writes
    const isDryRun = false;
    
    // Write games in batches
    for (let i = 0; i < gamesToWrite.length; i += BATCH_SIZE) {
      const batch = db.batch();
      const batchGames = gamesToWrite.slice(i, i + BATCH_SIZE);
      
      for (const { game } of batchGames) {
        const docRef = gamesRef.doc(String(game['Game ID']));
        batch.set(docRef, game, { merge: true });
      }
      
      if (batchGames.length > 0) {
        try {
          if (isDryRun) {
            writeCount += batchGames.length;
            console.log(`[ESPN Live Data] [DRY RUN] Would commit write batch: ${batchGames.length} games (total would-write: ${writeCount})`);
          } else {
            await batch.commit();
            writeCount += batchGames.length;
            console.log(`[ESPN Live Data] ‚úÖ Committed write batch: ${batchGames.length} games (total written: ${writeCount})`);
          }
        } catch (err) {
          console.error(`[ESPN Live Data] ‚ùå Batch commit failed:`, err.message);
          throw err;
        }
      }
    }
    
    // Delete games that no longer exist in fetched data
    for (let i = 0; i < gamesToDelete.length; i += BATCH_SIZE) {
      const batch = db.batch();
      const batchDeletes = gamesToDelete.slice(i, i + BATCH_SIZE);
      
      for (const { docId } of batchDeletes) {
        const docRef = gamesRef.doc(docId);
        batch.delete(docRef);
      }
      
      if (batchDeletes.length > 0) {
        try {
          if (isDryRun) {
            deleteCount += batchDeletes.length;
            console.log(`[ESPN Live Data] [DRY RUN] Would commit delete batch: ${batchDeletes.length} games (total would-delete: ${deleteCount})`);
          } else {
            await batch.commit();
            deleteCount += batchDeletes.length;
            console.log(`[ESPN Live Data] ‚úÖ Committed delete batch: ${batchDeletes.length} games (total deleted: ${deleteCount})`);
          }
        } catch (err) {
          console.error(`[ESPN Live Data] ‚ùå Delete batch commit failed:`, err.message);
          throw err;
        }
      }
    }
    
    if (writeCount > 0 || deleteCount > 0) {
      console.log(`[ESPN Live Data] ‚úÖ Incremental update complete: ${writeCount} games written, ${deleteCount} games deleted`);
    } else {
      console.log(`[ESPN Live Data] ‚úÖ No changes detected - all games up to date`);
    }
    
    if (res) {
      res.status(200).json({
        success: true,
        message: 'ESPN live data polling complete',
        gamesFetched: allGames.length,
        gamesWritten: writeCount,
        gamesSkipped: skipCount
      });
    }
    
  } catch (err) {
    console.error('--- /pollESPNLiveData FAILED ---', err);
    if (res) {
      res.status(500).json({
        success: false,
        error: err.message
      });
    }
  }
};

app.post('/pollESPNLiveData', pollESPNLiveDataHandler);
app.get('/pollESPNLiveData', pollESPNLiveDataHandler);




// New endpoint for fetching weekly games
app.get('/fetchUpcomingGames', fetchUpcomingGamesHandler);
app.post('/fetchUpcomingGames', fetchUpcomingGamesHandler);




// Morning Refresh Handler - runs all scripts
const morningRefreshHandler = async (req, res) => {
  const executionId = `morning-${Date.now()}`;
  console.log(`\n${'='.repeat(70)}`);
  console.log(`üöÄ [${executionId}] Morning Refresh Started`);
  console.log(`‚è∞ Time: ${new Date().toISOString()}`);
  console.log('='.repeat(70));
  
  try {
    const results = { success: [], failed: [], startTime: new Date() };
    const { exec } = await import('child_process');
    const { promisify } = await import('util');
    const { fileURLToPath } = await import('url');
    const { dirname, join } = await import('path');
    const execPromise = promisify(exec);
    
    // Get the directory where index.js is located
    const __filename = fileURLToPath(import.meta.url);
    const __dirname = dirname(__filename);
    console.log(`üìÅ Working directory: ${__dirname}`);
    
    // 1. Run pollESPNLiveData first (morning mode)
    console.log('\nüîÑ [1/4] Running ESPN Live Data polling (morning mode)...');
    console.log('-'.repeat(70));
    try {
      const mockRes = {
        status: () => ({
          json: (data) => {
            console.log('üìä ESPN Live Data response:', JSON.stringify(data, null, 2));
          }
        })
      };
      await pollESPNLiveDataHandler({ query: { morning: 'true' } }, mockRes);
      results.success.push({ script: 'ESPN Live Data', details: 'Completed successfully' });
      console.log('‚úÖ [1/4] ESPN Live Data completed');
    } catch (error) {
      console.error('‚ùå [1/4] ESPN Live Data failed:', error.message);
      console.error('Stack:', error.stack);
      results.failed.push({ script: 'ESPN Live Data', error: error.message, stack: error.stack });
    }
    
    // 2. Import featured games from sheets
    console.log('\nüìã [2/4] Importing featured games from sheets...');
    console.log('-'.repeat(70));
    try {
      const scriptPath = join(__dirname, 'import-featured-from-sheets.cjs');
      console.log(`üìù Running: node ${scriptPath}`);
      const { stdout, stderr } = await execPromise(`node "${scriptPath}"`, {
        cwd: __dirname,
        maxBuffer: 10 * 1024 * 1024 // 10MB buffer
      });
      if (stderr && !stderr.includes('warning')) {
        console.error('‚ö†Ô∏è Featured stderr:', stderr);
      }
      if (stdout) {
        console.log('üìÑ Featured stdout:', stdout.substring(0, 1000)); // Limit output
      }
      results.success.push({ script: 'Featured Games Import', details: stdout || 'Completed' });
      console.log('‚úÖ [2/4] Featured games import completed');
    } catch (error) {
      console.error('‚ùå [2/4] Featured games import failed:', error.message);
      console.error('Stack:', error.stack);
      if (error.stdout) console.error('stdout:', error.stdout);
      if (error.stderr) console.error('stderr:', error.stderr);
      results.failed.push({ script: 'Featured Games', error: error.message, stdout: error.stdout, stderr: error.stderr });
    }
    
    // Note: stats scrapers and standings were moved to a separate script
    console.log('\nüì¶ Skipping stats scrapers and standings in this morning refresh (moved to stats-standings.cjs)');
    results.success.push({ script: 'Stats+Standings', details: 'Skipped (handled by stats-standings.cjs)' });
    
    // 1. Run pollESPNLiveData first (morning mode)
    console.log('\nüîÑ [1/4] Running ESPN Live Data polling (morning mode)...');
    console.log('-'.repeat(70));
    try {
      const mockRes = {
        status: () => ({
          json: (data) => {
            console.log('üìä ESPN Live Data response:', JSON.stringify(data, null, 2));
          }
        })
      };
      await pollESPNLiveDataHandler({ query: { morning: 'true' } }, mockRes);
      results.success.push({ script: 'ESPN Live Data', details: 'Completed successfully' });
      console.log('‚úÖ [1/4] ESPN Live Data completed');
    } catch (error) {
      console.error('‚ùå [1/4] ESPN Live Data failed:', error.message);
      console.error('Stack:', error.stack);
      results.failed.push({ script: 'ESPN Live Data', error: error.message, stack: error.stack });
    }
    
    // 2. Import featured games from sheets
    console.log('\nüìã [2/4] Importing featured games from sheets...');
    console.log('-'.repeat(70));
    try {
      const scriptPath = join(__dirname, 'import-featured-from-sheets.cjs');
      console.log(`üìù Running: node ${scriptPath}`);
      const { stdout, stderr } = await execPromise(`node "${scriptPath}"`, {
        cwd: __dirname,
        maxBuffer: 10 * 1024 * 1024 // 10MB buffer
      });
      if (stderr && !stderr.includes('warning')) {
        console.error('‚ö†Ô∏è Featured stderr:', stderr);
      }
      if (stdout) {
        console.log('üìÑ Featured stdout:', stdout.substring(0, 1000)); // Limit output
      }
      results.success.push({ script: 'Featured Games Import', details: stdout || 'Completed' });
      console.log('‚úÖ [2/4] Featured games import completed');
    } catch (error) {
      console.error('‚ùå [2/4] Featured games import failed:', error.message);
      console.error('Stack:', error.stack);
      if (error.stdout) console.error('stdout:', error.stdout);
      if (error.stderr) console.error('stderr:', error.stderr);
      results.failed.push({ script: 'Featured Games', error: error.message, stdout: error.stdout, stderr: error.stderr });
    }
    
    // 3. Run all stats scrapers
    console.log('\nüìä [3/4] Running all stats scrapers...');
    console.log('-'.repeat(70));
    try {
      const { runAllStatsScrapers } = await import('./run-all-stats-scrapers.js');
      const statsResult = await runAllStatsScrapers();
      console.log('üìä Stats scrapers result:', JSON.stringify(statsResult, null, 2));
      results.success.push({ script: 'Stats Scrapers', details: statsResult || 'Completed' });
      console.log('‚úÖ [3/4] Stats scrapers completed');
    } catch (error) {
      console.error('‚ùå [3/4] Stats scrapers failed:', error.message);
      console.error('Stack:', error.stack);
      results.failed.push({ script: 'Stats Scrapers', error: error.message, stack: error.stack });
    }
    
    // 4. Scrape all standings
    console.log('\nüèÜ [4/4] Scraping all standings...');
    console.log('-'.repeat(70));
    try {
      const scriptPath = join(__dirname, 'scrape-all-standings.cjs');
      console.log(`üìù Running: node ${scriptPath}`);
      const { stdout, stderr } = await execPromise(`node "${scriptPath}"`, {
        cwd: __dirname,
        maxBuffer: 10 * 1024 * 1024 // 10MB buffer
      });
      if (stderr && !stderr.includes('warning')) {
        console.error('‚ö†Ô∏è Standings stderr:', stderr);
      }
      if (stdout) {
        console.log('üìÑ Standings stdout:', stdout.substring(0, 1000)); // Limit output
      }
      results.success.push({ script: 'Standings Scraper', details: stdout || 'Completed' });
      console.log('‚úÖ [4/4] Standings scraper completed');
    } catch (error) {
      console.error('‚ùå [4/4] Standings scraper failed:', error.message);
      console.error('Stack:', error.stack);
      if (error.stdout) console.error('stdout:', error.stdout);
      if (error.stderr) console.error('stderr:', error.stderr);
      results.failed.push({ script: 'Standings', error: error.message, stdout: error.stdout, stderr: error.stderr });
    }
    
    results.endTime = new Date();
    const duration = (results.endTime - results.startTime) / 1000;
    
    console.log('\n' + '='.repeat(70));
    console.log(`üìä [${executionId}] Morning Refresh Summary:`);
    console.log(`‚úÖ Success: ${results.success.length} scripts`);
    console.log(`‚ùå Failed: ${results.failed.length} scripts`);
    console.log(`‚è±Ô∏è  Duration: ${duration.toFixed(2)}s`);
    if (results.failed.length > 0) {
      console.log('\n‚ùå Failed Scripts:');
      results.failed.forEach(f => {
        console.log(`  - ${f.script}: ${f.error}`);
      });
    }
    console.log('='.repeat(70));
    
    res.status(200).json({
      message: 'Morning refresh completed',
      executionId,
      results,
      duration: `${duration.toFixed(2)}s`,
      timestamp: results.endTime.toISOString()
    });
  } catch (error) {
    console.error(`\nüí• [${executionId}] Fatal error in morning refresh:`, error);
    console.error('Stack:', error.stack);
    res.status(500).json({ 
      error: 'Morning refresh failed', 
      executionId,
      details: error.message,
      stack: error.stack,
      timestamp: new Date().toISOString()
    });
  }
};

app.post('/morningRefresh', morningRefreshHandler);
app.get('/morningRefresh', morningRefreshHandler);

// =================================================================
// PERSPECTIVES SYSTEM ENDPOINTS
// =================================================================

// Add manual social post to a game
const addManualPostHandler = async (req, res) => {
  try {
    const { gameId, url, priority = 50, sourceType = 'fan', addedBy = 'admin', notes = null, tags = ['manual'] } = req.body;
    
    if (!gameId || !url) {
      return res.status(400).json({ error: 'gameId and url are required' });
    }
    
    const { addManualPost, ensureGameSocialStructure } = await loadPerspectivesCore();
    
    // Ensure game has social structure
    await ensureGameSocialStructure(gameId);
    
    // Add the post
    const post = await addManualPost(gameId, url, {
      priority: parseInt(priority),
      sourceType,
      addedBy,
      notes,
      tags: Array.isArray(tags) ? tags : [tags]
    });
    
    res.status(200).json({
      success: true,
      message: 'Manual post added successfully',
      post
    });
  } catch (error) {
    console.error('Error adding manual post:', error);
    res.status(500).json({
      error: 'Failed to add manual post',
      details: error.message
    });
  }
};

// Get all social posts for a game
const getGameSocialPostsHandler = async (req, res) => {
  try {
    const { gameId } = req.query;

    if (!gameId) {
      return res.status(400).json({ error: 'gameId is required' });
    }

    const { getGameSocialPosts } = await loadPerspectivesCore();
    const posts = await getGameSocialPosts(gameId);

    res.status(200).json({
      success: true,
      gameId,
      posts,
      count: posts.length
    });
  } catch (error) {
    console.error('Error getting game social posts:', error);
    res.status(500).json({
      error: 'Failed to get game social posts',
      details: error.message
    });
  }
};

// Match a post to games (for automated ingestion)
const matchPostHandler = async (req, res) => {
  try {
    const { title, description, url, timestamp, league } = req.body;
    
    if (!title && !description) {
      return res.status(400).json({ error: 'title or description is required' });
    }
    
    const { matchPostToGames } = await loadPerspectivesCore();
    
    const post = {
      title,
      description,
      url: url || '',
      timestamp: timestamp || new Date().toISOString()
    };
    
    const matches = await matchPostToGames(post, league || null);
    
    res.status(200).json({
      success: true,
      matches,
      count: matches.length
    });
  } catch (error) {
    console.error('Error matching post to games:', error);
    res.status(500).json({
      error: 'Failed to match post to games',
      details: error.message
    });
  }
};

app.post('/perspectives/addManualPost', addManualPostHandler);
app.get('/perspectives/getGameSocialPosts', getGameSocialPostsHandler);
app.post('/perspectives/matchPost', matchPostHandler);

// =================================================================
// SCRAPE THPORTH.COM CONTENT ENDPOINT
// =================================================================

/**
 * Scrape thporth.com to get all news articles, social posts, and videos
 * Returns content that can be filtered by keywords to match games
 */
const scrapeThporthContentHandler = async (req, res) => {
  let browser = null;
  try {
    const { contentType } = req.query;
    
    // Use Puppeteer to get fully rendered page (RSS.app widgets + rss-feed-service content)
    browser = await puppeteer.launch({
      headless: true,
      executablePath: process.env.PUPPETEER_EXECUTABLE_PATH || undefined,
      args: [
        '--no-sandbox',
        '--disable-setuid-sandbox',
        '--disable-dev-shm-usage',
        '--disable-accelerated-2d-canvas',
        '--disable-gpu'
      ]
    });
    
    const page = await browser.newPage();
    await page.goto('https://thporth.com', { waitUntil: 'networkidle2', timeout: 30000 });
    await page.waitForTimeout(4000); // Wait for RSS.app widgets AND rss-feed-service feeds to load
    
    const html = await page.content();
    await browser.close();
    browser = null;
    
    const $ = cheerio.load(html);
    
    const result = {
      news: [],
      social: [],
      media: [],
      scrapedAt: new Date().toISOString()
    };
    
    // Scrape news articles from the news column
    if (!contentType || contentType === 'news' || contentType === 'all') {
      // Exact selectors from shadow.html: .news-feed-content, rssapp-feed, .rssapp-item
      $('.news-feed-content rssapp-feed .rssapp-item, .news-feed-content .rssapp-item, rssapp-feed .rssapp-item').each((i, elem) => {
        const $item = $(elem);
        const title = $item.find('.rssapp-item-title, h3').first().text().trim();
        const link = $item.find('a').first().attr('href') || '';
        const description = $item.find('.rssapp-item-content, p').first().text().trim();
        const image = $item.find('img').first().attr('src') || '';
        
        if (title) {
          result.news.push({
            id: `news_${i}_${Date.now()}`,
            title,
            description,
            link: link.startsWith('http') ? link : `https://thporth.com${link}`,
            image,
            scrapedAt: new Date().toISOString()
          });
        }
      });
      
      // Also check inside news-feed-content divs directly
      $('.news-feed-content').each((i, container) => {
        const $container = $(container);
        $container.find('.rssapp-item, article, .headlines-item').each((j, elem) => {
          const $item = $(elem);
          const title = $item.find('.rssapp-item-title, h3, h2, a').first().text().trim();
          const link = $item.find('a').first().attr('href') || '';
          const description = $item.find('.rssapp-item-content, p').first().text().trim();
          
          if (title && !result.news.find(n => n.title === title && n.link === link)) {
            result.news.push({
              id: `news_${result.news.length}_${Date.now()}`,
              title,
              description,
              link: link.startsWith('http') ? link : `https://thporth.com${link}`,
              scrapedAt: new Date().toISOString()
            });
          }
        });
      });
      
      console.log(`[scrapeThporth] Found ${result.news.length} news articles`);
    }
    
    // Scrape social posts - gets both RSS.app widgets AND rss-feed-service content
    if (!contentType || contentType === 'social' || contentType === 'all') {
      $('#social-feed-container').each((i, container) => {
        const $container = $(container);
        
        // RSS.app items
        $container.find('rssapp-feed .rssapp-item, .rssapp-item').each((j, elem) => {
          const $item = $(elem);
          const text = $item.find('.rssapp-item-content, p').first().text().trim();
          const title = $item.find('.rssapp-item-title, h3').first().text().trim();
          const link = $item.find('a').first().attr('href') || '';
          const image = $item.find('img').first().attr('src') || '';
          const platform = link.includes('twitter.com') ? 'twitter' :
                          link.includes('x.com') ? 'x' :
                          link.includes('reddit.com') ? 'reddit' : 'unknown';
          
          if (text || title) {
            result.social.push({
              id: `social_${result.social.length}_${Date.now()}`,
              text: text || title,
              title: title || text,
              description: text || title,
              link: link.startsWith('http') ? link : `https://thporth.com${link}`,
              image,
              platform,
              scrapedAt: new Date().toISOString()
            });
          }
        });
        
        // Regular RSS feed items (from rss-feed-service)
        $container.find('li, article, .item').each((j, elem) => {
          const $item = $(elem);
          const text = $item.find('p, .description').first().text().trim();
          const title = $item.find('h3, h2, a').first().text().trim();
          const link = $item.find('a').first().attr('href') || '';
          
          if ((text || title) && !result.social.find(s => s.link === link && link)) {
            result.social.push({
              id: `social_${result.social.length}_${Date.now()}`,
              text: text || title,
              title: title || text,
              description: text || title,
              link: link.startsWith('http') ? link : `https://thporth.com${link}`,
              scrapedAt: new Date().toISOString()
            });
          }
        });
      });
      
      console.log(`[scrapeThporth] Found ${result.social.length} social posts`);
    }
    
    // Scrape videos/media - gets both RSS.app widgets AND rss-feed-service content
    if (!contentType || contentType === 'media' || contentType === 'all') {
      $('#videos-content, #dynamicVideosContent').each((i, container) => {
        const $container = $(container);
        
        // Video items
        $container.find('.video-item').each((j, elem) => {
          const $item = $(elem);
          const title = $item.find('h3, h2, a').first().text().trim();
          const link = $item.find('a').first().attr('href') || '';
          const thumbnail = $item.find('img.video-thumbnail, img').first().attr('src') || '';
          
          if (title || link) {
            result.media.push({
              id: `media_${result.media.length}_${Date.now()}`,
              title: title || 'Video',
              link: link.startsWith('http') ? link : `https://thporth.com${link}`,
              thumbnail,
              scrapedAt: new Date().toISOString()
            });
          }
        });
        
        // RSS.app video items
        $container.find('rssapp-feed .rssapp-item').each((j, elem) => {
          const $item = $(elem);
          const title = $item.find('.rssapp-item-title, h3').first().text().trim();
          const link = $item.find('a').first().attr('href') || '';
          const thumbnail = $item.find('img').first().attr('src') || '';
          
          if (title && !result.media.find(m => m.title === title && m.link === link)) {
            result.media.push({
              id: `media_${result.media.length}_${Date.now()}`,
              title,
              link: link.startsWith('http') ? link : `https://thporth.com${link}`,
              thumbnail,
              scrapedAt: new Date().toISOString()
            });
          }
        });
        
        // Regular RSS feed items (from rss-feed-service)
        $container.find('li, article, .item').each((j, elem) => {
          const $item = $(elem);
          const title = $item.find('h3, h2, a').first().text().trim();
          const link = $item.find('a').first().attr('href') || '';
          const thumbnail = $item.find('img').first().attr('src') || '';
          
          if (title && !result.media.find(m => m.title === title && m.link === link)) {
            result.media.push({
              id: `media_${result.media.length}_${Date.now()}`,
              title,
              link: link.startsWith('http') ? link : `https://thporth.com${link}`,
              thumbnail,
              scrapedAt: new Date().toISOString()
            });
          }
        });
      });
      
      // YouTube embeds
      $('iframe[src*="youtube.com"], iframe[src*="youtu.be"]').each((i, elem) => {
        const $iframe = $(elem);
        const src = $iframe.attr('src') || '';
        const videoId = src.match(/(?:youtube\.com\/embed\/|youtu\.be\/)([^?&]+)/)?.[1];
        
        if (videoId && !result.media.find(m => m.link && m.link.includes(videoId))) {
          result.media.push({
            id: `media_youtube_${i}_${Date.now()}`,
            title: $iframe.attr('title') || 'YouTube Video',
            link: `https://www.youtube.com/watch?v=${videoId}`,
            thumbnail: `https://img.youtube.com/vi/${videoId}/hqdefault.jpg`,
            platform: 'youtube',
            scrapedAt: new Date().toISOString()
          });
        }
      });
      
      console.log(`[scrapeThporth] Found ${result.media.length} media items`);
    }
    
    // Filter by contentType if specified
    if (contentType && contentType !== 'all') {
      res.status(200).json({
        success: true,
        contentType,
        items: result[contentType],
        count: result[contentType].length
      });
    } else {
      res.status(200).json({
        success: true,
        ...result,
        totalNews: result.news.length,
        totalSocial: result.social.length,
        totalMedia: result.media.length
      });
    }
    
  } catch (error) {
    console.error('[scrapeThporth] Error scraping thporth.com:', error);
    if (browser) {
      try {
        await browser.close();
      } catch (e) {
        console.error('[scrapeThporth] Error closing browser:', e);
      }
    }
    res.status(500).json({
      error: 'Failed to scrape thporth.com',
      details: error.message
    });
  }
};

app.get('/scrapeThporth', scrapeThporthContentHandler);
app.post('/scrapeThporth', scrapeThporthContentHandler);

// =================================================================
// PERSPECTIVES PIPELINE ENDPOINT
// =================================================================

const perspectivesPipelineHandler = async (req, res) => {
  try {
    const { runPerspectivesPipeline } = await import('./perspectives-pipeline.js');
    
    const {
      league,
      keywordSource, // Can be local file path (e.g., './nhl-keywords.csv') or Google Sheets CSV URL
      contentSources = null, // null = auto-load from perspectives-feed-config.js
      gameDate = null
    } = req.body;
    
    if (!league || !keywordSource) {
      return res.status(400).json({
        error: 'league and keywordSource are required',
        examples: {
          googleSheets: {
            league: 'NHL',
            keywordSource: 'https://docs.google.com/spreadsheets/d/SPREADSHEET_ID/export?gid=0&format=csv',
            contentSources: null // null = auto-load from perspectives-feed-config.js
          },
          localFile: {
            league: 'NHL',
            keywordSource: './nhl-keywords.csv',
            contentSources: null
          }
        }
      });
    }
    
    await runPerspectivesPipeline({
      league,
      keywordSource,
      contentSources,
      gameDate
    });
    
    res.status(200).json({
      success: true,
      message: `Perspectives pipeline completed for ${league}`
    });
  } catch (error) {
    console.error('[perspectivesPipeline] Error:', error);
    res.status(500).json({
      error: 'Failed to run Perspectives pipeline',
      details: error.message
    });
  }
};

app.post('/perspectives/runPipeline', perspectivesPipelineHandler);
app.get('/perspectives/runPipeline', perspectivesPipelineHandler);

// =================================================================
// LIVE SCORES JSON ENDPOINT
// =================================================================

// In-memory cache for today's games JSON
let todayGamesCache = null;
let todayGamesCacheTimestamp = null;
const TODAY_GAMES_CACHE_TTL = 120000; // 2 minutes cache (matches backend update frequency)

/**
 * Generate JSON object with all today's games from Firestore
 * Only reads from Firestore once, caches result for 5 seconds
 */
async function generateTodayGamesJSON() {
  const now = Date.now();
  
  // Return cached data if still valid
  if (todayGamesCache && todayGamesCacheTimestamp && (now - todayGamesCacheTimestamp) < TODAY_GAMES_CACHE_TTL) {
    return todayGamesCache;
  }
  
  const db = initializeFirebase();
  const todayStr = DateTime.now().setZone('America/New_York').toISODate();
  
  try {
    console.log(`[today.json] Fetching games for ${todayStr} from Firestore...`);
    
    const gamesRef = db.collection(`artifacts/flashlive-daily-scraper/public/data/sportsGames`);
    const snapshot = await gamesRef.where('gameDate', '==', todayStr).get();
    
    const games = [];
    snapshot.forEach(doc => {
      const data = doc.data();
      // Preserve original Firestore field names to match frontend expectations
      const gameData = {
        'Game ID': doc.id,
        ...data // Spread all original fields
      };
      games.push(gameData);
    });
    
    const result = {
      lastUpdated: new Date().toISOString(),
      date: todayStr,
      gameCount: games.length,
      games: games
    };
    
    // Update cache
    todayGamesCache = result;
    todayGamesCacheTimestamp = now;
    
    console.log(`[today.json] Generated JSON with ${games.length} games`);
    return result;
  } catch (error) {
    console.error('[today.json] Error generating JSON:', error);
    // Return cached data if available, even if expired
    if (todayGamesCache) {
      console.log('[today.json] Returning cached data due to error');
      return todayGamesCache;
    }
    throw error;
  }
}

/**
 * Handler for /data/today.json endpoint
 * Serves live games data as JSON
 */
const todayGamesJSONHandler = async (req, res) => {
  try {
    const json = await generateTodayGamesJSON();
    
    // Set CORS headers to allow frontend access
    res.set('Access-Control-Allow-Origin', '*');
    res.set('Access-Control-Allow-Methods', 'GET, OPTIONS');
    res.set('Access-Control-Allow-Headers', 'Content-Type, Cache-Control, Pragma');
    res.set('Content-Type', 'application/json');
    res.set('Cache-Control', 'no-store, no-cache, must-revalidate, proxy-revalidate');
    res.set('Pragma', 'no-cache');
    res.set('Expires', '0');
    
    res.status(200).json(json);
  } catch (error) {
    console.error('[today.json] Handler error:', error);
    res.status(500).json({
      error: 'Failed to generate today\'s games JSON',
      message: error.message
    });
  }
};

// Handle OPTIONS requests for CORS preflight
app.options('/data/today.json', (req, res) => {
  res.set('Access-Control-Allow-Origin', '*');
  res.set('Access-Control-Allow-Methods', 'GET, OPTIONS');
  res.set('Access-Control-Allow-Headers', 'Content-Type, Cache-Control, Pragma');
  res.status(204).end();
});

// Serve today's games JSON at /data/today.json
app.get('/data/today.json', todayGamesJSONHandler);
app.get('/public/data/today.json', todayGamesJSONHandler);

// =================================================================
// STATIC DATA EXPORT ENDPOINTS
// These endpoints serve static JSON files generated from Firestore
// Backend reads from Firestore once, frontend fetches from these endpoints
// =================================================================

/**
 * Helper function to serialize Firestore Timestamps and data
 */
function serializeFirestoreData(data) {
  if (data === null || data === undefined) return data;
  if (data instanceof Date) return data.toISOString();
  if (data && typeof data === 'object' && data.toDate && typeof data.toDate === 'function') {
    return data.toDate().toISOString();
  }
  if (data && typeof data === 'object' && data._seconds !== undefined) {
    return new Date(data._seconds * 1000).toISOString();
  }
  if (Array.isArray(data)) {
    return data.map(serializeFirestoreData);
  }
  if (typeof data === 'object') {
    const result = {};
    for (const key in data) {
      result[key] = serializeFirestoreData(data[key]);
    }
    return result;
  }
  return data;
}

// Serve yesterday's scores JSON
app.get('/data/yesterday.json', async (req, res) => {
  try {
    const db = initializeFirebase();
    // Use Eastern Time to match gameDate storage (same as today.json)
    const nowInEastern = DateTime.now().setZone('America/New_York');
    const yesterdayStr = nowInEastern.minus({ days: 1 }).toISODate();
    
    // Query sportsGames collection for yesterday's date (same as original frontend code)
    const sportsGamesRef = db.collection('artifacts/flashlive-daily-scraper/public/data/sportsGames');
    const snapshot = await sportsGamesRef.where('gameDate', '==', yesterdayStr).get();
    
    const games = [];
    snapshot.forEach(doc => {
      const data = doc.data();
      games.push({
        'Game ID': doc.id,
        ...serializeFirestoreData(data)
      });
    });
    
    const data = {
      lastUpdated: new Date().toISOString(),
      date: yesterdayStr,
      gameCount: games.length,
      games: games
    };
    
    res.set('Access-Control-Allow-Origin', '*');
    res.set('Content-Type', 'application/json');
    res.json(data);
  } catch (error) {
    res.status(500).json({ error: error.message });
  }
});

// Serve featured games JSON
app.get('/data/featured.json', async (req, res) => {
  try {
    const db = initializeFirebase();
    const today = DateTime.now().setZone('America/New_York').toISODate();
    
    const featuredRef = db.collection('artifacts/flashlive-daily-scraper/public/data/Featured');
    const snapshot = await featuredRef.where('gameDate', '==', today).get();
    
    const games = [];
    snapshot.forEach(doc => {
      const data = doc.data();
      games.push({
        id: doc.id,
        ...serializeFirestoreData(data)
      });
    });
    
    games.sort((a, b) => {
      if (a.order !== undefined && b.order !== undefined) {
        return a.order - b.order;
      }
      return 0;
    });
    
    const data = {
      lastUpdated: new Date().toISOString(),
      date: today,
      gameCount: games.length,
      games: games
    };
    
    res.set('Access-Control-Allow-Origin', '*');
    res.set('Content-Type', 'application/json');
    res.json(data);
  } catch (error) {
    res.status(500).json({ error: error.message });
  }
});

// Serve F1 Driver Standings JSON
app.get('/data/f1-driver-standings.json', async (req, res) => {
  try {
    const db = initializeFirebase();
    const snapshot = await db.collection('F1DriverStandings').get();
    
    const standings = [];
    snapshot.forEach(doc => {
      standings.push({
        id: doc.id,
        ...serializeFirestoreData(doc.data())
      });
    });
    
    const data = {
      lastUpdated: new Date().toISOString(),
      standings: standings
    };
    
    res.set('Access-Control-Allow-Origin', '*');
    res.set('Content-Type', 'application/json');
    res.json(data);
  } catch (error) {
    res.status(500).json({ error: error.message });
  }
});

// Serve F1 Constructor Standings JSON
app.get('/data/f1-constructor-standings.json', async (req, res) => {
  try {
    const db = initializeFirebase();
    const snapshot = await db.collection('F1ConstructorStandings').get();
    
    const standings = [];
    snapshot.forEach(doc => {
      standings.push({
        id: doc.id,
        ...serializeFirestoreData(doc.data())
      });
    });
    
    const data = {
      lastUpdated: new Date().toISOString(),
      standings: standings
    };
    
    res.set('Access-Control-Allow-Origin', '*');
    res.set('Content-Type', 'application/json');
    res.json(data);
  } catch (error) {
    res.status(500).json({ error: error.message });
  }
});

// Serve F1 Schedule JSON
app.get('/data/f1-schedule.json', async (req, res) => {
  try {
    const db = initializeFirebase();
    const snapshot = await db.collection('FormulaOne').get();
    
    const events = [];
    snapshot.forEach(doc => {
      events.push({
        id: doc.id,
        ...serializeFirestoreData(doc.data())
      });
    });
    
    const data = {
      lastUpdated: new Date().toISOString(),
      events: events
    };
    
    res.set('Access-Control-Allow-Origin', '*');
    res.set('Content-Type', 'application/json');
    res.json(data);
  } catch (error) {
    res.status(500).json({ error: error.message });
  }
});

// Serve Standings JSON (all leagues)
app.get('/data/standings.json', async (req, res) => {
  try {
    const db = initializeFirebase();
    
    // Map of all standings collections (matching frontend collectionMap)
    const collectionsMap = {
      'EPLStandings': 'EPLStandings',
      'LaLigaStandings': 'LaLigaStandings',
      'SerieAStandings': 'SerieAStandings',
      'BundesligaStandings': 'BundesligaStandings',
      'Ligue1Standings': 'Ligue1Standings',
      'MLSStandings': 'MLSStandings',
      'LigaMXStandings': 'LigaMXStandings',
      'NWSLStandings': 'NWSLStandings',
      'UEFAEuropaLeagueStandings': 'UEFAEuropaLeagueStandings',
      'UEFAConferenceLeagueStandings': 'UEFAConferenceLeagueStandings',
      'NFLStandings': 'NFLStandings',
      'MLBStandings': 'MLBStandings',
      'NBAStandings': 'NBAStandings',
      'NHLStandings': 'NHLStandings',
      'NCAAFStandings': 'NCAAFStandings',
      'NCAAMStandings': 'NCAAMStandings',
      'NCAAWStandings': 'NCAAWStandings',
      'AFCChampionsLeagueStandings': 'AFCChampionsLeagueStandings',
      'F1DriverStandings': 'F1DriverStandings',
      'FACupStandings': 'FACupStandings',
      'PGATourStandings': 'PGATourStandings',
      'LPGATourStandings': 'LPGATourStandings',
      'UFCStandings': 'UFCStandings',
      'BoxingStandings': 'BoxingStandings',
      'NASCARCupSeriesStandings': 'NASCARCupSeriesStandings',
      'TennisStandings': 'TennisStandings',
      'LIVGolfStandings': 'LIVGolfStandings',
      'IndyCarStandings': 'IndyCarStandings',
      'MotoGPStandings': 'MotoGPStandings',
      'TrackAndFieldStandings': 'TrackAndFieldStandings',
      'SoccerStandings': 'SoccerStandings',
      'NCAABaseballStandings': 'NCAABaseballStandings',
      'NCAASoftballStandings': 'NCAASoftballStandings',
      'WorldCupU17Standings': 'WorldCupU17Standings',
      'WorldCupU17PlayOffsStandings': 'WorldCupU17PlayOffsStandings',
      'standings': 'standings' // Generic standings collection (for UCL, WNBA)
    };
    
    const allStandings = {};
    
    // Fetch from all collections in parallel
    const promises = Object.entries(collectionsMap).map(async ([key, collectionName]) => {
      try {
        const snapshot = await db.collection(collectionName).get();
        const teams = [];
        snapshot.forEach(doc => {
          teams.push(serializeFirestoreData(doc.data()));
        });
        if (teams.length > 0) {
          allStandings[key] = teams;
        }
      } catch (error) {
        console.error(`Error fetching ${collectionName}:`, error);
        // Continue with other collections even if one fails
      }
    });
    
    await Promise.all(promises);
    
    // Also fetch from generic 'standings' collection with league field
    try {
      const genericSnapshot = await db.collection('standings').get();
      const genericStandings = {};
      genericSnapshot.forEach(doc => {
        const data = serializeFirestoreData(doc.data());
        const league = data.league || 'unknown';
        if (!genericStandings[league]) {
          genericStandings[league] = [];
        }
        genericStandings[league].push(data);
      });
      // Merge into allStandings
      Object.assign(allStandings, genericStandings);
    } catch (error) {
      console.error('Error fetching generic standings:', error);
    }
    
    const data = {
      lastUpdated: new Date().toISOString(),
      standings: allStandings
    };
    
    res.set('Access-Control-Allow-Origin', '*');
    res.set('Content-Type', 'application/json');
    res.json(data);
  } catch (error) {
    res.status(500).json({ error: error.message });
  }
});

// Serve MLB Stats JSON
app.get('/data/mlb-stats.json', async (req, res) => {
  try {
    const db = initializeFirebase();
    const snapshot = await db.collection('mlb_stats').get();
    
    const stats = {};
    snapshot.forEach(doc => {
      stats[doc.id] = serializeFirestoreData(doc.data());
    });
    
    const data = {
      lastUpdated: new Date().toISOString(),
      stats: stats
    };
    
    res.set('Access-Control-Allow-Origin', '*');
    res.set('Content-Type', 'application/json');
    res.json(data);
  } catch (error) {
    res.status(500).json({ error: error.message });
  }
});

// Serve NBA Stats JSON
app.get('/data/nba-stats.json', async (req, res) => {
  try {
    const db = initializeFirebase();
    const playerStatsSnapshot = await db.collection('nbaStats').get();
    const teamStatsSnapshot = await db.collection('nbaTeamStats').get();
    
    const playerStats = {};
    playerStatsSnapshot.forEach(doc => {
      playerStats[doc.id] = serializeFirestoreData(doc.data());
    });
    
    const teamStats = {};
    teamStatsSnapshot.forEach(doc => {
      teamStats[doc.id] = serializeFirestoreData(doc.data());
    });
    
    const data = {
      lastUpdated: new Date().toISOString(),
      playerStats: playerStats,
      teamStats: teamStats
    };
    
    res.set('Access-Control-Allow-Origin', '*');
    res.set('Content-Type', 'application/json');
    res.json(data);
  } catch (error) {
    res.status(500).json({ error: error.message });
  }
});

// Serve CFP Standings JSON
// Serve Top 25 rankings for NCAA leagues
app.get('/data/top25/:leagueKey.json', async (req, res) => {
  try {
    const { leagueKey } = req.params;
    const db = initializeFirebase();
    
    const collectionMap = {
      'NCAAF': 'NCAAFStandings',
      'NCAAM': 'NCAAMStandings',
      'NCAAW': 'NCAAWStandings'
    };
    
    const collectionName = collectionMap[leagueKey];
    if (!collectionName) {
      return res.status(400).json({ error: 'Invalid league key' });
    }
    
    const snapshot = await db.collection(collectionName).get();
    const teams = [];
    
    snapshot.forEach(doc => {
      const team = serializeFirestoreData(doc.data());
      // Only include teams with Top25Rank
      if (team.Top25Rank !== null && team.Top25Rank !== undefined) {
        teams.push(team);
      }
    });
    
    // Sort by rank
    teams.sort((a, b) => {
      const rankA = parseInt(a.Top25Rank) || 999;
      const rankB = parseInt(b.Top25Rank) || 999;
      return rankA - rankB;
    });
    
    res.set('Access-Control-Allow-Origin', '*');
    res.set('Content-Type', 'application/json');
    res.json({
      lastUpdated: new Date().toISOString(),
      teams: teams
    });
  } catch (error) {
    console.error(`Error fetching Top 25 for ${req.params.leagueKey}:`, error);
    res.status(500).json({ error: error.message });
  }
});

// Serve NCAA standings for a specific league
app.get('/data/ncaa-standings/:leagueKey.json', async (req, res) => {
  try {
    const { leagueKey } = req.params;
    const db = initializeFirebase();
    
    const collectionMap = {
      'NCAAF': 'NCAAFStandings',
      'NCAAM': 'NCAAMStandings',
      'NCAAW': 'NCAAWStandings'
    };
    
    const collectionName = collectionMap[leagueKey];
    if (!collectionName) {
      return res.status(400).json({ error: 'Invalid league key' });
    }
    
    const snapshot = await db.collection(collectionName).get();
    const teams = [];
    
    snapshot.forEach(doc => {
      teams.push(serializeFirestoreData(doc.data()));
    });
    
    res.set('Access-Control-Allow-Origin', '*');
    res.set('Content-Type', 'application/json');
    res.json({
      lastUpdated: new Date().toISOString(),
      teams: teams
    });
  } catch (error) {
    console.error(`Error fetching standings for ${req.params.leagueKey}:`, error);
    res.status(500).json({ error: error.message });
  }
});

app.get('/data/cfp-standings.json', async (req, res) => {
  try {
    const db = initializeFirebase();
    const snapshot = await db.collection('CFP').get();
    
    const standings = [];
    snapshot.forEach(doc => {
      standings.push({
        id: doc.id,
        ...serializeFirestoreData(doc.data())
      });
    });
    
    const data = {
      lastUpdated: new Date().toISOString(),
      standings: standings
    };
    
    res.set('Access-Control-Allow-Origin', '*');
    res.set('Content-Type', 'application/json');
    res.json(data);
  } catch (error) {
    res.status(500).json({ error: error.message });
  }
});

// Serve Today Slate JSON
app.get('/data/today-slate.json', async (req, res) => {
  try {
    const db = initializeFirebase();
    const docRef = db.collection('system').doc('todaySlate');
    const doc = await docRef.get();
    
    const data = {
      lastUpdated: new Date().toISOString(),
      slate: doc.exists ? serializeFirestoreData(doc.data()) : null
    };
    
    res.set('Access-Control-Allow-Origin', '*');
    res.set('Content-Type', 'application/json');
    res.json(data);
  } catch (error) {
    res.status(500).json({ error: error.message });
  }
});

// Endpoint to get game-specific content (replaces direct Firestore access)
app.get('/data/game/:gameId.json', async (req, res) => {
  try {
    const db = initializeFirebase();
    const gameId = req.params.gameId;
    
    const gameDocRef = db.collection("artifacts/flashlive-daily-scraper/public/data/sportsGames").doc(gameId);
    const gameDoc = await gameDocRef.get();
    
    if (!gameDoc.exists) {
      res.status(404).json({ error: 'Game not found' });
      return;
    }
    
    const data = {
      'Game ID': gameDoc.id,
      ...serializeFirestoreData(gameDoc.data())
    };
    
    res.set('Access-Control-Allow-Origin', '*');
    res.set('Content-Type', 'application/json');
    res.json(data);
  } catch (error) {
    res.status(500).json({ error: error.message });
  }
});

// Catch-all route to log all requests (for debugging Gen2 routing)
app.use((req, res, next) => {
  if (req.path !== '/pollESPNLiveData' && req.path !== '/morningRefresh' && req.path !== '/') {
    console.log(`‚ö†Ô∏è Unhandled request: ${req.method} ${req.path} from ${req.headers?.['user-agent'] || 'unknown'}`);
  }
  next();
});

// For local development only
if (process.env.NODE_ENV !== 'production' && !process.env.FUNCTION_TARGET) {
  const PORT = process.env.PORT || 8080;
  app.listen(PORT, () => {
    console.log(`Server listening on port ${PORT}`);
  });
}

// Export for Cloud Functions
export default app;






